{"version":3,"file":"paint.cjs.prod.js","sources":["../src/fromPaintExpression.ts","../src/typeHelpers.ts","../src/preparePaint.ts"],"sourcesContent":["import { evaluate, type Expression, isExpression } from '@nextgis/expression';\n\nimport type { Feature } from 'geojson';\n\nimport type { GetPaintCallback, VectorAdapterLayerPaint } from './interfaces';\n\ntype PropertyExpressionCb = (feature: Feature) => ReturnType<typeof evaluate>;\n\nfunction createPropertyExpressionCb(\n  expression: Expression,\n): PropertyExpressionCb {\n  return (feature: Feature) => {\n    const properties = feature.properties;\n    if (properties) {\n      return evaluate(expression, properties);\n    }\n    return false;\n  };\n}\n\nconst excludeExpressionList = ['iconSize', 'iconAnchor'];\n\nexport function createExpressionCallback(\n  paint: Record<string, any>,\n): GetPaintCallback | undefined {\n  let withExpression = false;\n  const expressions: {\n    [key: string]: PropertyExpressionCb;\n  } = {};\n  for (const p in paint) {\n    if (excludeExpressionList.indexOf(p) === -1) {\n      const p_ = p as keyof VectorAdapterLayerPaint;\n      const val = paint[p_];\n      if (isExpression(val)) {\n        withExpression = true;\n        expressions[p_] = createPropertyExpressionCb(val);\n      }\n    }\n  }\n  if (withExpression) {\n    return (feature: Feature) => {\n      const fromCb: any = {};\n      for (const p in expressions) {\n        fromCb[p] = expressions[p](feature);\n      }\n      return { ...paint, ...fromCb };\n    };\n  }\n  return;\n}\n","import type {\n  GeometryPaint,\n  GetPaintCallback,\n  IconPaint,\n  Paint,\n  PropertiesPaint,\n  VectorAdapterLayerPaint,\n} from './interfaces';\n\nexport function isPropertiesPaint(paint: Paint): paint is PropertiesPaint {\n  if (Array.isArray(paint)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPaint(paint: Paint): paint is VectorAdapterLayerPaint {\n  if (Object.prototype.toString.call(paint) === '[object Object]') {\n    return true;\n  }\n  return false;\n}\n\nexport function isBasePaint(paint: Paint): paint is GeometryPaint {\n  if (isPaint(paint)) {\n    if (paint.type === 'get-paint' || paint.type === 'icon') {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function isPaintCallback(paint: Paint): paint is GetPaintCallback {\n  if (typeof paint === 'function') {\n    return true;\n  }\n  return false;\n}\n\nexport function isIcon(paint: IconPaint): paint is IconPaint {\n  return paint.type === 'icon' || 'html' in paint;\n}\n","import { featureFilter } from '@nextgis/properties-filter';\n\nimport { createExpressionCallback } from './fromPaintExpression';\nimport { isPaintCallback, isPropertiesPaint } from './typeHelpers';\n\nimport type { Feature } from 'geojson';\n\nimport type {\n  GeometryPaint,\n  GetCustomPaintOptions,\n  GetPaintCallback,\n  GetPaintFunction,\n  Paint,\n  PropertiesPaint,\n  PropertyPaint,\n  VectorAdapterLayerPaint,\n} from './interfaces';\n\nfunction updatePaintOptionFromCallback(\n  paint: GetCustomPaintOptions,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): VectorAdapterLayerPaint | undefined {\n  if (typeof paint.from === 'function') {\n    return paint.from(paint.options);\n  } else if (typeof paint.from === 'string' && getPaintFunctions) {\n    const from = getPaintFunctions[paint.from];\n    if (from) {\n      return from(paint.options);\n    }\n  }\n}\n\nfunction createPropertiesPaint(\n  propertiesPaint: PropertiesPaint,\n): GetPaintFunction {\n  let mask: VectorAdapterLayerPaint = {};\n  const paintsFilters: PropertyPaint[] = [];\n  for (const p of propertiesPaint) {\n    if (p) {\n      if (Array.isArray(p)) {\n        paintsFilters.push(p);\n      } else {\n        mask = p as VectorAdapterLayerPaint;\n      }\n    }\n  }\n\n  return (feature: Feature) => {\n    const paint = paintsFilters.find((x) => featureFilter(feature, x[0]));\n    if (paint) {\n      return { ...mask, ...paint[1] };\n    }\n    return mask;\n  };\n}\n\nfunction expressionCallback({\n  paint,\n  defaultPaint,\n}: PreparePaintOptions): Paint | VectorAdapterLayerPaint {\n  const expressionCallback = createExpressionCallback(paint);\n  if (expressionCallback) {\n    const expressionPaintCb = (feature: Feature) => {\n      return preparePaint({\n        paint: expressionCallback(feature),\n        defaultPaint,\n      }) as VectorAdapterLayerPaint;\n    };\n    expressionPaintCb.paint = finalizePaint({ paint, defaultPaint });\n    return expressionPaintCb as VectorAdapterLayerPaint;\n  }\n  return finalizePaint({ paint, defaultPaint });\n}\n\nfunction finalizePaint({ paint, defaultPaint }: PreparePaintOptions): Paint {\n  let newPaint: Paint = { ...defaultPaint };\n  newPaint = { ...newPaint, ...paint } as GeometryPaint;\n  newPaint.fill = newPaint.fill ?? true;\n  newPaint.stroke =\n    newPaint.stroke !== undefined\n      ? newPaint.stroke\n      : !newPaint.fill || !!(newPaint.strokeColor || newPaint.strokeOpacity);\n  return newPaint;\n}\n\nexport interface PreparePaintOptions {\n  paint: Paint;\n  defaultPaint?: GeometryPaint;\n  getPaintFunctions?: { [name: string]: GetPaintFunction };\n}\n\nexport function preparePaint({\n  paint,\n  defaultPaint,\n  getPaintFunctions,\n}: PreparePaintOptions): Paint {\n  if (!paint) {\n    throw new Error('paint is empty');\n  }\n  let newPaint: Paint = { ...defaultPaint };\n  if (isPaintCallback(paint)) {\n    const getPaintFunction: GetPaintCallback = (feature: Feature) => {\n      const getPaint = preparePaint({\n        paint: paint(feature),\n        defaultPaint,\n        getPaintFunctions,\n      }) as VectorAdapterLayerPaint;\n      getPaint.type = paint.type;\n      return getPaint;\n    };\n    getPaintFunction.type = paint.type;\n    return getPaintFunction;\n  } else if (isPropertiesPaint(paint)) {\n    return (feature: Feature) => {\n      return preparePaint({\n        paint: createPropertiesPaint(paint)(feature),\n        defaultPaint,\n        getPaintFunctions,\n      }) as VectorAdapterLayerPaint;\n    };\n  } else if (paint.type === 'get-paint') {\n    const getPaint = updatePaintOptionFromCallback(paint, getPaintFunctions);\n    if (getPaint) {\n      newPaint = preparePaint({\n        paint: getPaint,\n        defaultPaint,\n        getPaintFunctions,\n      });\n    }\n  } else if (paint.type === 'icon') {\n    return paint;\n  } else {\n    newPaint = expressionCallback({ paint, defaultPaint });\n  }\n\n  if (isPaintCallback(newPaint)) {\n    return newPaint;\n  }\n\n  if ('color' in newPaint) {\n    if (!newPaint.strokeColor) {\n      newPaint.strokeColor = newPaint.color;\n    }\n    if (!newPaint.fillColor) {\n      newPaint.fillColor = newPaint.color;\n    }\n  }\n  if ('opacity' in newPaint) {\n    if (newPaint.strokeOpacity === undefined) {\n      newPaint.strokeOpacity = newPaint.opacity;\n    }\n    if (newPaint.fillOpacity === undefined) {\n      newPaint.fillOpacity = newPaint.opacity;\n    }\n  }\n\n  return newPaint;\n}\n"],"names":["createPropertyExpressionCb","expression","feature","properties","evaluate","excludeExpressionList","createExpressionCallback","paint","withExpression","expressions","p","indexOf","p_","val","isExpression","fromCb","isPropertiesPaint","Array","isArray","isPaint","Object","prototype","toString","call","isPaintCallback","createPropertiesPaint","propertiesPaint","mask","paintsFilters","push","find","x","featureFilter","finalizePaint","defaultPaint","_a","newPaint","fill","stroke","strokeColor","strokeOpacity","preparePaint","getPaintFunctions","Error","getPaintFunction","getPaint","type","from","options","updatePaintOptionFromCallback","expressionCallback","expressionPaintCb","color","fillColor","opacity","fillOpacity"],"mappings":"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"}