import{isExpression as t,evaluate as n}from"@nextgis/expression";import{featureFilter as r}from"@nextgis/properties-filter";var e=Object.defineProperty,o=Object.getOwnPropertySymbols,i=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable,f=(t,n,r)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[n]=r,c=(t,n)=>{for(var r in n||(n={}))i.call(n,r)&&f(t,r,n[r]);if(o)for(var r of o(n))a.call(n,r)&&f(t,r,n[r]);return t};function p(t){return r=>{const e=r.properties;return!!e&&n(t,e)}}const l=["iconSize","iconAnchor"];function u(n){let r=!1;const e={};for(const o in n)if(-1===l.indexOf(o)){const i=o,a=n[i];t(a)&&(r=!0,e[i]=p(a))}if(r)return t=>{const r={};for(const n in e)r[n]=e[n](t);return c(c({},n),r)}}function s(t){return!!Array.isArray(t)}function y(t){return"[object Object]"===Object.prototype.toString.call(t)}function b(t){return!!y(t)&&("get-paint"!==t.type&&"icon"!==t.type)}function O(t){return"function"==typeof t}function P(t){return"icon"===t.type||"html"in t}var d=Object.defineProperty,m=Object.getOwnPropertySymbols,g=Object.prototype.hasOwnProperty,v=Object.prototype.propertyIsEnumerable,j=(t,n,r)=>n in t?d(t,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[n]=r,k=(t,n)=>{for(var r in n||(n={}))g.call(n,r)&&j(t,r,n[r]);if(m)for(var r of m(n))v.call(n,r)&&j(t,r,n[r]);return t};function w(t){let n={};const e=[];for(const r of t)r&&(Array.isArray(r)?e.push(r):n=r);return t=>{const o=e.find((n=>r(t,n[0])));return o?k(k({},n),o[1]):n}}function h({paint:t,defaultPaint:n}){var r;let e=k({},n);return e=k(k({},e),t),e.fill=null==(r=e.fill)||r,e.stroke=void 0!==e.stroke?e.stroke:!e.fill||!(!e.strokeColor&&!e.strokeOpacity),e}function x({paint:t,defaultPaint:n,getPaintFunctions:r}){if(!t)throw new Error("paint is empty");let e=k({},n);if(O(t)){const e=e=>{const o=x({paint:t(e),defaultPaint:n,getPaintFunctions:r});return o.type=t.type,o};return e.type=t.type,e}if(s(t))return e=>x({paint:w(t)(e),defaultPaint:n,getPaintFunctions:r});if("get-paint"===t.type){const o=function(t,n){if("function"==typeof t.from)return t.from(t.options);if("string"==typeof t.from&&n){const r=n[t.from];if(r)return r(t.options)}}(t,r);o&&(e=x({paint:o,defaultPaint:n,getPaintFunctions:r}))}else{if("icon"===t.type)return t;e=function({paint:t,defaultPaint:n}){const r=u(t);if(r){const e=t=>x({paint:r(t),defaultPaint:n});return e.paint=h({paint:t,defaultPaint:n}),e}return h({paint:t,defaultPaint:n})}({paint:t,defaultPaint:n})}return O(e)||("color"in e&&(e.strokeColor||(e.strokeColor=e.color),e.fillColor||(e.fillColor=e.color)),"opacity"in e&&(void 0===e.strokeOpacity&&(e.strokeOpacity=e.opacity),void 0===e.fillOpacity&&(e.fillOpacity=e.opacity))),e}export{u as createExpressionCallback,b as isBasePaint,P as isIcon,y as isPaint,O as isPaintCallback,s as isPropertiesPaint,x as preparePaint};
//# sourceMappingURL=paint.esm-bundler.prod.js.map
