{"version":3,"file":"cancelable-promise.cjs.prod.js","sources":["../src/CancelError.ts","../src/PromiseControl.ts","../src/TimeoutError.ts","../src/CancelablePromise.ts"],"sourcesContent":["export class CancelError extends Error {\n  name = 'CancelError';\n\n  constructor() {\n    super();\n    Object.setPrototypeOf(this, CancelError.prototype);\n  }\n}\n","import type CancelablePromise from '.';\n\nexport interface PromiseControlOptions {\n  onStart?: () => void;\n  onStop?: () => void;\n}\n\ntype Key = CancelablePromise | string | number | symbol;\n\nexport class PromiseControl {\n  private _promises: Map<Key, CancelablePromise> = new Map();\n\n  constructor(private options: PromiseControlOptions = {}) {}\n\n  get isLoaded(): boolean {\n    return this._promises.size > 0;\n  }\n\n  remove(promise: Key): void {\n    if (this._promises.has(promise)) {\n      this._promises.delete(promise);\n      this._onStop();\n    }\n  }\n\n  get(promise: Key): CancelablePromise | undefined {\n    return this._promises.get(promise);\n  }\n\n  add<T extends CancelablePromise = CancelablePromise>(\n    promise: T,\n    name?: string | number | symbol,\n  ): CancelablePromise<T> {\n    const key = name ? name : promise;\n    const exist = this._promises.get(key);\n    if (this.options.onStart && !this.isLoaded) {\n      this.options.onStart();\n    }\n    if (exist) {\n      return exist;\n    }\n    this._promises.set(key, promise);\n    promise.finally(() => {\n      this.remove(key);\n    });\n    return promise;\n  }\n\n  abort(): void {\n    if (this.isLoaded) {\n      this._promises.forEach((x) => {\n        if (x.cancel) {\n          x.cancel();\n        }\n      });\n      this._promises.clear();\n      this._onStop();\n    }\n  }\n\n  waitFunc<T>(func: () => any, name = ''): CancelablePromise<T> {\n    name = name || func.name;\n    const exist = this.get(name);\n    if (exist) {\n      return exist;\n    }\n    return this.add(func(), name);\n  }\n\n  WaitForMe(name: string | symbol = ''): MethodDecorator {\n    const get = this.get.bind(this);\n    const add = this.add.bind(this);\n    return function (\n      target: unknown,\n      key: string | symbol,\n      descriptor: PropertyDescriptor,\n    ): PropertyDescriptor {\n      const originalMethod = descriptor.value;\n      name = name || key;\n      descriptor.value = function (...args: any[]) {\n        const exist = get(name);\n        if (exist) {\n          return exist;\n        }\n        const result = add(originalMethod.apply(this, args), name);\n        return result;\n      };\n\n      return descriptor;\n    };\n  }\n\n  /** @deprecated use {@link PromiseControl.WaitForMe } instead */\n  GetOrCreateDecorator(name: string | symbol = ''): MethodDecorator {\n    return this.WaitForMe(name);\n  }\n\n  private _onStop(): void {\n    if (this.options.onStop && !this.isLoaded) {\n      this.options.onStop();\n    }\n  }\n}\n","export class TimeoutError extends Error {\n  name = 'TimeoutError';\n\n  constructor() {\n    super();\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n  }\n}\n","import { CancelError } from './CancelError';\nimport { PromiseControl } from './PromiseControl';\nimport { TimeoutError } from './TimeoutError';\n\nimport type { PromiseControlOptions } from './PromiseControl';\n\ntype Reject = (reason?: any) => void;\ntype Resolve = (value?: any) => void;\nexport type OnCancelFunction = (cancelHandler: () => void) => void;\n\nconst handleCallback = <T = never>(\n  resolve: Resolve,\n  reject: Reject,\n  callback: Resolve,\n  r: T,\n) => {\n  try {\n    resolve(callback(r));\n  } catch (e) {\n    reject(e);\n  }\n};\n\nlet ID = 0;\n\n/**\n * Promise that can be canceled\n *\n * @example\n * Catch `CancelError`\n * ```javascript\n * import CancelablePromise from \"@nextgis/cancelable-promise\";\n *\n * const promise = new CancelablePromise((resolve, reject) => {\n *  setTimeout(() => resolve(), 100);\n * }).catch((er) => {\n *  if (er.name === \"CancelError\") {\n *    // handle cancel error\n *  }\n *  throw er;\n * });\n *\n * promise.cancel();\n * ```\n * @example\n * Handle `onCancel` callback\n * ```javascript\n * import CancelablePromise from \"@nextgis/cancelable-promise\";\n *\n * const promise = new CancelablePromise((resolve, reject, onCancel) => {\n *   const xhr = new XMLHttpRequest();\n *   xhr.open(\"GET\", url, true);\n *   xhr.onload = () => {\n *     resolve(xhr.responseText);\n *   };\n *   xhr.onerror = (er) => {\n *     reject(er);\n *   };\n *\n *   onCancel(() => {\n *     xhr.abort();\n *   });\n *\n *   xhr.send();\n * });\n *\n * promise.cancel();\n * ```\n */\nexport class CancelablePromise<T = any> implements Promise<T> {\n  static CancelError = CancelError;\n  static TimeoutError = TimeoutError;\n  static PromiseControl = PromiseControl;\n\n  // @ts-expect-error Property '[Symbol.toStringTag]' has no initializer and is not definitely assigned in the constructor\n  readonly [Symbol.toStringTag]: string;\n  readonly id = ID++;\n  private _isCanceled = false;\n  private _isPending = true;\n  private _promise?: Promise<T>;\n  private _cancelPromise?: Promise<T>;\n  private _cancelHandlers: (() => void)[] = [];\n  private _setCanceledCallback?: (er?: any) => void;\n  private _parentPromise?: CancelablePromise;\n  private _children: CancelablePromise[] = [];\n\n  constructor(\n    executor: (\n      resolve: (value?: T | PromiseLike<T>) => void,\n      reject: (reason?: any) => void,\n      onCancel: OnCancelFunction,\n    ) => void,\n    timeout?: number,\n  ) {\n    this._cancelPromise = new Promise<any>((resolve_, reject_) => {\n      this._setCanceledCallback = (er) => resolve_(er || new CancelError());\n    });\n    const promises = [\n      this._cancelPromise,\n      new Promise<T>((resolve, reject) => {\n        const onResolve = (value?: T | PromiseLike<T>) => {\n          if (value instanceof CancelablePromise) {\n            this.attach(value);\n          } else {\n            this._isPending = false;\n          }\n          // TODO: fix types, `undefined` not allowed since 19.12.2020\n          resolve(value as T | PromiseLike<T>);\n        };\n\n        const onReject = (error: any) => {\n          this._isPending = false;\n          reject(error);\n        };\n\n        const onCancel: OnCancelFunction = (handler) => {\n          if (!this._isPending) {\n            throw new Error(\n              'The `onCancel` handler was attached after the promise settled.',\n            );\n          }\n\n          this._cancelHandlers.push(handler);\n        };\n\n        return executor(onResolve, onReject, onCancel);\n      }),\n    ];\n    if (timeout) {\n      promises.push(\n        new Promise((resolve, reject) => {\n          setTimeout(() => {\n            if (this._isPending) {\n              try {\n                this.cancel();\n              } finally {\n                reject(new TimeoutError());\n              }\n            }\n          }, timeout);\n        }),\n      );\n    }\n    this._promise = Promise.race(promises);\n  }\n\n  static createControl(opt?: PromiseControlOptions): PromiseControl {\n    return new PromiseControl(opt);\n  }\n\n  static resolve<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve) => resolve(value));\n  }\n\n  static reject<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve, reject) => reject(value));\n  }\n\n  static all<T>(values: (T | PromiseLike<T>)[]): CancelablePromise<T[]> {\n    return new CancelablePromise((resolve, reject) => {\n      Promise.all(values).then(resolve).catch(reject);\n    }).catch((er) => {\n      if (er instanceof this.CancelError) {\n        for (const v of values) {\n          const v_ = v as CancelablePromise;\n          if ('cancel' in v_) {\n            v_.cancel();\n          }\n        }\n      }\n      throw er;\n    });\n  }\n\n  attach(p: CancelablePromise): void {\n    if (this._isCanceled) {\n      p.cancel();\n    } else {\n      this._children.push(p);\n    }\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null,\n  ): CancelablePromise<TResult1 | TResult2> {\n    const p = new CancelablePromise((resolve, reject) => {\n      if (this._promise) {\n        const reject_ = (r: any) => {\n          if (onrejected) {\n            handleCallback(resolve, reject, onrejected, r);\n          } else {\n            reject(r);\n          }\n        };\n        this._promise.then((r) => {\n          if (this._isCanceled) {\n            reject_(r);\n          } else {\n            if (onfulfilled) {\n              handleCallback(resolve, reject, onfulfilled, r);\n            } else {\n              resolve(r);\n            }\n          }\n        }, reject_);\n      }\n    });\n    p._parentPromise = this;\n    this._children.push(p);\n    return p as CancelablePromise<TResult1 | TResult2>;\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: Error) => TResult | PromiseLike<TResult>)\n      | undefined\n      | null,\n  ): CancelablePromise<T | TResult> {\n    if (this._isCanceled && onrejected) {\n      onrejected(new CancelError());\n    }\n    return this.then(undefined, onrejected);\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    if (this._promise) {\n      return this._promise.finally(onfinally);\n    }\n    if (this._isCanceled) {\n      return Promise.reject(new CancelError());\n    }\n    return Promise.reject<T>(onfinally);\n  }\n\n  cancel(): this {\n    // No reason to run cancel action if promise is already complete\n    if (this._isCanceled || !this._isPending) {\n      return this;\n    }\n    this._isCanceled = true;\n    const parent = this._getTopParent();\n    if (parent) {\n      parent.cancel();\n    }\n\n    if (this._children) {\n      this._children.forEach((x) => x.cancel());\n    }\n\n    if (this._isPending) {\n      if (this._cancelHandlers.length) {\n        try {\n          for (const handler of this._cancelHandlers) {\n            handler();\n          }\n        } catch {\n          // this._setCanceledCallback(error);\n        }\n      }\n      if (this._setCanceledCallback) {\n        this._setCanceledCallback();\n      }\n    }\n    this._destroy();\n\n    return this;\n  }\n\n  private _getTopParent() {\n    let parent = this._parentPromise;\n    let hasParent = !!parent;\n    while (hasParent) {\n      if (parent && parent._parentPromise) {\n        parent = parent._parentPromise;\n        hasParent = !!parent;\n      } else {\n        hasParent = false;\n      }\n    }\n    return parent;\n  }\n\n  private _destroy() {\n    this._setCanceledCallback = undefined;\n    this._cancelPromise = undefined;\n    this._promise = undefined;\n  }\n}\n\nObject.setPrototypeOf(CancelablePromise.prototype, Promise.prototype);\n"],"names":["CancelError","Error","constructor","super","__publicField","this","Object","setPrototypeOf","prototype","PromiseControl","options","Map","isLoaded","_promises","size","remove","promise","has","delete","_onStop","get","add","name","key","exist","onStart","set","finally","abort","forEach","x","cancel","clear","waitFunc","func","WaitForMe","bind","target","descriptor","originalMethod","value","args","apply","GetOrCreateDecorator","onStop","TimeoutError","_a","handleCallback","resolve","reject","callback","r","e","ID","Symbol","toStringTag","_CancelablePromise","executor","timeout","_cancelPromise","Promise","resolve_","reject_","_setCanceledCallback","er","promises","attach","_isPending","error","handler","_cancelHandlers","push","setTimeout","_promise","race","createControl","opt","all","values","then","catch","v","p","_isCanceled","_children","onfulfilled","onrejected","_parentPromise","onfinally","parent","_getTopParent","length","_destroy","hasParent","CancelablePromise"],"mappings":"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"}