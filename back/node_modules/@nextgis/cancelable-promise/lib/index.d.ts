declare class CancelError extends Error {
    name: string;
    constructor();
}

interface PromiseControlOptions {
    onStart?: () => void;
    onStop?: () => void;
}
type Key = CancelablePromise | string | number | symbol;
declare class PromiseControl {
    private options;
    private _promises;
    constructor(options?: PromiseControlOptions);
    get isLoaded(): boolean;
    remove(promise: Key): void;
    get(promise: Key): CancelablePromise | undefined;
    add<T extends CancelablePromise = CancelablePromise>(promise: T, name?: string | number | symbol): CancelablePromise<T>;
    abort(): void;
    waitFunc<T>(func: () => any, name?: string): CancelablePromise<T>;
    WaitForMe(name?: string | symbol): MethodDecorator;
    /** @deprecated use {@link PromiseControl.WaitForMe } instead */
    GetOrCreateDecorator(name?: string | symbol): MethodDecorator;
    private _onStop;
}

declare class TimeoutError extends Error {
    name: string;
    constructor();
}

type OnCancelFunction = (cancelHandler: () => void) => void;
/**
 * Promise that can be canceled
 *
 * @example
 * Catch `CancelError`
 * ```javascript
 * import CancelablePromise from "@nextgis/cancelable-promise";
 *
 * const promise = new CancelablePromise((resolve, reject) => {
 *  setTimeout(() => resolve(), 100);
 * }).catch((er) => {
 *  if (er.name === "CancelError") {
 *    // handle cancel error
 *  }
 *  throw er;
 * });
 *
 * promise.cancel();
 * ```
 * @example
 * Handle `onCancel` callback
 * ```javascript
 * import CancelablePromise from "@nextgis/cancelable-promise";
 *
 * const promise = new CancelablePromise((resolve, reject, onCancel) => {
 *   const xhr = new XMLHttpRequest();
 *   xhr.open("GET", url, true);
 *   xhr.onload = () => {
 *     resolve(xhr.responseText);
 *   };
 *   xhr.onerror = (er) => {
 *     reject(er);
 *   };
 *
 *   onCancel(() => {
 *     xhr.abort();
 *   });
 *
 *   xhr.send();
 * });
 *
 * promise.cancel();
 * ```
 */
declare class CancelablePromise<T = any> implements Promise<T> {
    static CancelError: typeof CancelError;
    static TimeoutError: typeof TimeoutError;
    static PromiseControl: typeof PromiseControl;
    readonly [Symbol.toStringTag]: string;
    readonly id: number;
    private _isCanceled;
    private _isPending;
    private _promise?;
    private _cancelPromise?;
    private _cancelHandlers;
    private _setCanceledCallback?;
    private _parentPromise?;
    private _children;
    constructor(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onCancel: OnCancelFunction) => void, timeout?: number);
    static createControl(opt?: PromiseControlOptions): PromiseControl;
    static resolve<T>(value: T | PromiseLike<T>): CancelablePromise<T>;
    static reject<T>(value: T | PromiseLike<T>): CancelablePromise<T>;
    static all<T>(values: (T | PromiseLike<T>)[]): CancelablePromise<T[]>;
    attach(p: CancelablePromise): void;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): CancelablePromise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: Error) => TResult | PromiseLike<TResult>) | undefined | null): CancelablePromise<T | TResult>;
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
    cancel(): this;
    private _getTopParent;
    private _destroy;
}

export { CancelablePromise as default };
