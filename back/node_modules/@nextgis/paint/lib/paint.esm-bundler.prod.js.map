{"version":3,"file":"paint.esm-bundler.prod.js","sources":["../src/fromPaintExpression.ts","../src/typeHelpers.ts","../src/preparePaint.ts"],"sourcesContent":["import { evaluate, type Expression, isExpression } from '@nextgis/expression';\n\nimport type { Feature } from 'geojson';\n\nimport type { GetPaintCallback, VectorAdapterLayerPaint } from './interfaces';\n\ntype PropertyExpressionCb = (feature: Feature) => ReturnType<typeof evaluate>;\n\nfunction createPropertyExpressionCb(\n  expression: Expression,\n): PropertyExpressionCb {\n  return (feature: Feature) => {\n    const properties = feature.properties;\n    if (properties) {\n      return evaluate(expression, properties);\n    }\n    return false;\n  };\n}\n\nconst excludeExpressionList = ['iconSize', 'iconAnchor'];\n\nexport function createExpressionCallback(\n  paint: Record<string, any>,\n): GetPaintCallback | undefined {\n  let withExpression = false;\n  const expressions: {\n    [key: string]: PropertyExpressionCb;\n  } = {};\n  for (const p in paint) {\n    if (excludeExpressionList.indexOf(p) === -1) {\n      const p_ = p as keyof VectorAdapterLayerPaint;\n      const val = paint[p_];\n      if (isExpression(val)) {\n        withExpression = true;\n        expressions[p_] = createPropertyExpressionCb(val);\n      }\n    }\n  }\n  if (withExpression) {\n    return (feature: Feature) => {\n      const fromCb: any = {};\n      for (const p in expressions) {\n        fromCb[p] = expressions[p](feature);\n      }\n      return { ...paint, ...fromCb };\n    };\n  }\n  return;\n}\n","import type {\n  GeometryPaint,\n  GetPaintCallback,\n  IconPaint,\n  Paint,\n  PropertiesPaint,\n  VectorAdapterLayerPaint,\n} from './interfaces';\n\nexport function isPropertiesPaint(paint: Paint): paint is PropertiesPaint {\n  if (Array.isArray(paint)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPaint(paint: Paint): paint is VectorAdapterLayerPaint {\n  if (Object.prototype.toString.call(paint) === '[object Object]') {\n    return true;\n  }\n  return false;\n}\n\nexport function isBasePaint(paint: Paint): paint is GeometryPaint {\n  if (isPaint(paint)) {\n    if (paint.type === 'get-paint' || paint.type === 'icon') {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function isPaintCallback(paint: Paint): paint is GetPaintCallback {\n  if (typeof paint === 'function') {\n    return true;\n  }\n  return false;\n}\n\nexport function isIcon(paint: IconPaint): paint is IconPaint {\n  return paint.type === 'icon' || 'html' in paint;\n}\n","import { featureFilter } from '@nextgis/properties-filter';\n\nimport { createExpressionCallback } from './fromPaintExpression';\nimport { isPaintCallback, isPropertiesPaint } from './typeHelpers';\n\nimport type { Feature } from 'geojson';\n\nimport type {\n  GeometryPaint,\n  GetCustomPaintOptions,\n  GetPaintCallback,\n  GetPaintFunction,\n  Paint,\n  PropertiesPaint,\n  PropertyPaint,\n  VectorAdapterLayerPaint,\n} from './interfaces';\n\nfunction updatePaintOptionFromCallback(\n  paint: GetCustomPaintOptions,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): VectorAdapterLayerPaint | undefined {\n  if (typeof paint.from === 'function') {\n    return paint.from(paint.options);\n  } else if (typeof paint.from === 'string' && getPaintFunctions) {\n    const from = getPaintFunctions[paint.from];\n    if (from) {\n      return from(paint.options);\n    }\n  }\n}\n\nfunction createPropertiesPaint(\n  propertiesPaint: PropertiesPaint,\n): GetPaintFunction {\n  let mask: VectorAdapterLayerPaint = {};\n  const paintsFilters: PropertyPaint[] = [];\n  for (const p of propertiesPaint) {\n    if (p) {\n      if (Array.isArray(p)) {\n        paintsFilters.push(p);\n      } else {\n        mask = p as VectorAdapterLayerPaint;\n      }\n    }\n  }\n\n  return (feature: Feature) => {\n    const paint = paintsFilters.find((x) => featureFilter(feature, x[0]));\n    if (paint) {\n      return { ...mask, ...paint[1] };\n    }\n    return mask;\n  };\n}\n\nfunction expressionCallback({\n  paint,\n  defaultPaint,\n}: PreparePaintOptions): Paint | VectorAdapterLayerPaint {\n  const expressionCallback = createExpressionCallback(paint);\n  if (expressionCallback) {\n    const expressionPaintCb = (feature: Feature) => {\n      return preparePaint({\n        paint: expressionCallback(feature),\n        defaultPaint,\n      }) as VectorAdapterLayerPaint;\n    };\n    expressionPaintCb.paint = finalizePaint({ paint, defaultPaint });\n    return expressionPaintCb as VectorAdapterLayerPaint;\n  }\n  return finalizePaint({ paint, defaultPaint });\n}\n\nfunction finalizePaint({ paint, defaultPaint }: PreparePaintOptions): Paint {\n  let newPaint: Paint = { ...defaultPaint };\n  newPaint = { ...newPaint, ...paint } as GeometryPaint;\n  newPaint.fill = newPaint.fill ?? true;\n  newPaint.stroke =\n    newPaint.stroke !== undefined\n      ? newPaint.stroke\n      : !newPaint.fill || !!(newPaint.strokeColor || newPaint.strokeOpacity);\n  return newPaint;\n}\n\nexport interface PreparePaintOptions {\n  paint: Paint;\n  defaultPaint?: GeometryPaint;\n  getPaintFunctions?: { [name: string]: GetPaintFunction };\n}\n\nexport function preparePaint({\n  paint,\n  defaultPaint,\n  getPaintFunctions,\n}: PreparePaintOptions): Paint {\n  if (!paint) {\n    throw new Error('paint is empty');\n  }\n  let newPaint: Paint = { ...defaultPaint };\n  if (isPaintCallback(paint)) {\n    const getPaintFunction: GetPaintCallback = (feature: Feature) => {\n      const getPaint = preparePaint({\n        paint: paint(feature),\n        defaultPaint,\n        getPaintFunctions,\n      }) as VectorAdapterLayerPaint;\n      getPaint.type = paint.type;\n      return getPaint;\n    };\n    getPaintFunction.type = paint.type;\n    return getPaintFunction;\n  } else if (isPropertiesPaint(paint)) {\n    return (feature: Feature) => {\n      return preparePaint({\n        paint: createPropertiesPaint(paint)(feature),\n        defaultPaint,\n        getPaintFunctions,\n      }) as VectorAdapterLayerPaint;\n    };\n  } else if (paint.type === 'get-paint') {\n    const getPaint = updatePaintOptionFromCallback(paint, getPaintFunctions);\n    if (getPaint) {\n      newPaint = preparePaint({\n        paint: getPaint,\n        defaultPaint,\n        getPaintFunctions,\n      });\n    }\n  } else if (paint.type === 'icon') {\n    return paint;\n  } else {\n    newPaint = expressionCallback({ paint, defaultPaint });\n  }\n\n  if (isPaintCallback(newPaint)) {\n    return newPaint;\n  }\n\n  if ('color' in newPaint) {\n    if (!newPaint.strokeColor) {\n      newPaint.strokeColor = newPaint.color;\n    }\n    if (!newPaint.fillColor) {\n      newPaint.fillColor = newPaint.color;\n    }\n  }\n  if ('opacity' in newPaint) {\n    if (newPaint.strokeOpacity === undefined) {\n      newPaint.strokeOpacity = newPaint.opacity;\n    }\n    if (newPaint.fillOpacity === undefined) {\n      newPaint.fillOpacity = newPaint.opacity;\n    }\n  }\n\n  return newPaint;\n}\n"],"names":["createPropertyExpressionCb","expression","feature","properties","evaluate","excludeExpressionList","createExpressionCallback","paint","withExpression","expressions","p","indexOf","p_","val","isExpression","fromCb","__spreadValues","isPropertiesPaint","Array","isArray","isPaint","Object","prototype","toString","call","isBasePaint","type","isPaintCallback","isIcon","createPropertiesPaint","propertiesPaint","mask","paintsFilters","push","find","x","featureFilter","finalizePaint","defaultPaint","_a","newPaint","fill","stroke","strokeColor","strokeOpacity","preparePaint","getPaintFunctions","Error","getPaintFunction","getPaint","from","options","updatePaintOptionFromCallback","expressionCallback","expressionPaintCb","color","fillColor","opacity","fillOpacity"],"mappings":"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"}