/** Bundle of @nextgis/paint; version: 3.0.0-alpha.13; author: NextGIS */
import { isExpression, evaluate } from '@nextgis/expression';
import { featureFilter } from '@nextgis/properties-filter';

var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
function createPropertyExpressionCb(expression) {
  return (feature) => {
    const properties = feature.properties;
    if (properties) {
      return evaluate(expression, properties);
    }
    return false;
  };
}
const excludeExpressionList = ["iconSize", "iconAnchor"];
function createExpressionCallback(paint) {
  let withExpression = false;
  const expressions = {};
  for (const p in paint) {
    if (excludeExpressionList.indexOf(p) === -1) {
      const p_ = p;
      const val = paint[p_];
      if (isExpression(val)) {
        withExpression = true;
        expressions[p_] = createPropertyExpressionCb(val);
      }
    }
  }
  if (withExpression) {
    return (feature) => {
      const fromCb = {};
      for (const p in expressions) {
        fromCb[p] = expressions[p](feature);
      }
      return __spreadValues$1(__spreadValues$1({}, paint), fromCb);
    };
  }
  return;
}

function isPropertiesPaint(paint) {
  if (Array.isArray(paint)) {
    return true;
  }
  return false;
}
function isPaint(paint) {
  if (Object.prototype.toString.call(paint) === "[object Object]") {
    return true;
  }
  return false;
}
function isBasePaint(paint) {
  if (isPaint(paint)) {
    if (paint.type === "get-paint" || paint.type === "icon") {
      return false;
    }
    return true;
  }
  return false;
}
function isPaintCallback(paint) {
  if (typeof paint === "function") {
    return true;
  }
  return false;
}
function isIcon(paint) {
  return paint.type === "icon" || "html" in paint;
}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
function updatePaintOptionFromCallback(paint, getPaintFunctions) {
  if (typeof paint.from === "function") {
    return paint.from(paint.options);
  } else if (typeof paint.from === "string" && getPaintFunctions) {
    const from = getPaintFunctions[paint.from];
    if (from) {
      return from(paint.options);
    }
  }
}
function createPropertiesPaint(propertiesPaint) {
  let mask = {};
  const paintsFilters = [];
  for (const p of propertiesPaint) {
    if (p) {
      if (Array.isArray(p)) {
        paintsFilters.push(p);
      } else {
        mask = p;
      }
    }
  }
  return (feature) => {
    const paint = paintsFilters.find((x) => featureFilter(feature, x[0]));
    if (paint) {
      return __spreadValues(__spreadValues({}, mask), paint[1]);
    }
    return mask;
  };
}
function expressionCallback({
  paint,
  defaultPaint
}) {
  const expressionCallback2 = createExpressionCallback(paint);
  if (expressionCallback2) {
    const expressionPaintCb = (feature) => {
      return preparePaint({
        paint: expressionCallback2(feature),
        defaultPaint
      });
    };
    expressionPaintCb.paint = finalizePaint({ paint, defaultPaint });
    return expressionPaintCb;
  }
  return finalizePaint({ paint, defaultPaint });
}
function finalizePaint({ paint, defaultPaint }) {
  var _a;
  let newPaint = __spreadValues({}, defaultPaint);
  newPaint = __spreadValues(__spreadValues({}, newPaint), paint);
  newPaint.fill = (_a = newPaint.fill) != null ? _a : true;
  newPaint.stroke = newPaint.stroke !== void 0 ? newPaint.stroke : !newPaint.fill || !!(newPaint.strokeColor || newPaint.strokeOpacity);
  return newPaint;
}
function preparePaint({
  paint,
  defaultPaint,
  getPaintFunctions
}) {
  if (!paint) {
    throw new Error("paint is empty");
  }
  let newPaint = __spreadValues({}, defaultPaint);
  if (isPaintCallback(paint)) {
    const getPaintFunction = (feature) => {
      const getPaint = preparePaint({
        paint: paint(feature),
        defaultPaint,
        getPaintFunctions
      });
      getPaint.type = paint.type;
      return getPaint;
    };
    getPaintFunction.type = paint.type;
    return getPaintFunction;
  } else if (isPropertiesPaint(paint)) {
    return (feature) => {
      return preparePaint({
        paint: createPropertiesPaint(paint)(feature),
        defaultPaint,
        getPaintFunctions
      });
    };
  } else if (paint.type === "get-paint") {
    const getPaint = updatePaintOptionFromCallback(paint, getPaintFunctions);
    if (getPaint) {
      newPaint = preparePaint({
        paint: getPaint,
        defaultPaint,
        getPaintFunctions
      });
    }
  } else if (paint.type === "icon") {
    return paint;
  } else {
    newPaint = expressionCallback({ paint, defaultPaint });
  }
  if (isPaintCallback(newPaint)) {
    return newPaint;
  }
  if ("color" in newPaint) {
    if (!newPaint.strokeColor) {
      newPaint.strokeColor = newPaint.color;
    }
    if (!newPaint.fillColor) {
      newPaint.fillColor = newPaint.color;
    }
  }
  if ("opacity" in newPaint) {
    if (newPaint.strokeOpacity === void 0) {
      newPaint.strokeOpacity = newPaint.opacity;
    }
    if (newPaint.fillOpacity === void 0) {
      newPaint.fillOpacity = newPaint.opacity;
    }
  }
  return newPaint;
}

export { createExpressionCallback, isBasePaint, isIcon, isPaint, isPaintCallback, isPropertiesPaint, preparePaint };
//# sourceMappingURL=paint.esm-bundler.js.map
