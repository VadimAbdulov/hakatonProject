type Data = Record<string, any>;
type LookupExpressionName = 'at' | 'get' | 'has' | 'length' | 'in' | 'index-of' | 'slice';
type TypeExpressionName = 'array' | 'boolean' | 'literal' | 'number' | 'object' | 'string' | 'to-boolean' | 'to-number' | 'to-string' | 'typeof';
type StringExpressionName = 'concat' | 'downcase' | 'upcase';
type MathExpressionName = '+' | '-' | '*' | '/' | '%' | '^' | 'abs' | 'acos' | 'asin' | 'atan' | 'ceil' | 'cos' | 'e' | 'floor' | 'ln' | 'ln2' | 'log10' | 'log2' | 'max' | 'min' | 'pi' | 'round' | 'sin' | 'sqrt' | 'tan';
type DecisionExpressionName = '!' | '!=' | '<' | '<=' | '==' | '>=' | '>' | 'all' | 'any' | 'case' | 'match' | 'coalesce';
type InterpolationExpressionName = 'step' | 'interpolate';
type ExpressionName = MathExpressionName | TypeExpressionName | StringExpressionName | LookupExpressionName | DecisionExpressionName | InterpolationExpressionName;
type SimpleType = string | number | boolean | null | Record<string, any>;
type ExpressionArg = SimpleType | Expression;
type Expression = [ExpressionName, ...ExpressionArg[]];
type Callback<T> = () => T;
type MapToCallback<T = any> = {
    [K in keyof T]: Callback<T[K]>;
};
type ExpressionCbFunc<T = any, R = T extends Array<any> ? T[0] : any> = (args: MapToCallback<T>, data: Data) => R;
type ExpressionFunc<T = any, R = T extends Array<any> ? T[0] : any> = (args: T, data: Data) => R;

declare function isExpression(value: any): value is Expression;
declare function evaluate<T extends SimpleType[] = SimpleType[], R = T[0]>(expression: Expression, data?: Data): R;

export { type Data, type DecisionExpressionName, type Expression, type ExpressionCbFunc, type ExpressionFunc, type ExpressionName, type InterpolationExpressionName, type LookupExpressionName, type MapToCallback, type MathExpressionName, type SimpleType, type StringExpressionName, type TypeExpressionName, evaluate, isExpression };
