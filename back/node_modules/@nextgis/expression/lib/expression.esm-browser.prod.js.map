{"version":3,"file":"expression.esm-browser.prod.js","sources":["../src/utils/evaluateArgs.ts","../src/expressions/decisionExpressions.ts","../src/constants/colors.ts","../src/utils/color.ts","../src/expressions/interpolationExpressions/interpolate.ts","../src/expressions/interpolationExpressions/index.ts","../src/expressions/interpolationExpressions/step.ts","../src/expressions/lookupExpressions.ts","../src/expressions/mathExpressions.ts","../src/expressions/stringExpressions.ts","../src/utils/tryConvert.ts","../src/utils/fallback.ts","../src/expressions/typeExpressions.ts","../src/expression.ts"],"sourcesContent":["import type {\n  ExpressionCbFunc,\n  ExpressionFunc,\n  MapToCallback,\n  SimpleType,\n} from '../interfaces';\n\nexport default function evaluateArgs<\n  T extends SimpleType[] = SimpleType[],\n  R = T[0],\n>(cb: ExpressionFunc<T, R>): ExpressionCbFunc<T, R> {\n  return (args: MapToCallback<T>, data) => {\n    const unwrap = args.map((a) => a()) as T;\n    return cb(unwrap, data);\n  };\n}\n","import e from '../utils/evaluateArgs';\n\nimport type { DecisionExpressionName, ExpressionCbFunc } from '../interfaces';\n\nfunction not([expr]: [boolean]): boolean {\n  return !expr;\n}\n\nfunction notEqual([a, b]: [value1: any, value2: any]): boolean {\n  return a !== b;\n}\n\nfunction lessThan([left, right]: [value1: any, value2: any]): boolean {\n  return left < right;\n}\n\nfunction lessThanOrEqual([left, right]: [value1: any, value2: any]): boolean {\n  return left <= right;\n}\n\nfunction equal([left, right]: [value1: any, value2: any]): boolean {\n  return left === right;\n}\n\nfunction greaterThan([left, right]: [value1: any, value2: any]): boolean {\n  return left > right;\n}\n\nfunction greaterThanOrEqual([left, right]: [\n  value1: any,\n  value2: any,\n]): boolean {\n  return left >= right;\n}\n\nconst coalesce: ExpressionCbFunc<any[], any> = (args) => {\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i]();\n    if (arg !== null && arg !== undefined) {\n      return arg;\n    }\n  }\n  return null;\n};\n\nconst all: ExpressionCbFunc<any[], boolean> = (args) => {\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i]();\n    if (!arg) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst any: ExpressionCbFunc<any[], boolean> = (args) => {\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i]();\n    if (arg) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst match: ExpressionCbFunc<any[]> = (args) => {\n  const [lookupFn, ...cases] = args;\n  const lookup = lookupFn();\n  // remove last odd item from cases array\n  const defValue = cases.splice(-1, cases.length % 2)[0];\n  for (let fry = 0; fry < cases.length - 1; fry += 2) {\n    const key = cases[fry]();\n    if (key === lookup) {\n      return cases[fry + 1]();\n    }\n  }\n  return defValue();\n};\n\ntype OutputType = any;\nconst caseFunc: ExpressionCbFunc<\n  [boolean, OutputType, ...Array<boolean | OutputType>],\n  OutputType\n> = (args) => {\n  if (args.length < 2) {\n    throw new Error(\n      'The \"case\" function requires at least a condition and a corresponding output.',\n    );\n  }\n\n  if (args.length % 2 === 0) {\n    throw new Error(\n      'Missing a fallback value or unmatched condition-output pair.',\n    );\n  }\n  for (let i = 0; i < args.length - 1; i += 2) {\n    const condition = args[i]() as boolean;\n    const value = args[i + 1]() as OutputType;\n    if (condition) {\n      return value;\n    }\n  }\n  const fallback = args[args.length - 1];\n  return fallback();\n};\n\nexport const decisionExpressions: Record<\n  DecisionExpressionName,\n  ExpressionCbFunc\n> = {\n  '!': e(not),\n  '!=': e(notEqual),\n  '<': e(lessThan),\n  '<=': e(lessThanOrEqual),\n  '==': e(equal),\n  '>': e(greaterThan),\n  '>=': e(greaterThanOrEqual),\n  coalesce,\n  all,\n  any,\n  case: caseFunc,\n  match,\n};\n","export const COLORS = {\n  aliceblue: '#f0f8ff',\n  antiquewhite: '#faebd7',\n  aqua: '#00ffff',\n  aquamarine: '#7fffd4',\n  azure: '#f0ffff',\n  beige: '#f5f5dc',\n  bisque: '#ffe4c4',\n  black: '#000000',\n  blanchedalmond: '#ffebcd',\n  blue: '#0000ff',\n  blueviolet: '#8a2be2',\n  brown: '#a52a2a',\n  burlywood: '#deb887',\n  cadetblue: '#5f9ea0',\n  chartreuse: '#7fff00',\n  chocolate: '#d2691e',\n  coral: '#ff7f50',\n  cornflowerblue: '#6495ed',\n  cornsilk: '#fff8dc',\n  crimson: '#dc143c',\n  cyan: '#00ffff',\n  darkblue: '#00008b',\n  darkcyan: '#008b8b',\n  darkgoldenrod: '#b8860b',\n  darkgray: '#a9a9a9',\n  darkgreen: '#006400',\n  darkkhaki: '#bdb76b',\n  darkmagenta: '#8b008b',\n  darkolivegreen: '#556b2f',\n  darkorange: '#ff8c00',\n  darkorchid: '#9932cc',\n  darkred: '#8b0000',\n  darksalmon: '#e9967a',\n  darkseagreen: '#8fbc8f',\n  darkslateblue: '#483d8b',\n  darkslategray: '#2f4f4f',\n  darkturquoise: '#00ced1',\n  darkviolet: '#9400d3',\n  deeppink: '#ff1493',\n  deepskyblue: '#00bfff',\n  dimgray: '#696969',\n  dodgerblue: '#1e90ff',\n  firebrick: '#b22222',\n  floralwhite: '#fffaf0',\n  forestgreen: '#228b22',\n  fuchsia: '#ff00ff',\n  gainsboro: '#dcdcdc',\n  ghostwhite: '#f8f8ff',\n  gold: '#ffd700',\n  goldenrod: '#daa520',\n  gray: '#808080',\n  green: '#008000',\n  greenyellow: '#adff2f',\n  honeydew: '#f0fff0',\n  hotpink: '#ff69b4',\n  'indianred ': '#cd5c5c',\n  indigo: '#4b0082',\n  ivory: '#fffff0',\n  khaki: '#f0e68c',\n  lavender: '#e6e6fa',\n  lavenderblush: '#fff0f5',\n  lawngreen: '#7cfc00',\n  lemonchiffon: '#fffacd',\n  lightblue: '#add8e6',\n  lightcoral: '#f08080',\n  lightcyan: '#e0ffff',\n  lightgoldenrodyellow: '#fafad2',\n  lightgrey: '#d3d3d3',\n  lightgreen: '#90ee90',\n  lightpink: '#ffb6c1',\n  lightsalmon: '#ffa07a',\n  lightseagreen: '#20b2aa',\n  lightskyblue: '#87cefa',\n  lightslategray: '#778899',\n  lightsteelblue: '#b0c4de',\n  lightyellow: '#ffffe0',\n  lime: '#00ff00',\n  limegreen: '#32cd32',\n  linen: '#faf0e6',\n  magenta: '#ff00ff',\n  maroon: '#800000',\n  mediumaquamarine: '#66cdaa',\n  mediumblue: '#0000cd',\n  mediumorchid: '#ba55d3',\n  mediumpurple: '#9370d8',\n  mediumseagreen: '#3cb371',\n  mediumslateblue: '#7b68ee',\n  mediumspringgreen: '#00fa9a',\n  mediumturquoise: '#48d1cc',\n  mediumvioletred: '#c71585',\n  midnightblue: '#191970',\n  mintcream: '#f5fffa',\n  mistyrose: '#ffe4e1',\n  moccasin: '#ffe4b5',\n  navajowhite: '#ffdead',\n  navy: '#000080',\n  oldlace: '#fdf5e6',\n  olive: '#808000',\n  olivedrab: '#6b8e23',\n  orange: '#ffa500',\n  orangered: '#ff4500',\n  orchid: '#da70d6',\n  palegoldenrod: '#eee8aa',\n  palegreen: '#98fb98',\n  paleturquoise: '#afeeee',\n  palevioletred: '#d87093',\n  papayawhip: '#ffefd5',\n  peachpuff: '#ffdab9',\n  peru: '#cd853f',\n  pink: '#ffc0cb',\n  plum: '#dda0dd',\n  powderblue: '#b0e0e6',\n  purple: '#800080',\n  rebeccapurple: '#663399',\n  red: '#ff0000',\n  rosybrown: '#bc8f8f',\n  royalblue: '#4169e1',\n  saddlebrown: '#8b4513',\n  salmon: '#fa8072',\n  sandybrown: '#f4a460',\n  seagreen: '#2e8b57',\n  seashell: '#fff5ee',\n  sienna: '#a0522d',\n  silver: '#c0c0c0',\n  skyblue: '#87ceeb',\n  slateblue: '#6a5acd',\n  slategray: '#708090',\n  snow: '#fffafa',\n  springgreen: '#00ff7f',\n  steelblue: '#4682b4',\n  tan: '#d2b48c',\n  teal: '#008080',\n  thistle: '#d8bfd8',\n  tomato: '#ff6347',\n  turquoise: '#40e0d0',\n  violet: '#ee82ee',\n  wheat: '#f5deb3',\n  white: '#ffffff',\n  whitesmoke: '#f5f5f5',\n  yellow: '#ffff00',\n  yellowgreen: '#9acd32',\n};\n","import { COLORS } from '../constants/colors';\n\nexport type ColorArray = [r: number, g: number, b: number, a?: number];\n\nexport type ColorObject = {\n  r: number;\n  g: number;\n  b: number;\n  a?: number;\n};\nexport type Color = string | ColorObject;\n\nfunction isHex(hex: any): hex is string {\n  return typeof hex === 'string' && /^#([A-Fa-f0-9]{3}){1,2}$/.test(hex);\n}\n\nfunction isRgb(hex: any): hex is string {\n  const r =\n    // eslint-disable-next-line max-len\n    /^rgb(a?)\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)(?:\\s*,\\s*([01](?:\\.\\d+)?))?\\s*\\)$/;\n  return typeof hex === 'string' && r.test(hex);\n}\n\nfunction isColorObj(obj: any): obj is ColorObject {\n  if (typeof obj === 'object' && obj !== null) {\n    const hasRgb = 'r' in obj && 'g' in obj && 'b' in obj;\n    const hasValidAlpha =\n      !('a' in obj) || (typeof obj.a === 'number' && obj.a >= 0 && obj.a <= 1);\n    return hasRgb && hasValidAlpha;\n  }\n  return false;\n}\n\nfunction isColorName(name: any): name is keyof typeof COLORS {\n  if (typeof name === 'string' && name in COLORS) {\n    return true;\n  }\n  return false;\n}\n\nexport function isColor(value: any): value is Color {\n  return [isColorName, isHex, isRgb, isColorObj].some((c) => c(value));\n}\n\nexport function toColor(value: Color): ColorArray {\n  if (isHex(value)) {\n    return hexToColor(value);\n  } else if (isColorName(value)) {\n    return colorNameToColor(value);\n  } else if (isRgb(value)) {\n    return rgbToColor(value);\n  } else if (isColorObj(value)) {\n    return colorObjectToColor(value);\n  }\n  throw new Error(`The '${value}' cannot be converted to color`);\n}\n\nfunction colorNameToColor(name: keyof typeof COLORS) {\n  return hexToColor(COLORS[name]);\n}\n\nfunction hexToColor(hex: string): ColorArray {\n  const shortRGB = /^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/;\n  const shortRGBA = /^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/;\n  const longRGB = /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/;\n  const longRGBA =\n    /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/;\n\n  let result;\n\n  if ((result = shortRGB.exec(hex))) {\n    return [\n      parseInt(result[1] + result[1], 16),\n      parseInt(result[2] + result[2], 16),\n      parseInt(result[3] + result[3], 16),\n    ];\n  } else if ((result = shortRGBA.exec(hex))) {\n    return [\n      parseInt(result[1] + result[1], 16),\n      parseInt(result[2] + result[2], 16),\n      parseInt(result[3] + result[3], 16),\n      parseInt(result[4] + result[4], 16) / 255,\n    ];\n  } else if ((result = longRGB.exec(hex))) {\n    return [\n      parseInt(result[1], 16),\n      parseInt(result[2], 16),\n      parseInt(result[3], 16),\n    ];\n  } else if ((result = longRGBA.exec(hex))) {\n    return [\n      parseInt(result[1], 16),\n      parseInt(result[2], 16),\n      parseInt(result[3], 16),\n      parseInt(result[4], 16) / 255,\n    ];\n  }\n  throw new Error(`The '${hex}' Is not valid hex`);\n}\n\nfunction rgbToColor(rgb: string): ColorArray {\n  const rgbPattern = /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/;\n  const rgbaPattern = /^rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([\\d.]+)\\)$/;\n\n  let matches;\n\n  if ((matches = rgb.match(rgbPattern))) {\n    return [\n      parseInt(matches[1], 10),\n      parseInt(matches[2], 10),\n      parseInt(matches[3], 10),\n    ];\n  } else if ((matches = rgb.match(rgbaPattern))) {\n    return [\n      parseInt(matches[1], 10),\n      parseInt(matches[2], 10),\n      parseInt(matches[3], 10),\n      parseFloat(matches[4]),\n    ];\n  }\n\n  throw new Error(`The '${rgb}' Is not valid rgb`);\n}\n\nexport function colorObjectToColor({ r, g, b, a }: ColorObject): ColorArray {\n  return [r, g, b, ...(a !== undefined ? [a] : [])] as ColorArray;\n}\n\nexport function colorToRGB(array: ColorArray): string {\n  return `rgb(${array.join(',')})`;\n}\n","import { type ColorArray, colorToRGB, toColor } from '../../utils/color';\n\nimport type { ExpressionCbFunc } from '../../interfaces';\n\ntype LinearInterpolation = ['linear'];\ntype ExponentialInterpolation = [name: 'exponential', base: number];\ntype CubicBezierInterpolation = [\n  name: 'cubic-bezier',\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n];\ntype Interpolation =\n  | LinearInterpolation\n  | ExponentialInterpolation\n  | CubicBezierInterpolation;\n\ntype OutputType = any;\n\ntype InterpolateArgs = [\n  interpolation: Interpolation,\n  input: number,\n  ...stops: (number | OutputType)[],\n];\n\nfunction linearInterpolation(\n  input: number,\n  input1: number,\n  output1: OutputType,\n  input2: number,\n  output2: OutputType,\n): OutputType {\n  if (typeof output1 === 'number' && typeof output2 === 'number') {\n    return (\n      output1 + ((input - input1) / (input2 - input1)) * (output2 - output1)\n    );\n  }\n\n  try {\n    const outputColor1 = toColor(output1);\n    const outputColor2 = toColor(output2);\n    return colorToRGB(\n      outputColor1.map((val, index) => {\n        return Math.ceil(\n          linearInterpolation(input, input1, val, input2, outputColor2[index]),\n        );\n      }) as ColorArray,\n    );\n  } catch (er) {\n    console.log(er);\n  }\n\n  throw new Error('Unsupported output type for linear interpolation.');\n}\n\nexport const interpolate: ExpressionCbFunc<InterpolateArgs, OutputType> = ([\n  interpolationFn,\n  inputFn,\n  ...stops\n]) => {\n  if (stops.length < 2) {\n    throw new Error('At least two stops are required');\n  }\n  if (stops.length < 2 || stops.length % 2 !== 0) {\n    throw new Error('Invalid stops provided.');\n  }\n  const input = inputFn();\n\n  if (typeof input !== 'number') {\n    throw new Error('Input must be a number.');\n  }\n  const interpolation = interpolationFn();\n  for (let i = 0; i < stops.length - 2; i += 2) {\n    const stopInput1 = stops[i]() as number;\n    const stopOutput1 = stops[i + 1]() as OutputType;\n    const stopInput2 = stops[i + 2]() as number;\n    const stopOutput2 = stops[i + 3]() as OutputType;\n\n    if (input >= stopInput1 && input <= stopInput2) {\n      if (interpolation[0] === 'linear') {\n        return linearInterpolation(\n          input,\n          stopInput1,\n          stopOutput1,\n          stopInput2,\n          stopOutput2,\n        );\n      }\n      // else if (interpolation[0] === 'exponential') {\n      //   const base = interpolation[1];\n      //   return exponentialInterpolation(\n      //     input,\n      //     base,\n      //     stopInput1,\n      //     stopOutput1,\n      //     stopInput2,\n      //     stopOutput2,\n      //   );\n      // }\n    }\n  }\n\n  throw new Error('Invalid interpolation type.');\n};\n","import { interpolate } from './interpolate';\nimport { step } from './step';\n\nimport type {\n  ExpressionFunc,\n  InterpolationExpressionName,\n} from '../../interfaces';\n\nexport const interpolationExpressions: Record<\n  InterpolationExpressionName,\n  ExpressionFunc\n> = {\n  step,\n  interpolate,\n};\n","import type { ExpressionCbFunc } from '../../interfaces';\n\ntype OutputType = number | string | boolean | null;\n\nexport const step: ExpressionCbFunc<(number | OutputType)[], OutputType> = (\n  args,\n) => {\n  const [inputFn, defaultValue, ...stops] = args;\n  const input = inputFn();\n\n  if (typeof input !== 'number') {\n    return defaultValue() as OutputType;\n  }\n\n  for (let i = 0; i < stops.length - 2; i += 2) {\n    const stopInput = stops[i]() as number;\n    const stopOutput = stops[i + 1]() as OutputType;\n    const nextStopInput = stops[i + 2]() as number;\n\n    if (input >= stopInput && input < nextStopInput) {\n      return stopOutput;\n    }\n  }\n\n  if (input >= (stops[stops.length - 2]() as number)) {\n    return stops[stops.length - 1]();\n  }\n\n  return defaultValue();\n};\n","import e from '../utils/evaluateArgs';\n\nimport type {\n  Data,\n  ExpressionCbFunc,\n  LookupExpressionName,\n  SimpleType,\n} from '../interfaces';\n\ntype GetArg = [key: string] | [key: string, obj: Record<string, any>];\n\nfunction get([key, objExp]: GetArg, data: Data): SimpleType | null {\n  const target = objExp || data;\n  if (target && typeof target === 'object' && key in target) {\n    return target[key];\n  }\n  return null;\n}\n\nfunction has([key, objExp]: GetArg, data: Data): boolean {\n  const target = objExp || data;\n  return !!(target && typeof target === 'object' && key in target);\n}\n\nfunction at([index, array]: [index: number, array: any[]]): SimpleType {\n  return array[index];\n}\n\ntype InArgs = [keyword: string | boolean | number, input: string | any[]];\nfunction inFunc([keyword, input]: InArgs): boolean {\n  if (typeof input === 'string') {\n    return input.includes(String(keyword));\n  } else if (Array.isArray(input)) {\n    return input.includes(keyword);\n  }\n  throw new Error(\n    `Invalid input type for 'in'. Expected string or array, got ${typeof input}.`,\n  );\n}\n\nconst length = ([item]: [string | any[]]) => {\n  if (typeof item === 'string' || Array.isArray(item)) {\n    return item.length;\n  }\n  return undefined;\n};\n\ntype IndexOfArgs =\n  | [keyword: string | boolean | number, input: string | any[]]\n  | [keyword: string | boolean | number, input: string | any[], index: number];\nfunction indexOf([keyword, input, startIndex]: IndexOfArgs): number {\n  if (typeof input === 'string') {\n    return input.indexOf(String(keyword), startIndex);\n  } else if (Array.isArray(input)) {\n    return input.indexOf(keyword, startIndex);\n  }\n\n  throw new Error(\n    `Invalid input type for 'index-of'. Expected string or array, got ${typeof input}.`,\n  );\n}\n\ntype SliceArgs =\n  | [input: string | any[], startIndex: number]\n  | [input: string | any[], startIndex: number, endIndex: number];\n\nfunction slice(args: SliceArgs): string | any[] {\n  const [input, startIndex, endIndex] = args;\n\n  if (typeof input === 'string') {\n    return input.slice(startIndex, endIndex);\n  } else if (Array.isArray(input)) {\n    return input.slice(startIndex, endIndex);\n  }\n\n  throw new Error(\n    `Invalid input type for 'slice'. Expected string or array, got ${typeof input}.`,\n  );\n}\n\nexport const lookupExpressions: Record<LookupExpressionName, ExpressionCbFunc> =\n  {\n    get: e(get),\n    length: e(length),\n    at: e(at),\n    has: e(has),\n    in: e(inFunc),\n    'index-of': e(indexOf),\n    slice: e(slice),\n  };\n","import e from '../utils/evaluateArgs';\n\nimport type { ExpressionCbFunc, MathExpressionName } from '../interfaces';\n\nexport const mathExpressions: Record<\n  MathExpressionName,\n  ExpressionCbFunc<number[], number>\n> = {\n  '+': e((args) => args.reduce((a, b) => a + b, 0)),\n  '-': e((args) => args.reduce((a, b) => a - b)),\n  '*': e((args) => args.reduce((a, b) => a * b, 1)),\n  '/': e((args) => args.reduce((a, b) => a / b)),\n  '%': e((args) => args[0] % args[1]),\n  '^': e((args) => Math.pow(args[0], args[1])),\n  abs: e((args) => Math.abs(args[0])),\n  acos: e((args) => Math.acos(args[0])),\n  asin: e((args) => Math.asin(args[0])),\n  atan: e((args) => Math.atan(args[0])),\n  ceil: e((args) => Math.ceil(args[0])),\n  cos: e((args) => Math.cos(args[0])),\n  e: () => Math.E,\n  floor: e((args) => Math.floor(args[0])),\n  ln: e((args) => Math.log(args[0])),\n  ln2: () => Math.LN2,\n  log10: e((args) => Math.log10(args[0])),\n  log2: e((args) => Math.log2(args[0])),\n  max: e((args) => Math.max(...args)),\n  min: e((args) => Math.min(...args)),\n  pi: () => Math.PI,\n  round: e((args) => Math.round(args[0])),\n  sin: e((args) => Math.sin(args[0])),\n  sqrt: e((args) => Math.sqrt(args[0])),\n  tan: e((args) => Math.tan(args[0])),\n};\n","import e from '../utils/evaluateArgs';\n\nimport type { ExpressionCbFunc, StringExpressionName } from '../interfaces';\n\nexport const stringExpressions: Record<\n  StringExpressionName,\n  ExpressionCbFunc<string[], string>\n> = {\n  concat: e((args) => args.reduce((a, b) => String(a) + String(b), '')),\n  downcase: e((args) => String(args[0]).toLowerCase()),\n  upcase: e((args) => String(args[0]).toUpperCase()),\n};\n","export const tryConvert = (\n  converter: (arg: any, data: any) => any,\n  arg: any,\n  data: any,\n): any => {\n  try {\n    const result = converter(arg, data);\n    if (result !== undefined) {\n      return result;\n    }\n  } catch {\n    // ignore errors\n  }\n  return undefined;\n};\n","import { tryConvert } from './tryConvert';\n\nimport type { ExpressionFunc, SimpleType } from '../interfaces';\n\nexport default function fallback<\n  T extends SimpleType[] = SimpleType[],\n  R = T[0],\n>(cb: ExpressionFunc<T, R | undefined>): ExpressionFunc<T[], R> {\n  return (args: T[], data) => {\n    for (const arg of args) {\n      const result = tryConvert(cb, arg, data);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n    throw new Error(`Received a mismatched type`);\n  };\n}\n","import e from '../utils/evaluateArgs';\nimport f from '../utils/fallback';\n\nimport type { ExpressionCbFunc, TypeExpressionName } from '../interfaces';\n\ntype ArrayType = 'string' | 'number' | 'boolean';\n\ntype ArrayArgs =\n  | [value: any[]]\n  | [type: ArrayType, value: any[]]\n  | [type: ArrayType, n: number, value: any[]];\n\nconst array = (args: ArrayArgs): any[] => {\n  const [firstArg, secondArg, thirdArg] = args;\n  let requiredType: ArrayType | undefined = undefined;\n  let requiredLength: number | undefined = undefined;\n  let value: any[] | undefined;\n\n  if (\n    typeof firstArg === 'string' &&\n    ['string', 'number', 'boolean'].includes(firstArg)\n  ) {\n    requiredType = firstArg;\n\n    if (typeof secondArg === 'number') {\n      requiredLength = secondArg;\n      value = thirdArg;\n    } else {\n      value = secondArg;\n    }\n  } else if (Array.isArray(firstArg)) {\n    value = firstArg;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error('Expected an array');\n  }\n  if (requiredType && !value.every((item) => typeof item === requiredType)) {\n    throw new Error(\n      `Expected all items in array to be of type ${requiredType}`,\n    );\n  }\n\n  if (requiredLength && value.length !== requiredLength) {\n    throw new Error(`Expected array of length ${requiredLength}`);\n  }\n  return value;\n};\n\nfunction typeOfValue(value: any): string {\n  if (value === null) return 'null';\n  switch (typeof value) {\n    case 'string':\n      return 'string';\n    case 'number':\n      return 'number';\n    case 'boolean':\n      return 'boolean';\n    case 'object':\n      if (Array.isArray(value)) {\n        let arrayType = 'value';\n        if (value.every((item) => typeof item === 'number')) {\n          arrayType = 'number';\n        } else if (value.every((item) => typeof item === 'string')) {\n          arrayType = 'string';\n        } else if (value.every((item) => typeof item === 'boolean')) {\n          arrayType = 'boolean';\n        }\n        return `array<${arrayType}, ${value.length}>`;\n      } else {\n        return 'object';\n      }\n    default:\n      return 'undefined';\n  }\n}\n\nexport const typeExpressions: Record<TypeExpressionName, ExpressionCbFunc> = {\n  array: e(array),\n  boolean: e(\n    f<boolean[]>((arg) => (typeof arg === 'boolean' ? arg : undefined)),\n  ),\n  literal: e(([arg]) => arg),\n  number: e(f<number[]>((arg) => (typeof arg === 'number' ? arg : undefined))),\n  object: e(\n    f<Record<string, any>[]>((arg) =>\n      arg !== null && typeof arg === 'object' && !Array.isArray(arg)\n        ? arg\n        : undefined,\n    ),\n  ),\n\n  string: e(f((arg) => (typeof arg === 'string' ? arg : undefined))),\n  'to-boolean': e(f(Boolean)),\n  'to-number': e(f(Number)),\n  'to-string': e(f(String)),\n  typeof: e(([arg]) => typeOfValue(arg)),\n};\n","import { decisionExpressions } from './expressions/decisionExpressions';\nimport { interpolationExpressions } from './expressions/interpolationExpressions';\nimport { lookupExpressions } from './expressions/lookupExpressions';\nimport { mathExpressions } from './expressions/mathExpressions';\nimport { stringExpressions } from './expressions/stringExpressions';\nimport { typeExpressions } from './expressions/typeExpressions';\n\nimport type {\n  Data,\n  Expression,\n  ExpressionFunc,\n  ExpressionName,\n  SimpleType,\n} from './interfaces';\n\nexport function isExpression(value: any): value is Expression {\n  if (Array.isArray(value)) {\n    const [lookup, ...cases] = value;\n    const l = lookup as ExpressionName;\n    return (\n      typeof l === 'string' &&\n      l !== 'literal' &&\n      l in expressions &&\n      cases.length > 0\n    );\n  }\n  return false;\n}\n\nconst expressions: { [key in ExpressionName]: ExpressionFunc } = {\n  ...mathExpressions,\n  ...typeExpressions,\n  ...stringExpressions,\n  ...lookupExpressions,\n  ...decisionExpressions,\n  ...interpolationExpressions,\n};\n\nexport function evaluate<T extends SimpleType[] = SimpleType[], R = T[0]>(\n  expression: Expression,\n  data: Data = {},\n): R {\n  const [name, ...args] = expression;\n  const expressionFun = expressions[name];\n  if (expressionFun) {\n    return expressionFun(\n      args.map((arg) => () => (isExpression(arg) ? evaluate(arg, data) : arg)),\n      data,\n    );\n  }\n  throw new Error(`Expression \"${name}\" is not supported.`);\n}\n"],"names":["evaluateArgs","cb","args","data","unwrap","map","a","decisionExpressions","e","expr","b","left","right","coalesce","i","length","arg","all","any","case","Error","condition","value","fallback","match","lookupFn","cases","lookup","defValue","splice","fry","COLORS","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","honeydew","hotpink","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgrey","lightgreen","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","toColor","hex","test","hexToColor","name","colorNameToColor","isRgb","rgb","rgbaPattern","matches","parseInt","parseFloat","rgbToColor","obj","isColorObj","r","g","colorObjectToColor","result","exec","linearInterpolation","input","input1","output1","input2","output2","outputColor1","outputColor2","array","join","colorToRGB","val","index","Math","ceil","er","console","log","interpolationExpressions","step","inputFn","defaultValue","stops","stopInput","stopOutput","nextStopInput","interpolate","interpolationFn","interpolation","stopInput1","stopOutput1","stopInput2","stopOutput2","lookupExpressions","get","key","objExp","target","item","Array","isArray","at","has","in","keyword","includes","String","startIndex","indexOf","slice","endIndex","mathExpressions","reduce","pow","abs","acos","asin","atan","cos","E","floor","ln","ln2","LN2","log10","log2","max","min","pi","PI","round","sin","sqrt","stringExpressions","concat","downcase","toLowerCase","upcase","toUpperCase","tryConvert","converter","typeExpressions","firstArg","secondArg","thirdArg","requiredType","requiredLength","every","boolean","f","literal","number","object","string","Boolean","Number","typeof","arrayType","typeOfValue","isExpression","expressions","__spreadValues","evaluate","expression","expressionFun"],"mappings":"AAOA,SAAwBA,EAGtBC,GACO,MAAA,CAACC,EAAwBC,KAC9B,MAAMC,EAASF,EAAKG,KAAKC,GAAMA,MACxB,OAAAL,EAAGG,EAAQD,EAAI,CAE1B,CCoBA,MAuEaI,EAGT,CACF,IAAKC,GA1GP,UAAcC,IACZ,OAAQA,CACV,IAyGE,KAAMD,GAvGR,UAAmBF,EAAGI,IACpB,OAAOJ,IAAMI,CACf,IAsGE,IAAKF,GApGP,UAAmBG,EAAMC,IACvB,OAAOD,EAAOC,CAChB,IAmGE,KAAMJ,GAjGR,UAA0BG,EAAMC,IAC9B,OAAOD,GAAQC,CACjB,IAgGE,KAAMJ,GA9FR,UAAgBG,EAAMC,IACpB,OAAOD,IAASC,CAClB,IA6FE,IAAKJ,GA3FP,UAAsBG,EAAMC,IAC1B,OAAOD,EAAOC,CAChB,IA0FE,KAAMJ,GAxFR,UAA6BG,EAAMC,IAIjC,OAAOD,GAAQC,CACjB,IAoFEC,SAlF8CX,IAC9C,IAAA,IAASY,EAAI,EAAGA,EAAIZ,EAAKa,OAAQD,IAAK,CAC9B,MAAAE,EAAMd,EAAKY,KACb,GAAAE,QACK,OAAAA,CAEX,CACO,OAAA,IAAA,EA4EPC,IAzE6Cf,IAC7C,IAAA,IAASY,EAAI,EAAGA,EAAIZ,EAAKa,OAAQD,IAAK,CAEpC,IADYZ,EAAKY,KAER,OAAA,CAEX,CACO,OAAA,CAAA,EAmEPI,IAhE6ChB,IAC7C,IAAA,IAASY,EAAI,EAAGA,EAAIZ,EAAKa,OAAQD,IAAK,CAEpC,GADYZ,EAAKY,KAER,OAAA,CAEX,CACO,OAAA,CAAA,EA0DPK,KArCGjB,IACC,GAAAA,EAAKa,OAAS,EAChB,MAAM,IAAIK,MACR,iFAIA,GAAAlB,EAAKa,OAAS,GAAM,EACtB,MAAM,IAAIK,MACR,gEAGJ,IAAA,IAASN,EAAI,EAAGA,EAAIZ,EAAKa,OAAS,EAAGD,GAAK,EAAG,CACrC,MAAAO,EAAYnB,EAAKY,KACjBQ,EAAQpB,EAAKY,EAAI,KACvB,GAAIO,EACK,OAAAC,CAEX,CAEA,OAAOC,EADUrB,EAAKA,EAAKa,OAAS,KACpB,EAkBhBS,MAxDsCtB,IACtC,MAAOuB,KAAaC,GAASxB,EACvByB,EAASF,IAETG,EAAWF,EAAMG,QAAO,EAAIH,EAAMX,OAAS,GAAG,GACpD,IAAA,IAASe,EAAM,EAAGA,EAAMJ,EAAMX,OAAS,EAAGe,GAAO,EAAG,CAElD,GADYJ,EAAMI,OACNH,EACH,OAAAD,EAAMI,EAAM,IAEvB,CACA,OAAOF,GAAS,GC5ELG,EAAS,CACpBC,UAAW,UACXC,aAAc,UACdC,KAAM,UACNC,WAAY,UACZC,MAAO,UACPC,MAAO,UACPC,OAAQ,UACRC,MAAO,UACPC,eAAgB,UAChBC,KAAM,UACNC,WAAY,UACZC,MAAO,UACPC,UAAW,UACXC,UAAW,UACXC,WAAY,UACZC,UAAW,UACXC,MAAO,UACPC,eAAgB,UAChBC,SAAU,UACVC,QAAS,UACTC,KAAM,UACNC,SAAU,UACVC,SAAU,UACVC,cAAe,UACfC,SAAU,UACVC,UAAW,UACXC,UAAW,UACXC,YAAa,UACbC,eAAgB,UAChBC,WAAY,UACZC,WAAY,UACZC,QAAS,UACTC,WAAY,UACZC,aAAc,UACdC,cAAe,UACfC,cAAe,UACfC,cAAe,UACfC,WAAY,UACZC,SAAU,UACVC,YAAa,UACbC,QAAS,UACTC,WAAY,UACZC,UAAW,UACXC,YAAa,UACbC,YAAa,UACbC,QAAS,UACTC,UAAW,UACXC,WAAY,UACZC,KAAM,UACNC,UAAW,UACXC,KAAM,UACNC,MAAO,UACPC,YAAa,UACbC,SAAU,UACVC,QAAS,UACT,aAAc,UACdC,OAAQ,UACRC,MAAO,UACPC,MAAO,UACPC,SAAU,UACVC,cAAe,UACfC,UAAW,UACXC,aAAc,UACdC,UAAW,UACXC,WAAY,UACZC,UAAW,UACXC,qBAAsB,UACtBC,UAAW,UACXC,WAAY,UACZC,UAAW,UACXC,YAAa,UACbC,cAAe,UACfC,aAAc,UACdC,eAAgB,UAChBC,eAAgB,UAChBC,YAAa,UACbC,KAAM,UACNC,UAAW,UACXC,MAAO,UACPC,QAAS,UACTC,OAAQ,UACRC,iBAAkB,UAClBC,WAAY,UACZC,aAAc,UACdC,aAAc,UACdC,eAAgB,UAChBC,gBAAiB,UACjBC,kBAAmB,UACnBC,gBAAiB,UACjBC,gBAAiB,UACjBC,aAAc,UACdC,UAAW,UACXC,UAAW,UACXC,SAAU,UACVC,YAAa,UACbC,KAAM,UACNC,QAAS,UACTC,MAAO,UACPC,UAAW,UACXC,OAAQ,UACRC,UAAW,UACXC,OAAQ,UACRC,cAAe,UACfC,UAAW,UACXC,cAAe,UACfC,cAAe,UACfC,WAAY,UACZC,UAAW,UACXC,KAAM,UACNC,KAAM,UACNC,KAAM,UACNC,WAAY,UACZC,OAAQ,UACRC,cAAe,UACfC,IAAK,UACLC,UAAW,UACXC,UAAW,UACXC,YAAa,UACbC,OAAQ,UACRC,WAAY,UACZC,SAAU,UACVC,SAAU,UACVC,OAAQ,UACRC,OAAQ,UACRC,QAAS,UACTC,UAAW,UACXC,UAAW,UACXC,KAAM,UACNC,YAAa,UACbC,UAAW,UACXC,IAAK,UACLC,KAAM,UACNC,QAAS,UACTC,OAAQ,UACRC,UAAW,UACXC,OAAQ,UACRC,MAAO,UACPC,MAAO,UACPC,WAAY,UACZC,OAAQ,UACRC,YAAa,WCjGR,SAASC,EAAQtJ,GAClB,GAhCkB,iBADTuJ,EAiCHvJ,IAhCwB,2BAA2BwJ,KAAKD,GAiChE,OAAOE,EAAWzJ,GACpB,GAboB,iBADD0J,EAcI1J,IAbS0J,KAAQjJ,EActC,OASJ,SAA0BiJ,GACjB,OAAAD,EAAWhJ,EAAOiJ,GAC3B,CAXWC,CAAiB3J,GAC1B,GAjCF,SAAeuJ,GAIb,MAAsB,iBAARA,GAHR,wFAG8BC,KAAKD,EAC3C,CA4BaK,CAAM5J,GACf,OAkDJ,SAAoB6J,GAClB,MACMC,EAAc,gDAEhB,IAAAC,EAEJ,GAAKA,EAAUF,EAAI3J,MALA,oCAMV,MAAA,CACL8J,SAASD,EAAQ,GAAI,IACrBC,SAASD,EAAQ,GAAI,IACrBC,SAASD,EAAQ,GAAI,KAEb,GAAAA,EAAUF,EAAI3J,MAAM4J,GACvB,MAAA,CACLE,SAASD,EAAQ,GAAI,IACrBC,SAASD,EAAQ,GAAI,IACrBC,SAASD,EAAQ,GAAI,IACrBE,WAAWF,EAAQ,KAIvB,MAAM,IAAIjK,MAAM,QAAQ+J,sBAC1B,CAxEWK,CAAWlK,GACpB,GA5BF,SAAoBmK,GAClB,GAAmB,iBAARA,GAA4B,OAARA,EAI7B,MAHe,MAAOA,GAAO,MAAOA,GAAO,MAAOA,MAE9C,MAAOA,IAA0B,iBAAVA,EAAInL,GAAkBmL,EAAInL,GAAK,GAAKmL,EAAInL,GAAK,GAGnE,OAAA,CACT,CAoBaoL,CAAWpK,GACpB,OAwEG,UAA4BqK,EAAEA,EAAAC,EAAGA,EAAGlL,EAAAA,EAAAJ,EAAGA,IACrC,MAAA,CAACqL,EAAGC,EAAGlL,UAAa,IAANJ,EAAkB,CAACA,GAAK,GAC/C,CA1EWuL,CAAmBvK,GAnB9B,IAAqB0J,EArBNH,EA0Cb,MAAM,IAAIzJ,MAAM,QAAQE,kCAC1B,CAMA,SAASyJ,EAAWF,GAOd,IAAAiB,EAEJ,GAAKA,EARY,6CAQMC,KAAKlB,GACnB,MAAA,CACLS,SAASQ,EAAO,GAAKA,EAAO,GAAI,IAChCR,SAASQ,EAAO,GAAKA,EAAO,GAAI,IAChCR,SAASQ,EAAO,GAAKA,EAAO,GAAI,KAExB,GAAAA,EAbM,0DAaaC,KAAKlB,GAC3B,MAAA,CACLS,SAASQ,EAAO,GAAKA,EAAO,GAAI,IAChCR,SAASQ,EAAO,GAAKA,EAAO,GAAI,IAChCR,SAASQ,EAAO,GAAKA,EAAO,GAAI,IAChCR,SAASQ,EAAO,GAAKA,EAAO,GAAI,IAAM,KAE9B,GAAAA,EAnBI,sDAmBaC,KAAKlB,GACzB,MAAA,CACLS,SAASQ,EAAO,GAAI,IACpBR,SAASQ,EAAO,GAAI,IACpBR,SAASQ,EAAO,GAAI,KAEZ,GAAAA,EAvBV,sEAuB4BC,KAAKlB,GAC1B,MAAA,CACLS,SAASQ,EAAO,GAAI,IACpBR,SAASQ,EAAO,GAAI,IACpBR,SAASQ,EAAO,GAAI,IACpBR,SAASQ,EAAO,GAAI,IAAM,KAG9B,MAAM,IAAI1K,MAAM,QAAQyJ,sBAC1B,CCxEA,SAASmB,EACPC,EACAC,EACAC,EACAC,EACAC,GAEA,GAAuB,iBAAZF,GAA2C,iBAAZE,EACxC,OACEF,GAAYF,EAAQC,IAAWE,EAASF,IAAYG,EAAUF,GAI9D,IACI,MAAAG,EAAe1B,EAAQuB,GACvBI,EAAe3B,EAAQyB,GACtB,ODsFJ,SAAoBG,GACzB,MAAO,OAAOA,EAAMC,KAAK,OAC3B,CCxFWC,CACLJ,EAAajM,KAAI,CAACsM,EAAKC,IACdC,KAAKC,KACVd,EAAoBC,EAAOC,EAAQS,EAAKP,EAAQG,EAAaK,cAI5DG,GACPC,QAAQC,IAAIF,EACd,CAEM,MAAA,IAAI3L,MAAM,oDAClB,CAEO,MChDM8L,EAGT,CACFC,KCPAjN,IAEA,MAAOkN,EAASC,KAAiBC,GAASpN,EACpC+L,EAAQmB,IAEV,GAAiB,iBAAVnB,EACT,OAAOoB,IAGT,IAAA,IAASvM,EAAI,EAAGA,EAAIwM,EAAMvM,OAAS,EAAGD,GAAK,EAAG,CACtC,MAAAyM,EAAYD,EAAMxM,KAClB0M,EAAaF,EAAMxM,EAAI,KACvB2M,EAAgBH,EAAMxM,EAAI,KAE5B,GAAAmL,GAASsB,GAAatB,EAAQwB,EACzB,OAAAD,CAEX,CAEA,OAAIvB,GAAUqB,EAAMA,EAAMvM,OAAS,KAC1BuM,EAAMA,EAAMvM,OAAS,KAGvBsM,GAAa,EDfpBK,YD2CwE,EACxEC,EACAP,KACGE,MAEC,GAAAA,EAAMvM,OAAS,EACX,MAAA,IAAIK,MAAM,mCAElB,GAAIkM,EAAMvM,OAAS,GAAKuM,EAAMvM,OAAS,GAAM,EACrC,MAAA,IAAIK,MAAM,2BAElB,MAAM6K,EAAQmB,IAEV,GAAiB,iBAAVnB,EACH,MAAA,IAAI7K,MAAM,2BAElB,MAAMwM,EAAgBD,IACtB,IAAA,IAAS7M,EAAI,EAAGA,EAAIwM,EAAMvM,OAAS,EAAGD,GAAK,EAAG,CACtC,MAAA+M,EAAaP,EAAMxM,KACnBgN,EAAcR,EAAMxM,EAAI,KACxBiN,EAAaT,EAAMxM,EAAI,KACvBkN,EAAcV,EAAMxM,EAAI,KAE1B,GAAAmL,GAAS4B,GAAc5B,GAAS8B,GACT,WAArBH,EAAc,GACT,OAAA5B,EACLC,EACA4B,EACAC,EACAC,EACAC,EAeR,CAEM,MAAA,IAAI5M,MAAM,8BAA6B,GGvBxC,MAAM6M,EACX,CACEC,IAAK1N,GAvET,UAAc2N,EAAKC,GAAiBjO,GAClC,MAAMkO,EAASD,GAAUjO,EACzB,OAAIkO,GAA4B,iBAAXA,GAAuBF,KAAOE,EAC1CA,EAAOF,GAET,IACT,IAkEIpN,OAAQP,GA3CG,EAAE8N,MACf,GAAoB,iBAATA,GAAqBC,MAAMC,QAAQF,GAC5C,OAAOA,EAAKvN,MAEP,IAwCL0N,GAAIjO,GA5DR,UAAaoM,EAAOJ,IAClB,OAAOA,EAAMI,EACf,IA2DI8B,IAAKlO,GAlET,UAAc2N,EAAKC,GAAiBjO,GAClC,MAAMkO,EAASD,GAAUjO,EACzB,SAAUkO,GAA4B,iBAAXA,KAAuBF,KAAOE,GAC3D,IAgEIM,GAAInO,GAzDR,UAAiBoO,EAAS3C,IACpB,GAAiB,iBAAVA,EACT,OAAOA,EAAM4C,SAASC,OAAOF,IACpB,GAAAL,MAAMC,QAAQvC,GAChB,OAAAA,EAAM4C,SAASD,GAExB,MAAM,IAAIxN,MACR,qEAAqE6K,KAEzE,IAiDI,WAAYzL,GArChB,UAAkBoO,EAAS3C,EAAO8C,IAC5B,GAAiB,iBAAV9C,EACT,OAAOA,EAAM+C,QAAQF,OAAOF,GAAUG,GAC7B,GAAAR,MAAMC,QAAQvC,GAChB,OAAAA,EAAM+C,QAAQJ,EAASG,GAGhC,MAAM,IAAI3N,MACR,2EAA2E6K,KAE/E,IA4BIgD,MAAOzO,GAtBX,SAAeN,GACb,MAAO+L,EAAO8C,EAAYG,GAAYhP,EAElC,GAAiB,iBAAV+L,EACF,OAAAA,EAAMgD,MAAMF,EAAYG,GACtB,GAAAX,MAAMC,QAAQvC,GAChB,OAAAA,EAAMgD,MAAMF,EAAYG,GAGjC,MAAM,IAAI9N,MACR,wEAAwE6K,KAE5E,KC1EakD,EAGT,CACF,IAAK3O,GAAGN,GAASA,EAAKkP,QAAO,CAAC9O,EAAGI,IAAMJ,EAAII,GAAG,KAC9C,IAAKF,GAAGN,GAASA,EAAKkP,QAAO,CAAC9O,EAAGI,IAAMJ,EAAII,MAC3C,IAAKF,GAAGN,GAASA,EAAKkP,QAAO,CAAC9O,EAAGI,IAAMJ,EAAII,GAAG,KAC9C,IAAKF,GAAGN,GAASA,EAAKkP,QAAO,CAAC9O,EAAGI,IAAMJ,EAAII,MAC3C,IAAKF,GAAGN,GAASA,EAAK,GAAKA,EAAK,KAChC,IAAKM,GAAGN,GAAS2M,KAAKwC,IAAInP,EAAK,GAAIA,EAAK,MACxCoP,IAAK9O,GAAGN,GAAS2M,KAAKyC,IAAIpP,EAAK,MAC/BqP,KAAM/O,GAAGN,GAAS2M,KAAK0C,KAAKrP,EAAK,MACjCsP,KAAMhP,GAAGN,GAAS2M,KAAK2C,KAAKtP,EAAK,MACjCuP,KAAMjP,GAAGN,GAAS2M,KAAK4C,KAAKvP,EAAK,MACjC4M,KAAMtM,GAAGN,GAAS2M,KAAKC,KAAK5M,EAAK,MACjCwP,IAAKlP,GAAGN,GAAS2M,KAAK6C,IAAIxP,EAAK,MAC/BM,EAAG,IAAMqM,KAAK8C,EACdC,MAAOpP,GAAGN,GAAS2M,KAAK+C,MAAM1P,EAAK,MACnC2P,GAAIrP,GAAGN,GAAS2M,KAAKI,IAAI/M,EAAK,MAC9B4P,IAAK,IAAMjD,KAAKkD,IAChBC,MAAOxP,GAAGN,GAAS2M,KAAKmD,MAAM9P,EAAK,MACnC+P,KAAMzP,GAAGN,GAAS2M,KAAKoD,KAAK/P,EAAK,MACjCgQ,IAAK1P,GAAGN,GAAS2M,KAAKqD,OAAOhQ,KAC7BiQ,IAAK3P,GAAGN,GAAS2M,KAAKsD,OAAOjQ,KAC7BkQ,GAAI,IAAMvD,KAAKwD,GACfC,MAAO9P,GAAGN,GAAS2M,KAAKyD,MAAMpQ,EAAK,MACnCqQ,IAAK/P,GAAGN,GAAS2M,KAAK0D,IAAIrQ,EAAK,MAC/BsQ,KAAMhQ,GAAGN,GAAS2M,KAAK2D,KAAKtQ,EAAK,MACjC+J,IAAKzJ,GAAGN,GAAS2M,KAAK5C,IAAI/J,EAAK,OC5BpBuQ,EAGT,CACFC,OAAQlQ,GAAGN,GAASA,EAAKkP,QAAO,CAAC9O,EAAGI,IAAMoO,OAAOxO,GAAKwO,OAAOpO,IAAI,MACjEiQ,SAAUnQ,GAAGN,GAAS4O,OAAO5O,EAAK,IAAI0Q,gBACtCC,OAAQrQ,GAAGN,GAAS4O,OAAO5O,EAAK,IAAI4Q,iBCVzBC,EAAa,CACxBC,EACAhQ,EACAb,KAEI,IACI,MAAA2L,EAASkF,EAAUhQ,EAAKb,GAC9B,QAAe,IAAX2L,EACK,OAAAA,CAEH,CAAA,MAAAtL,GAER,CACO,ECTT,SAAwBe,EAGtBtB,GACO,MAAA,CAACC,EAAWC,KACjB,IAAA,MAAWa,KAAOd,EAAM,CACtB,MAAM4L,EAASiF,EAAW9Q,EAAIe,EAAKb,GACnC,QAAe,IAAX2L,EACK,OAAAA,CAEX,CACM,MAAA,IAAI1K,MAAM,6BAA4B,CAEhD,CC2DO,MAAM6P,EAAgE,CAC3EzE,MAAOhM,GAjEMN,IACb,MAAOgR,EAAUC,EAAWC,GAAYlR,EACxC,IAAImR,EACAC,EACAhQ,EAiBJ,GAdsB,iBAAb4P,GACP,CAAC,SAAU,SAAU,WAAWrC,SAASqC,IAE1BG,EAAAH,EAEU,iBAAdC,GACQG,EAAAH,EACT7P,EAAA8P,GAEA9P,EAAA6P,GAED5C,MAAMC,QAAQ0C,KACf5P,EAAA4P,IAEL3C,MAAMC,QAAQlN,GACX,MAAA,IAAIF,MAAM,qBAEd,GAAAiQ,IAAiB/P,EAAMiQ,OAAOjD,UAAgBA,IAAS+C,IACzD,MAAM,IAAIjQ,MACR,6CAA6CiQ,KAI7C,GAAAC,GAAkBhQ,EAAMP,SAAWuQ,EACrC,MAAM,IAAIlQ,MAAM,4BAA4BkQ,KAEvC,OAAAhQ,CAAA,IAiCPkQ,QAAShR,EACPiR,GAAczQ,GAAwB,kBAARA,EAAoBA,OAAM,KAE1D0Q,QAASlR,GAAE,EAAEQ,KAASA,IACtB2Q,OAAQnR,EAAEiR,GAAazQ,GAAwB,iBAARA,EAAmBA,OAAM,KAChE4Q,OAAQpR,EACNiR,GAA0BzQ,GAChB,OAARA,GAA+B,iBAARA,GAAqBuN,MAAMC,QAAQxN,QAEtD,EADAA,KAKR6Q,OAAQrR,EAAEiR,GAAGzQ,GAAwB,iBAARA,EAAmBA,OAAM,KACtD,aAAcR,EAAEiR,EAAEK,UAClB,YAAatR,EAAEiR,EAAEM,SACjB,YAAavR,EAAEiR,EAAE3C,SACjBkD,OAAQxR,GAAE,EAAEQ,KA/Cd,SAAqBM,GACf,GAAU,OAAVA,EAAuB,MAAA,OAC3B,cAAeA,GACb,IAAK,SACI,MAAA,SACT,IAAK,SACI,MAAA,SACT,IAAK,UACI,MAAA,UACT,IAAK,SACC,GAAAiN,MAAMC,QAAQlN,GAAQ,CACxB,IAAI2Q,EAAY,QAQhB,OAPI3Q,EAAMiQ,OAAOjD,GAAyB,iBAATA,IACnB2D,EAAA,SACH3Q,EAAMiQ,OAAOjD,GAAyB,iBAATA,IAC1B2D,EAAA,SACH3Q,EAAMiQ,OAAOjD,GAAyB,kBAATA,MAC1B2D,EAAA,WAEP,SAASA,MAAc3Q,EAAMP,SAAM,CAEnC,MAAA,SAEX,QACS,MAAA,YAEb,CAqBuBmR,CAAYlR,mVChF5B,SAASmR,EAAa7Q,GACvB,GAAAiN,MAAMC,QAAQlN,GAAQ,CACxB,MAAOK,KAAWD,GAASJ,EAGzB,MAAa,iBAFLK,GAGF,YAHEA,QAIHyQ,GACL1Q,EAAMX,OAAS,CAEnB,CACO,OAAA,CACT,CAEA,MAAMqR,EAA2DC,EAC5DA,EAAAA,EAAAA,EAAAA,EAAAA,EAAA,CAAA,EAAAlD,GACA8B,GACAR,GACAxC,GACA1N,GACA2M,GAGE,SAASoF,EACdC,EACApS,EAAa,IAEb,MAAO6K,KAAS9K,GAAQqS,EAClBC,EAAgBJ,EAAYpH,GAClC,GAAIwH,EACK,OAAAA,EACLtS,EAAKG,KAAKW,GAAQ,IAAOmR,EAAanR,GAAOsR,EAAStR,EAAKb,GAAQa,IACnEb,GAGJ,MAAM,IAAIiB,MAAM,eAAe4J,uBACjC"}