import { EventEmitter } from 'events';
import { GeoJSON, Position as Position$1, Geometry, Polygon, Feature } from 'geojson';
import { LngLatArray as LngLatArray$1, LngLatBoundsArray as LngLatBoundsArray$1 } from '@nextgis/utils';

interface ApplyMixinOptions {
    replace?: boolean;
}
type Ctor = any;
declare function applyMixins(derivedCtor: Ctor, baseCtors: Ctor[], opt?: ApplyMixinOptions): void;
declare function allProperties(obj: Record<string, unknown>): string[];
declare function mixinProperties(derivedCtor: Ctor, baseCtor: Ctor, properties: string[]): void;

declare function arrayChunk<T>(arr: T[], size: number): T[][];

/**
 * Comparison of the contents of two arrays. Position of elements is ignored.
 * @example
 * ```javascript
 * arrayCompare(['a', 'b'], ['b', 'a']) // true
 * arrayCompare(['a', 'b'], ['b']) // false
 * arrayCompare('asdf1234', '1234asdf') // true
 * ```
 */
declare function arrayCompare(array1: any[], array2: any[]): boolean;
/**
 * Comparing content and position of elements of two arrays.
 * @example
 * ```javascript
 * arrayCompareStrict(['a', 'b'], ['a', 'b']) // true
 * arrayCompareStrict(['a', 'b'], ['b', 'a']) // false
 * arrayCompareStrict('asdf1234', 'asdf1234') // true
 * arrayCompareStrict('asdf1234', '1234asdf') // false
 * ```
 */
declare function arrayCompareStrict(array1: any[], array2: any[]): boolean;

declare function arrayUnique<T = any>(arr: T[]): T[];

declare class Clipboard {
    silent: boolean;
    constructor(text?: string);
    static copy(text: string): boolean;
    copy(text: string): boolean;
    private copyToClipboard;
    private copyNodeContentsToClipboard;
}

declare function debounce<T extends (...args: any[]) => void>(cb: T, wait?: number): T & {
    clear: () => void;
};
declare function DebounceDecorator(wait?: number): (_target: unknown, key: string, descriptor: PropertyDescriptor) => PropertyDescriptor;

declare function debugLog(message?: string): boolean;

declare function deepmerge<T>(x: Partial<T>, y: Partial<T>, mergeArray?: boolean): T;

/**
 * from https://github.com/CesiumGS/cesium/blob/master/Source/Core/defined.js
 *
 * @param val - The object.
 * @returns Returns true if the object is defined, returns false otherwise.
 *
 * @example
 * ```javascript
 * if (defined(positions)) {
 *   doSomething();
 * } else {
 *   doSomethingElse();
 * }
 * ```
 */
declare function defined<T>(val: T): val is Exclude<T, null | undefined>;
/**
 * from https://github.com/CesiumGS/cesium/blob/master/Source/Core/defined.js
 *
 * @param val - The object.
 * @returns Returns true if the object is defined and not empty string, returns false otherwise.
 *
 * @example
 * ```javascript
 * full('foo') // true
 * full('') // false
 * full(undefined) // false
 * full(0) // true
 * ```
 */
declare function full<T>(val: T): val is Exclude<T, null | undefined>;

declare class Events<E = any> {
    private emitter;
    private readonly _eventsStatus;
    constructor(emitter: EventEmitter);
    setEventStatus(event: keyof E, status: boolean): void;
    onLoad(event: keyof E | (keyof E)[]): Promise<this>;
    getEventStatus(event: keyof E): boolean;
}

interface FlattenOptions {
    flatArray?: boolean;
}
declare function flatten(data: Record<string, any>, opt?: FlattenOptions): Record<string, any>;

/**
 * Map zoom level. From 0 to 22
 */
type ZoomLevel = number;
/**
 * Longitude and latitude coordinate, measured in degrees.
 */
interface LatLng {
    /**
     * Latitude, measured in degrees.
     */
    lat: number;
    /**
     * Longitude, measured in degrees.
     */
    lng: number;
}
/**
 * A Position is an array of coordinates.
 * {@link https://tools.ietf.org/html/rfc7946#section-3.1.1| GeoJSON standard}
 * Array should contain between two and three elements.
 * The previous GeoJSON specification allowed more elements (e.g., which could be used to represent M values),
 * but the current specification only allows X, Y, and (optionally) Z to be defined.
 */
type Position = [number, number];
/**
 * Array of coordinates, measured in degrees, in [west, south, east, north] order.
 * {@link https://tools.ietf.org/html/rfc7946#section-5 | GeoJSON standard}
 */
type LngLatBoundsArray = [west: number, south: number, east: number, north: number] | number[];
/**
 * Array of two numbers representing longitude and latitude.
 */
type LngLatArray = Position | number[];

declare function checkExtent(extent: number[]): extent is LngLatBoundsArray;

/**
 * Radius of the earth in kilometers
 */
declare const EARTHS_RADIUS = 6371;

declare function degrees2meters(lng: number, lat: number): [number, number];
declare function meters2degrees(x: number, y: number): LngLatArray;
declare function degrees2Radian(deg: number): number;

declare function coordinatesCount(geojson: GeoJSON): number;
declare function getCoordinates(geojson: GeoJSON): Position$1[];
declare function eachCoordinates(geojson: GeoJSON, cb: (position: Position$1) => void): void;
declare function getPolygons(geojson: GeoJSON): Position$1[][];
declare function eachGeometry(geojson: GeoJSON, cb: (position: Geometry) => void): void;

declare function latLngToLngLatArray(latLng: LatLng): LngLatArray;
declare function lngLatArrayToLatLng(coord: LngLatArray): LatLng;

declare function getBoundsPolygon(b: LngLatBoundsArray): Polygon;
declare function getBoundsCoordinates(b: LngLatBoundsArray): number[][];
declare function getBoundsFeature(b: LngLatBoundsArray): Feature<Polygon>;

declare function getCirclePolygonCoordinates(lng: number, lat: number, 
/** In kilometers */
radius?: number, points?: number): Position$1[];
declare function getCircleFeature(lng: number, lat: number, radius?: number, points?: number): Feature<Polygon>;

declare function getIdentifyRadius(center: LngLatArray$1, zoom: number, pixelRadius: number): number;

declare function getSquarePolygonCoordinates(lng: number, lat: number, halfSideLength?: number): Position$1[];

declare function isLngLatBoundsArray(array: unknown): array is LngLatBoundsArray$1;

type FeatureProperties = {
    [name: string]: any;
};
type FeatureProperties_<F extends Feature = Feature> = F['properties'];
type ExtractFeatureProperties<F extends Feature = Feature> = FeatureProperties_<F> extends null ? FeatureProperties : FeatureProperties;

declare function round(val: number, toFixed?: number): number;

declare function objectAssign<T, U>(target: T, source: U): T & U;
/**
 * Copy the values of all of the enumerable own properties from one or more source objects to a
 * target object. Returns the target object.
 * @param target - The target object to copy to.
 * @param source1 - The first source object from which to copy properties.
 * @param source2 - The second source object from which to copy properties.
 */
declare function objectAssign<T, U, V>(target: T, source1: U, source2: V): T & U & V;
/**
 * Copy the values of all of the enumerable own properties from one or more source objects to a
 * target object. Returns the target object.
 * @param target - The target object to copy to.
 * @param source1 - The first source object from which to copy properties.
 * @param source2 - The second source object from which to copy properties.
 * @param source3 - The third source object from which to copy properties.
 */
declare function objectAssign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;

declare function objectDeepEqual<T extends Record<string, any> = Record<string, any>>(o: T, p: T): boolean;

type NoUndefinedField<T> = {
    [P in keyof T]: Exclude<T[P], undefined>;
};
declare function objectRemoveEmpty<T extends Record<any, any>>(obj: T): NoUndefinedField<T>;

declare const isBrowser: boolean;
declare const type: 'browser' | 'node';
declare function getGlobalVariable(): any;

declare function reEscape(s: string): string;

declare function sleep(delay?: number): Promise<void>;

/**
 * Camelize a string, cutting the string by separator character.
 * @param text to camelize
 * @param separator Word separator (string or regexp)
 * @return string Camelized text
 */
declare function camelize(text: string, separator?: RegExp): string;

declare function capitalize(str: string): string;

declare function numberWithSpaces(x: number): string;

/**
 * This specification attempts to create a standard for representing metadata
 * about multiple types of web-based layers, to aid clients in configuration and browsing.
 *
 * From {@link https://github.com/mapbox/tilejson-spec/tree/master/2.2.0}
 */
interface TileJson {
    /**
     * A semver.org style version number. Describes the version of
     * the TileJSON spec that is implemented by this JSON object.
     */
    tilejson: string;
    /**
     * Default: null. A name describing the tileset. The name can
     * contain any legal character. Implementations SHOULD NOT interpret the
     * name as HTML.
     * @defaultValue null
     */
    name?: string;
    /**
     * Default: null. A text description of the tileset. The
     * description can contain any legal character. Implementations SHOULD NOT
     * interpret the description as HTML.
     */
    description?: string;
    /**
     * Default: "1.0.0". A semver.org style version number. When
     * changes across tiles are introduced, the minor version MUST change.
     * This may lead to cut off labels. Therefore, implementors can decide to
     * clean their cache when the minor version changes. Changes to the patch
     * level MUST only have changes to tiles that are contained within one tile.
     * When tiles change significantly, the major version MUST be increased.
     * Implementations MUST NOT use tiles with different major versions.
     */
    version?: string;
    /**
     * Default: null. Contains an attribution to be displayed
     * when the map is shown to a user. Implementations MAY decide to treat this
     * as HTML or literal text. For security reasons, make absolutely sure that
     * this field can't be abused as a vector for XSS or beacon tracking.
     */
    attribution?: string;
    /**
     * Default: null. Contains a mustache template to be used to
     * format data from grids for interaction.
     * See https://github.com/mapbox/utfgrid-spec/tree/master/1.2
     * for the interactivity specification.
     */
    template?: string;
    /**
     * Default: null. Contains a legend to be displayed with the map.
     * Implementations MAY decide to treat this as HTML or literal text.
     * For security reasons, make absolutely sure that this field can't be
     * abused as a vector for XSS or beacon tracking.
     */
    legend?: string;
    /**
     * Default: "xyz". Either "xyz" or "tms". Influences the y
     * direction of the tile coordinates.
     * The global-mercator (aka Spherical Mercator) profile is assumed.
     */
    scheme?: string;
    /**
     * REQUIRED. An array of tile endpoints. `{z}`, `{x}` and `{y}`, if present,
     * are replaced with the corresponding integers. If multiple endpoints are specified, clients
     * may use any combination of endpoints. All endpoints MUST return the same
     * content for the same URL. The array MUST contain at least one endpoint.
     */
    tiles: string[];
    /**
     * Default: []. An array of interactivity endpoints. `{z}`, `{x}`
     * and `{y}`, if present, are replaced with the corresponding integers. If multiple
     * endpoints are specified, clients may use any combination of endpoints.
     * All endpoints MUST return the same content for the same URL.
     * If the array doesn't contain any entries, interactivity is not supported
     * for this tileset.
     * See https://github.com/mapbox/utfgrid-spec/tree/master/1.2
     * for the interactivity specification.
     */
    grids?: string[];
    /**
     * Default: []. An array of data files in GeoJSON format.
     * `{z}`, `{x}` and `{y}`, if present,
     * are replaced with the corresponding integers. If multiple
     * endpoints are specified, clients may use any combination of endpoints.
     * All endpoints MUST return the same content for the same URL.
     * If the array doesn't contain any entries, then no data is present in
     * the map.
     */
    data?: string[];
    /**
     * Default: 0.`>= 0, <= 30.`
     * An integer specifying the minimum zoom level.
     */
    minzoom?: number;
    /**
     * Default: 30. `>= 0, <= 30.`
     * An integer specifying the maximum zoom level. MUST be `>= minzoom`.
     */
    maxzoom?: number;
    /**
     * Default: [-180, -90, 180, 90].
     * The maximum extent of available map tiles. Bounds MUST define an area
     * covered by all zoom levels. The bounds are represented in WGS:84
     * latitude and longitude values, in the order left, bottom, right, top.
     * Values may be integers or floating point numbers.
     */
    bounds?: number[];
    /**
     * Default: null.
     * The first value is the longitude, the second is latitude (both in
     * WGS:84 values), the third value is the zoom level as an integer.
     * Longitude and latitude MUST be within the specified bounds.
     * The zoom level MUST be between minzoom and maxzoom.
     * Implementations can use this value to set the default location. If the
     * value is null, implementations may use their own algorithm for
     * determining a default location.
     */
    center?: number[];
}

/**
 * Same as Partial<T> but goes deeper and makes Partial<T> all its properties and sub-properties.
 */
type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends Array<infer U> ? Array<DeepPartial<U>> : T[P] extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : DeepPartial<T[P]>;
};

type Obj = Record<string | number, any>;
declare function isObjKey<O extends Obj = Obj>(obj: O, key: unknown): key is keyof O;
/**
 *
 * @deprecated - use isObjKey instead
 */
declare function keyInObj<O extends Obj = Obj>(obj: O, key: unknown): key is keyof O;

type AnyJson = boolean | number | string | null | JsonArray | JsonMap;
interface JsonMap {
    [key: string]: AnyJson;
}
type JsonArray = Array<AnyJson>;
declare function isAnyJson(val: unknown): val is AnyJson;
declare function isJsonArray(val: unknown): val is JsonArray;
declare function isJsonMap(val: unknown): val is JsonMap;

type Type<T> = new (...args: any[]) => T;

declare function isObject(val: unknown): val is Record<string | number, any>;
declare function isArray(val: unknown): val is [];

declare function unflatten(data: Record<string, any> | any[]): Record<string, any>;

declare function fixUrlStr(url: string): string;
declare function updateUrlParams(urlStr: string, params: Record<string, string | undefined>): string;

export { type AnyJson, type ApplyMixinOptions, Clipboard, DebounceDecorator, type DeepPartial, EARTHS_RADIUS, Events, type ExtractFeatureProperties, type FeatureProperties, type FeatureProperties_, type FlattenOptions, type JsonArray, type JsonMap, type LatLng, type LngLatArray, type LngLatBoundsArray, type Position, type TileJson, type Type, type ZoomLevel, allProperties, applyMixins, arrayChunk, arrayCompare, arrayCompareStrict, arrayUnique, camelize, capitalize, checkExtent, coordinatesCount, debounce, debugLog, deepmerge, defined, degrees2Radian, degrees2meters, eachCoordinates, eachGeometry, fixUrlStr, flatten, full, getBoundsCoordinates, getBoundsFeature, getBoundsPolygon, getCircleFeature, getCirclePolygonCoordinates, getCoordinates, getGlobalVariable, getIdentifyRadius, getPolygons, getSquarePolygonCoordinates, isAnyJson, isArray, isBrowser, isJsonArray, isJsonMap, isLngLatBoundsArray, isObjKey, isObject, keyInObj, latLngToLngLatArray, lngLatArrayToLatLng, meters2degrees, mixinProperties, numberWithSpaces, objectAssign, objectDeepEqual, objectRemoveEmpty, reEscape, round, sleep, type, unflatten, updateUrlParams };
