/** Bundle of @nextgis/webmap; version: 3.0.0-alpha.17; author: NextGIS */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var paint = require('@nextgis/paint');
var propertiesFilter = require('@nextgis/properties-filter');
var utils = require('@nextgis/utils');
var events = require('events');

const WEB_MAP_CONTAINER = {};
function getWebMap(id) {
  return WEB_MAP_CONTAINER[id];
}
function setWebMap(id, webMap) {
  WEB_MAP_CONTAINER[id] = webMap;
}

function createToggleControl(createButtonControl, options) {
  const link = document.createElement("div");
  let status = false;
  if (options.getStatus) {
    status = options.getStatus();
  } else if (options.status) {
    status = options.status;
  }
  const title = options.title || "";
  const html = options.html;
  function setTitle() {
    if (title) {
      if (typeof title === "string") {
        link.title = title;
      } else {
        link.title = status ? title.on : title.off;
      }
      link.setAttribute("aria-label", link.title);
    }
  }
  setTitle();
  function _setHtml(htmlDef) {
    if (htmlDef instanceof HTMLElement) {
      link.innerHTML = "";
      link.appendChild(htmlDef);
    } else if (typeof htmlDef === "string") {
      link.innerHTML = htmlDef;
    }
  }
  function setHtml() {
    if (html) {
      if (typeof html === "string" || html instanceof HTMLElement) {
        _setHtml(html);
      } else {
        _setHtml(status ? html.on : html.off);
      }
      link.setAttribute("aria-label", link.title);
    }
  }
  setHtml();
  function _setClass(addClass, impact) {
    addClass.split(" ").forEach((x) => {
      if (impact) {
        link.classList.add(x);
      } else {
        link.classList.remove(x);
      }
    });
  }
  function setClass() {
    if (options.addClassOn) {
      _setClass(options.addClassOn, status);
    }
    if (options.addClassOff) {
      _setClass(options.addClassOff, !status);
    }
  }
  if (options.addClass) {
    _setClass(options.addClass, true);
  }
  setClass();
  const changeStatus = (status_) => {
    if (status_ !== void 0) {
      status = status_;
    }
    setHtml();
    setTitle();
    setClass();
  };
  const onClick = (status_) => {
    status = status_ !== void 0 ? status_ : !status;
    if (options.onClick) {
      const afterClick = options.onClick(status);
      Promise.resolve(afterClick).then(() => changeStatus()).catch(() => status = !status);
    } else {
      changeStatus();
    }
  };
  const buttonControl = createButtonControl({
    html: link,
    onClick
  });
  buttonControl.onClick = onClick;
  buttonControl.changeStatus = changeStatus;
  return buttonControl;
}

function findMostFrequentGeomType(arr) {
  const counts = {};
  for (let fry = 0; fry < arr.length; fry++) {
    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);
  }
  let maxName;
  for (const c in counts) {
    const count = maxName !== void 0 ? counts[maxName] : 0;
    if (counts[c] > (count || 0)) {
      maxName = c;
    }
  }
  return maxName;
}
function detectGeometryType(geojson) {
  let geometry;
  if (geojson.type === "FeatureCollection") {
    const featuresTypes = geojson.features.map(
      (f) => f.geometry.type
    );
    geometry = findMostFrequentGeomType(featuresTypes);
  } else if (geojson.type === "GeometryCollection") {
    const geometryTypes = geojson.geometries.map(
      (g) => g.type
    );
    geometry = findMostFrequentGeomType(geometryTypes);
  } else if (geojson.type === "Feature") {
    geometry = geojson.geometry.type;
  } else {
    geometry = geojson.type;
  }
  return geometry;
}

const paintTypeAlias = {
  polygon: "path",
  line: "path",
  point: "circle"
};
const typeAlias = {
  Point: "point",
  LineString: "line",
  MultiPoint: "point",
  Polygon: "polygon",
  MultiLineString: "line",
  MultiPolygon: "polygon"
};
function updateGeoJsonAdapterOptions(opt) {
  if (opt.data) {
    const geomType = typeAlias[detectGeometryType(opt.data)];
    const p = opt.paint;
    if (p && paint.isPaint(p)) {
      p.type = p.type ? p.type : geomType === "polygon" || geomType === "line" ? "path" : "html" in p || "className" in p ? "icon" : paintTypeAlias[geomType];
    }
    opt.type = opt.type || geomType;
  }
  return opt;
}

var __defProp$8 = Object.defineProperty;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$8 = (obj, key, value) => __defNormalProp$8(obj, typeof key !== "symbol" ? key + "" : key, value);
class KeyCodes {
  constructor() {
    __publicField$8(this, "backspace", 8);
    __publicField$8(this, "tab", 9);
    __publicField$8(this, "enter", 13);
    __publicField$8(this, "shift", 16);
    __publicField$8(this, "ctrl", 17);
    __publicField$8(this, "alt", 18);
    __publicField$8(this, "pause/break", 19);
    __publicField$8(this, "caps_lock", 20);
    __publicField$8(this, "escape", 27);
    __publicField$8(this, "page_up", 33);
    __publicField$8(this, "page_down", 34);
    __publicField$8(this, "end", 35);
    __publicField$8(this, "home", 36);
    __publicField$8(this, "left_arrow", 37);
    __publicField$8(this, "up_arrow", 38);
    __publicField$8(this, "right_arrow", 39);
    __publicField$8(this, "down_arrow", 40);
    __publicField$8(this, "insert", 45);
    __publicField$8(this, "delete", 46);
    __publicField$8(this, "left_window_key", 91);
    __publicField$8(this, "right_window_key", 92);
    __publicField$8(this, "select_key", 93);
    __publicField$8(this, "numpad_0", 96);
    __publicField$8(this, "numpad_1", 97);
    __publicField$8(this, "numpad_2", 98);
    __publicField$8(this, "numpad_3", 99);
    __publicField$8(this, "numpad_4", 100);
    __publicField$8(this, "numpad_5", 101);
    __publicField$8(this, "numpad_6", 102);
    __publicField$8(this, "numpad_7", 103);
    __publicField$8(this, "numpad_8", 104);
    __publicField$8(this, "numpad_9", 105);
    __publicField$8(this, "multiply", 106);
    __publicField$8(this, "add", 107);
    __publicField$8(this, "subtract", 109);
    __publicField$8(this, "decimal_point", 110);
    __publicField$8(this, "divide", 111);
    __publicField$8(this, "f1", 112);
    __publicField$8(this, "f2", 113);
    __publicField$8(this, "f3", 114);
    __publicField$8(this, "f4", 115);
    __publicField$8(this, "f5", 116);
    __publicField$8(this, "f6", 117);
    __publicField$8(this, "f7", 118);
    __publicField$8(this, "f8", 119);
    __publicField$8(this, "f9", 120);
    __publicField$8(this, "f10", 121);
    __publicField$8(this, "f11", 122);
    __publicField$8(this, "f12", 123);
    __publicField$8(this, "num_lock", 144);
    __publicField$8(this, "scroll_lock", 145);
    __publicField$8(this, "semi-colon", 186);
    __publicField$8(this, "equal_sign", 187);
    __publicField$8(this, ",", 188);
    // "comma";
    __publicField$8(this, "-", 189);
    // "dash";
    __publicField$8(this, ".", 190);
    // "period";
    __publicField$8(this, "/", 191);
    // "forward slash";
    __publicField$8(this, "`", 192);
    // "grave accent";
    __publicField$8(this, "[", 219);
    // "open bracket";
    __publicField$8(this, "\\", 220);
    // "back slash";
    __publicField$8(this, "]", 221);
    // "close braket";
    __publicField$8(this, "'", 222);
  }
  // "single quote"
}

var __defProp$7 = Object.defineProperty;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$7 = (obj, key, value) => __defNormalProp$7(obj, typeof key !== "symbol" ? key + "" : key, value);
class Keys {
  constructor() {
    __publicField$7(this, "keyCodeAlias", new KeyCodes());
    __publicField$7(this, "keys", {});
    __publicField$7(this, "_windowOnFocus");
    __publicField$7(this, "_keysPressed");
    __publicField$7(this, "_keysReleased");
    this._windowOnFocus = this.windowOnFocus.bind(this);
    this._keysPressed = this.keysPressed.bind(this);
    this._keysReleased = this.keysReleased.bind(this);
    this.addKeyboardEventsListener();
  }
  pressed(keyName) {
    const code = this.keyCodeAlias[keyName];
    return !!code && this.keys[code];
  }
  addKeyboardEventsListener() {
    if (typeof window !== "undefined") {
      window.addEventListener("focus", this._windowOnFocus, false);
      window.addEventListener("keydown", this._keysPressed, false);
      window.addEventListener("keyup", this._keysReleased, false);
    }
  }
  removeKeyboardEventsListener() {
    if (typeof window !== "undefined") {
      window.removeEventListener("focus", this._windowOnFocus, false);
      window.removeEventListener("keydown", this._keysPressed, false);
      window.removeEventListener("keyup", this._keysReleased, false);
    }
  }
  keysPressed(e) {
    e.stopPropagation();
    if (!this.keys[e.keyCode]) {
      this.keys[e.keyCode] = true;
    }
  }
  keysReleased(e) {
    e.stopPropagation();
    this.keys[e.keyCode] = false;
  }
  windowOnFocus() {
    this.keys = {};
  }
}

var __defProp$6 = Object.defineProperty;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$6 = (obj, key, value) => __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
class StateItem {
  constructor(webMap, opt) {
    this.webMap = webMap;
    __publicField$6(this, "name");
    __publicField$6(this, "event");
    __publicField$6(this, "value");
    if (opt) {
      if (opt.value) {
        this.setValue(opt.value);
      }
      if (opt.name) {
        this.name = opt.name;
      }
      if (opt.event) {
        if (typeof opt.event === "string") {
          this.event = [opt.event];
        } else {
          this.event = opt.event;
        }
      }
    }
  }
  getValue() {
    return this.value;
  }
  setValue(val) {
    this.value = val;
  }
}

var __defProp$5 = Object.defineProperty;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$5 = (obj, key, value) => __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
class BoundState extends StateItem {
  constructor() {
    super(...arguments);
    __publicField$5(this, "name", "bounds");
    __publicField$5(this, "event", ["moveend"]);
  }
  getValue() {
    return this.webMap.getBounds();
  }
  setValue(bounds) {
    this.webMap.setView({ bounds });
  }
  toString() {
    const data = this.getValue();
    if (data) {
      return data.slice(0, 4).map((x) => x.toFixed(5)).join("_");
    }
    return void 0;
  }
  parse(str) {
    const lngLat = str.split("_").map(Number);
    return lngLat;
  }
}

var __defProp$4 = Object.defineProperty;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$4 = (obj, key, value) => __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
class CenterState extends StateItem {
  constructor() {
    super(...arguments);
    __publicField$4(this, "name", "center");
    __publicField$4(this, "event", ["moveend"]);
  }
  getValue() {
    return this.webMap.getCenter();
  }
  setValue(val) {
    this.webMap.setCenter(val);
  }
  toString() {
    const data = this.getValue();
    if (data) {
      const d = data.map((x) => x.toFixed(5));
      return d[0] + "_" + d[1];
    }
    return "";
  }
  parse(str) {
    const lngLat = str.split("_").map(Number);
    return lngLat;
  }
}

var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
class ZoomState extends StateItem {
  constructor() {
    super(...arguments);
    __publicField$3(this, "name", "zoom");
    __publicField$3(this, "event", ["zoomend"]);
  }
  getValue() {
    const zoom = this.webMap.getZoom();
    return zoom !== void 0 ? Math.round(zoom) : void 0;
  }
  setValue(val) {
    this.webMap.setZoom(val);
  }
  toString() {
    return String(this.getValue());
  }
  parse(str) {
    return Number(str);
  }
}

function clearObject(obj) {
  for (const member in obj) {
    delete obj[member];
  }
}

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
let ID = 0;
const OPTIONS = {
  minZoom: 0,
  maxZoom: 22,
  paint: {
    color: "#0000ff",
    // blue
    opacity: 0.4,
    strokeOpacity: 1,
    stroke: true,
    radius: 8,
    weight: 1
  },
  selectedPaint: {
    color: "#00008b",
    // darkblue
    opacity: 0.4,
    strokeOpacity: 1,
    stroke: true,
    radius: 12,
    weight: 1
  },
  create: true
};
const _WebMapMain = class _WebMapMain {
  constructor(mapOptions) {
    __publicField$2(this, "options", OPTIONS);
    // `WebMapEvents` must be `E` but its not work correct
    __publicField$2(this, "emitter", new events.EventEmitter());
    __publicField$2(this, "keys", _WebMapMain.keys);
    __publicField$2(this, "mapAdapter");
    __publicField$2(this, "runtimeParams", []);
    __publicField$2(this, "getPaintFunctions", _WebMapMain.getPaintFunctions);
    __publicField$2(this, "mapStateItems", [CenterState, ZoomState, BoundState]);
    __publicField$2(this, "id", ID++);
    /**
     * From runtime params
     */
    __publicField$2(this, "mapState", []);
    __publicField$2(this, "_initMapState", {});
    __publicField$2(this, "_starterKits");
    __publicField$2(this, "_extent");
    __publicField$2(this, "_eventsStatus", {});
    __publicField$2(this, "_coordFromMapClickAbort");
    __publicField$2(this, "_mapEvents", {});
    this.mapAdapter = mapOptions.mapAdapter;
    this._starterKits = mapOptions.starterKits || [];
    if (mapOptions) {
      this.options = utils.deepmerge(OPTIONS || {}, mapOptions);
    }
    if (this.options.runtimeParams) {
      this.runtimeParams = this.options.runtimeParams;
    }
    this._addEventsListeners();
    if (this.options.tileJson) {
      this._setTileJsonOptions(this.options.tileJson);
    }
    if (this.options.create) {
      this.create();
    }
  }
  getId() {
    return this.id;
  }
  /**
   * Manual way to create a map (If {@link MapOptions.create} is `false`).
   * @example
   * ```javascript
   * const webMap = new WebMap(options);
   * webMap.create().then(() => doSomething());
   * ```
   */
  async create() {
    if (!this.getEventStatus("create")) {
      await this._setInitMapState(this.mapStateItems);
      await this._setupMap();
      this._emitStatusEvent("create", this);
    }
    return this;
  }
  setRuntimeParams(params) {
    this.runtimeParams.push(params);
  }
  /**
   * Destroys WebMap, MapAdapter, clears all layers and turn off all event listeners
   */
  destroy() {
    this._removeEventListeners();
    clearObject(this._emitStatusEvent);
    if (this.mapAdapter.destroy) {
      this.mapAdapter.destroy();
    }
  }
  mapStateWithFunc(func) {
    const state = {};
    this.mapState.forEach((x) => {
      state[x.name] = func(x);
    });
    return state;
  }
  getStateAsString() {
    return this.mapStateWithFunc((x) => x.toString());
  }
  getState() {
    return this.mapStateWithFunc((x) => x.getValue());
  }
  getRuntimeParams() {
    const state = {};
    this.mapState.forEach((x) => {
      for (const r of this.runtimeParams) {
        const val = r.get(x.name);
        if (val !== void 0) {
          state[x.name] = x.parse(val);
          break;
        }
      }
    });
    return state;
  }
  /**
   * Returns the HTML element that contains the map.
   * @returns The map's container
   */
  getContainer() {
    if (this.mapAdapter.getContainer) {
      return this.mapAdapter.getContainer();
    } else if (this.options.target) {
      if (this.options.target instanceof HTMLElement) {
        return this.options.target;
      } else if (typeof this.options.target === "string") {
        const element = document.getElementById(this.options.target);
        if (element) {
          return element;
        }
      }
    }
  }
  /**
   * Set the cursor icon to be displayed when hover icon on the map container.
   * @param cursor - Available cursor name from https://developer.mozilla.org/ru/docs/Web/CSS/cursor
   */
  setCursor(cursor) {
    this.onLoad().then(() => {
      if (this.mapAdapter.setCursor) {
        this.mapAdapter.setCursor(cursor);
      }
    });
  }
  getCursor() {
    if (this.mapAdapter.getCursor) {
      return this.mapAdapter.getCursor();
    }
    const container = this.getContainer();
    if (container) {
      return container.style.cursor;
    }
  }
  /**
   * Set the center of the current view.
   * @param lngLat - Array of two numbers representing longitude and latitude of the center of the map view.
   *
   * @example
   * ```javascript
   * // Mount Everest 27° 59′ 17″ N, 86° 55′ 31″ E
   * webMap.setCenter([86.925278, 27.988056]);
   * ```
   */
  setCenter(lngLat) {
    this.mapAdapter.setCenter(lngLat);
    return this;
  }
  /**
   * Returns the map's geographical centerpoint.
   * @returns lngLat Array of two numbers representing longitude and latitude of the center of the map view.
   *
   * @example
   * ```javascript
   * // Mount Everest 27° 59′ 17″ N, 86° 55′ 31″ E
   * webMap.getCenter(); // [86.925278, 27.988056]
   * ```
   */
  getCenter() {
    return this.mapAdapter.getCenter();
  }
  getBounds() {
    if (this.mapAdapter.getBounds) {
      return this.mapAdapter.getBounds();
    }
  }
  getBoundsPolygon() {
    const bounds = this.getBounds();
    if (bounds) {
      const feature = utils.getBoundsFeature(bounds);
      return feature;
    }
  }
  /**
   * Zoom to a specific zoom level.
   * @param zoom - The zoom level to set (0-24).
   */
  setZoom(zoom) {
    this.mapAdapter.setZoom(zoom);
    return this;
  }
  /**
   * Returns the map's current zoom level.
   * @returns The map's current zoom level (0-24).
   */
  getZoom() {
    const zoom = this.mapAdapter.getZoom();
    if (typeof zoom === "number") {
      return zoom;
    }
  }
  zoomIn() {
    if (this.mapAdapter.zoomIn) {
      this.mapAdapter.zoomIn();
    } else {
      const zoom = this.getZoom();
      if (zoom !== void 0) {
        const toZoom = zoom + 1;
        this.setZoom(toZoom);
      }
    }
  }
  zoomOut() {
    if (this.mapAdapter.zoomOut) {
      this.mapAdapter.zoomOut();
    } else {
      const zoom = this.getZoom();
      if (zoom !== void 0) {
        const toZoom = zoom - 1;
        this.setZoom(toZoom);
      }
    }
  }
  setView(lngLatOrOpt, zoom) {
    if (Array.isArray(lngLatOrOpt)) {
      const lngLat = lngLatOrOpt;
      if (this.mapAdapter.setView && lngLat && utils.defined(zoom)) {
        this.mapAdapter.setView(lngLat, zoom);
      } else {
        if (lngLat) {
          this.mapAdapter.setCenter(lngLat);
        }
        if (utils.defined(zoom)) {
          this.mapAdapter.setZoom(zoom);
        }
      }
    } else {
      const viewOpt = lngLatOrOpt;
      if (this.mapAdapter.setView) {
        this.mapAdapter.setView(viewOpt);
      }
    }
  }
  /**
   * Sets a map view that contains the given geographical bounds.
   * @param bounds - Array of coordinates, measured in degrees, in [west, south, east, north] order.
   *
   * @example
   * ```javascript
   * // Whole world
   * webMap.fitBounds([0, -90, 180, 90]);
   * ```
   */
  fitBounds(bounds, options) {
    utils.checkExtent(bounds);
    if (bounds.every((x) => utils.defined(x))) {
      if (bounds[1] < -85.06) {
        bounds[1] = -85.06;
      }
      if (bounds[3] > 85.06) {
        bounds[3] = 85.06;
      }
      this.mapAdapter.fitBounds(bounds, options);
    }
    return this;
  }
  /**
   * Checking the status of any asynchronous operation
   * @param event - The name of the event whose status is checked
   *
   * @example
   * ```javascript
   * var webMap = new WebMap(options);
   * webMap.getEventStatus('create'); // false
   * webMap.emitter.on('create', function () {
   *   webMap.getEventStatus('create'); // true
   * })
   * ```
   */
  getEventStatus(event) {
    const _eventName = event;
    const status = this._eventsStatus[_eventName];
    return status != null ? status : false;
  }
  /**
   * helper method to wait for events to load. By default, card creation is tracked
   * @param event - The name of the event whose status is checked
   *
   * @example
   * ```javascript
   * var webMap = new WebMap(options);
   * webMap.onLoad().then(function () {
   *   webMap.getEventStatus('create'); // true
   * })
   *
   * // use async/await syntax
   * async function () {
   *   await webMap.onLoad();
   *   doSomething();
   * }
   *
   * ```
   */
  onLoad(event = "create") {
    return new Promise((res) => {
      if (this.getEventStatus(event)) {
        res(this);
      } else {
        this.emitter.once(event, () => {
          res(this);
        });
      }
    });
  }
  onMapLoad(cb) {
    return new Promise((res) => {
      var _a;
      const _resolve = () => {
        const mapAdapter = this.mapAdapter;
        if (cb) {
          cb(mapAdapter);
        }
        if (mapAdapter) {
          res(mapAdapter);
        }
      };
      const isLoaded = (_a = this.mapAdapter.isLoaded) != null ? _a : true;
      if (this.mapAdapter.map && isLoaded) {
        _resolve();
      } else {
        this.mapAdapter.emitter.once("create", () => {
          _resolve();
        });
      }
    });
  }
  getLayerAdapters() {
    return this.mapAdapter.layerAdapters;
  }
  getLayerAdapter(name) {
    const adapter = this.mapAdapter.layerAdapters[name];
    return adapter;
  }
  locate(opt, events) {
    if (this.mapAdapter && this.mapAdapter.locate) {
      return this.mapAdapter.locate(opt, events);
    }
    const stop = () => ({});
    return { stop };
  }
  stopGetCoordFromMapClick() {
    if (this._coordFromMapClickAbort) {
      this._coordFromMapClickAbort();
      this._coordFromMapClickAbort = void 0;
    }
  }
  getCoordFromMapClick() {
    if (!this._coordFromMapClickAbort) {
      return new Promise((resolve, reject) => {
        const cursor = this.getCursor() || "grab";
        this._removeEventListeners({ include: ["click"] });
        this.setCursor("crosshair");
        const onCancel_ = () => {
          this.setCursor(cursor);
          this._addEventsListeners({ include: ["click"] });
          this.mapAdapter.emitter.off("click", onMapClick);
          this._coordFromMapClickAbort = void 0;
        };
        const onMapClick = (e) => {
          onCancel_();
          utils.deprecatedMapClick(e);
          resolve(e.lngLat);
        };
        this.mapAdapter.emitter.once("click", onMapClick);
        this._coordFromMapClickAbort = onCancel_;
      });
    } else {
      return this.getCoordFromMapClick();
    }
  }
  _emitStatusEvent(eventName, data) {
    const _eventName = eventName;
    this._eventsStatus[_eventName] = true;
    this.emitter.emit(_eventName, data);
  }
  async _addLayerProviders() {
  }
  async _onLoadSync() {
  }
  async _setupMap() {
    if (!this.mapAdapter) {
      throw new Error("WebMap `mapAdapter` option is not set");
    }
    await this.mapAdapter.create(this.options);
    this._zoomToInitialExtent();
    await this._addLayerProviders();
    await this._onLoadSync();
    this._emitStatusEvent("build-map", this.mapAdapter);
    return this;
  }
  _setTileJsonOptions(tileJson) {
    if (tileJson.center) {
      this.options.center = tileJson.center;
    }
    if (tileJson.bounds) {
      this.options.bounds = tileJson.bounds;
    }
    if (utils.defined(tileJson.maxzoom)) {
      this.options.zoom = tileJson.maxzoom;
    }
    if (utils.defined(tileJson.minzoom)) {
      this.options.zoom = tileJson.minzoom;
    }
    if (utils.defined(tileJson.maxzoom) && utils.defined(tileJson.minzoom)) {
      this.options.zoom = (tileJson.maxzoom + tileJson.minzoom) / 2;
    }
  }
  _zoomToInitialExtent() {
    const { center, zoom, bounds } = this.options;
    if (this._extent) {
      this.fitBounds(this._extent);
    } else if (center && zoom) {
      this.setView(center, zoom);
    } else if (bounds) {
      this.fitBounds(bounds);
      if (zoom !== void 0) {
        this.setZoom(zoom);
      }
    }
  }
  _setInitMapState(states) {
    for (const X of states) {
      const state = new X(this);
      this.mapState.push(state);
      for (const r of this.runtimeParams) {
        const str = r.get(state.name);
        if (str !== void 0) {
          const val = state.parse(str);
          this._initMapState[state.name] = val;
          Object.defineProperty(this.options, state.name, {
            value: val,
            configurable: true,
            enumerable: true
          });
          break;
        }
      }
    }
  }
  _addEventsListeners(opt) {
    let events = [
      "preclick",
      "click",
      "zoomstart",
      "zoom",
      "zoomend",
      "movestart",
      "move",
      "moveend",
      "mousemove",
      "mouseout",
      "mouseover"
    ];
    if (opt && opt.include) {
      events = events.filter((x) => opt.include.includes(x));
    }
    events.forEach((x) => {
      this._mapEvents[x] = (data) => {
        if (this.runtimeParams.length) {
          const mapStatusEvents = this.mapState.filter(
            (y) => y.event.includes(x)
          );
          mapStatusEvents.forEach((mapStatusEvent) => {
            const value = mapStatusEvent.toString();
            this.runtimeParams.forEach((r) => {
              r.set(mapStatusEvent.name, value);
            });
          });
        }
        if (this._eventsStatus) {
          this.emitter.emit(x, data);
        }
      };
      const mapEvent = this._mapEvents[x];
      if (mapEvent) {
        this.mapAdapter.emitter.on(x, mapEvent);
      }
    });
  }
  _removeEventListeners(opt) {
    let events = Object.entries(this._mapEvents);
    if (opt && opt.include) {
      events = events.filter((x) => opt.include.includes(x[0]));
    }
    events.forEach(([x, event]) => {
      if (event) {
        this.mapAdapter.emitter.removeListener(x, event);
      }
    });
  }
};
__publicField$2(_WebMapMain, "keys", new Keys());
__publicField$2(_WebMapMain, "getPaintFunctions");
let WebMapMain = _WebMapMain;

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
class WebMapLayers extends WebMapMain {
  constructor(mapOptions) {
    super(mapOptions);
    __publicField$1(this, "_layersIdCounter", 1);
    __publicField$1(this, "_layersOrderCounter", 1);
    __publicField$1(this, "_baselayers", []);
    __publicField$1(this, "_layers", {});
    __publicField$1(this, "_selectedLayers", []);
    const tileJson = this.options.tileJson;
    if (tileJson) {
      this.emitter.once("build-map", () => this.addTileJsonLayer(tileJson));
    }
  }
  /**
   * Try to fit map view by given layer bounds.
   * But not all layers have borders
   */
  async fitLayer(layerDef, options) {
    const layer = this.getLayer(layerDef);
    const getBounds = layer && (layer.getBounds || layer.getExtent);
    if (getBounds) {
      const extent = await getBounds.call(layer);
      if (extent) {
        this.fitBounds(extent, options);
      }
    }
  }
  /**
   * Check if given layer is baselayer
   */
  isBaseLayer(layerDef) {
    const layer = this.getLayer(layerDef);
    if (layer && layer.id) {
      return this._baselayers.indexOf(layer.id) !== -1;
    }
    return void 0;
  }
  getBaseLayers() {
    const baselayers = [];
    this._baselayers.forEach((x) => {
      const baselayer = this._layers[x];
      if (baselayer) {
        baselayers.push(baselayer);
      }
    });
    return baselayers;
  }
  getBaseLayersIds() {
    return this._baselayers;
  }
  /**
   * Helper method to return added layer object by any definition type.
   */
  getLayer(layerDef) {
    if (typeof layerDef === "string") {
      return this._layers[layerDef];
    }
    return layerDef;
  }
  /**
   * Helper method to return added layer identificator by any definition type.
   */
  getLayerId(layerDef) {
    const layer = this.getLayer(layerDef);
    if (layer) {
      if (layer.id) {
        return layer == null ? void 0 : layer.id;
      }
      if (layer && layer.options) {
        return layer.options.id;
      }
    }
    throw new Error("No id for layer");
  }
  /**
   * Return array of all added layer identifications.
   */
  getLayers() {
    return Object.keys(this._layers);
  }
  // TODO: rename to getLayers, getLayers rename to getLayersIds
  allLayers() {
    return this._layers;
  }
  orderedLayers() {
    return Object.values(this._layers).sort(
      (a, b) => a.order && b.order ? a.order - b.order : 0
    );
  }
  findLayer(filter) {
    for (const l in this._layers) {
      const layerAdapter = this._layers[l];
      const isFit = filter(layerAdapter);
      if (isFit) {
        return layerAdapter;
      }
    }
  }
  /**
   * Check if the given layer on the map
   */
  isLayerVisible(layerDef) {
    const layer = this.getLayer(layerDef);
    return layer && layer.options.visibility !== void 0 ? layer.options.visibility : false;
  }
  /**
   * Shortcut method to create base layer
   */
  async addBaseLayer(adapter, options) {
    const layer = await this.addLayer(
      adapter,
      {
        ...options,
        baselayer: true
      },
      void 0
    );
    return layer;
  }
  /**
   * Registration of map layer.
   *
   * @param adapter - The name of layer adapter from [MapAdapter.layerAdapters](webmap#MapAdapter.layerAdapters).
   *                May be custom object or class implemented by [MainLayerAdapter](webmap#MainLayerAdapter).
   * @param options - Specific options for given adapter
   *
   * @example
   * ```javascript
   * webMap.addLayer('TILE', options).then((layer) => webMap.showLayer(layer));
   *
   * webMap.addLayer(CustomLayerAdapter, options);
   * ```
   */
  async addLayer(adapter, options = {}, order) {
    var _a, _b;
    const id = this._layersIdCounter++;
    const _order = utils.defined(order) ? order : options.order !== void 0 ? options.order : this.reserveOrder();
    let adapterEngine;
    if (typeof adapter === "string") {
      adapterEngine = this.getLayerAdapter(adapter);
    } else if (typeof adapter === "function") {
      adapterEngine = adapter;
    } else if ("then" in adapter) {
      adapterEngine = await adapter;
    }
    const geoJsonOptions = options;
    this._updateGeoJsonOptions(geoJsonOptions);
    options = {
      id: String(id),
      order: _order,
      ...options
    };
    const visibility = (_a = options.visibility) != null ? _a : true;
    options.visibility = false;
    if (options.baselayer) {
      options.order = 0;
    }
    if (this.options.onBeforeAddLayer) {
      const modified = this.options.onBeforeAddLayer({
        options,
        adapter: adapterEngine
      });
      if (modified) {
        if (modified.options) {
          options = modified.options;
        }
        if (modified.adapter) {
          adapterEngine = modified.adapter;
        }
      }
    }
    if (adapterEngine !== void 0) {
      const _adapter = new adapterEngine(this.mapAdapter.map, options);
      _adapter.options = { ...options, ..._adapter.options };
      if (_adapter.options.baselayer) {
        options.baselayer = true;
        options.order = 0;
        _adapter.options.order = 0;
      }
      let layerId;
      if (_adapter.options.id) {
        layerId = String(_adapter.options.id);
        this._layers[layerId] = _adapter;
      }
      this._emitLayerEvent("layer:preadd", layerId || "", _adapter);
      await this.onMapLoad();
      _adapter.map = this.mapAdapter.map;
      const layer = await _adapter.addLayer(_adapter.options);
      _adapter.layer = layer;
      _adapter.id = _adapter.options.id || String(id);
      _adapter.options.id = _adapter.id;
      if (options.baselayer) {
        _adapter.options.order = 0;
      }
      _adapter.order = (_b = _adapter.options.order) != null ? _b : _order;
      if (layerId) {
        delete this._layers[layerId];
      }
      layerId = String(_adapter.id);
      if (this._layers[layerId]) {
        throw Error(`layer with id '${layerId}' already exist`);
      }
      if (layerId) {
        this._layers[layerId] = _adapter;
        if (geoJsonOptions.filter) {
          this.filterLayer(_adapter, geoJsonOptions.filter);
        }
        if (options.baselayer) {
          this._baselayers.push(layerId);
        }
        if (visibility) {
          await this.showLayer(layerId);
        }
      }
      const opacity = options.opacity;
      if (opacity !== void 0 && opacity !== null && opacity <= 1) {
        this.setLayerOpacity(_adapter, opacity);
      }
      const getBounds = layer && (_adapter.getBounds || _adapter.getExtent);
      if (options.fit && getBounds) {
        const extent = await getBounds.call(_adapter);
        if (extent) {
          await this.fitBounds(extent);
        }
      }
      if (options.onAdded) {
        options.onAdded(_adapter);
      }
      this._emitLayerEvent("layer:add", layerId, _adapter);
      return _adapter;
    }
    return Promise.reject("No adapter");
  }
  async addLayerFromAsyncAdapter(adapter, options, order) {
    const _order = order || options.order !== void 0 ? options.order : this.reserveOrder();
    const adapterConstructor = adapter;
    const adapterConstructorPromise = adapterConstructor();
    const adapterEngine = await adapterConstructorPromise;
    if (adapterEngine) {
      return this.addLayer(adapterEngine, options, _order);
    }
    return Promise.reject("No adapter");
  }
  /**
   * Remove all layer from map and memory.
   */
  removeLayers(allowCb) {
    for (const l in this._layers) {
      let allow = true;
      if (allowCb) {
        allow = allowCb(l, this._layers[l]);
      }
      if (allow) {
        this.removeLayer(l);
        delete this._layers[l];
      }
    }
  }
  async getLegend(options) {
    const promises = [];
    for (const l of this.orderedLayers()) {
      if (l.getLegend) {
        promises.push(l.getLegend(options));
      }
    }
    return (await Promise.all(promises)).flat();
  }
  reserveOrder() {
    return this._layersOrderCounter++;
  }
  /**
   * Remove all layers but not remove basemap.
   */
  removeOverlays() {
    this.removeLayers((layerId, layer) => {
      if (layer && layer.options && layer.options.baselayer) {
        return false;
      }
      return true;
    });
  }
  /**
   * Remove specific layer from map and memory by its definition.
   */
  removeLayer(layerDef) {
    const layer = this.getLayer(layerDef);
    const layerId = layer && this.getLayerId(layer);
    if (layer && layerId) {
      this.emitter.emit("layer:preremove", layer);
      if (layer.beforeRemove) {
        layer.beforeRemove();
      }
      if (layer.removeLayer) {
        layer.removeLayer();
      } else {
        this.mapAdapter.removeLayer(layer.layer);
      }
      if (layer.options && layer.options.baselayer) {
        const index = this._baselayers.indexOf(layerId);
        if (index) {
          this._baselayers.splice(index, 1);
        }
      }
      delete this._layers[layerId];
      this.emitter.emit("layer:remove", layer);
    }
  }
  /**
   * Create layer from GeoJson data. Set style and behavior for selection.
   *
   * @example
   * ```javascript
   * // Add simple layer
   * webMap.addGeoJsonLayer({ data: geojson, paint: { color: 'red' } });
   *
   * // Add styled by feature property layer with selection behavior
   * webMap.addGeoJsonLayer({
   *   data: geojson,
   *   paint: function (feature) {
   *     return { color: feature.properties.color, opacity: 0.5 }
   *   },
   *  selectedPaint: function (feature) {
   *    return { color: feature.properties.selcolor, opacity: 1 }
   *  },
   *  selectable: true,
   *  multiselect: true
   * });
   *
   * // Add marker layer styled with use [Icons](icons)
   * webMap.addGeoJsonLayer({ data: geojson, paint: webMap.getIcon({ color: 'orange' })});
   *
   * // work with added layer
   * const layer = webMap.addGeoJsonLayer({ data: geojson, id: 'my_layer_name'});
   * // access layer by id
   * webMap.showLayer('my_layer_name');
   * // or access layer by instance
   * webMap.showLayer(layer);
   * ```
   */
  addGeoJsonLayer(opt = {}, adapter) {
    opt = opt || {};
    opt.multiselect = opt.multiselect !== void 0 ? opt.multiselect : false;
    opt.unselectOnSecondClick = opt.unselectOnSecondClick !== void 0 ? opt.unselectOnSecondClick : true;
    if (!adapter) {
      opt = updateGeoJsonAdapterOptions(opt);
    }
    opt.paint = opt.paint || {};
    return this.addLayer(adapter || "GEOJSON", opt);
  }
  /** Shortcut for {@link WebMapLayers.addGeoJsonLayer} to create GeoJson adapter with generic types for working in typescript */
  addFeatureLayer(options = {}) {
    return this.addGeoJsonLayer(options);
  }
  /** Shortcut for {@link WebMapLayers.addLayer} to create TileLayer adapter */
  addTileLayer(url, options = {}) {
    return this.addLayer("TILE", { ...options, url });
  }
  addImageLayer(urlOrOptions, options) {
    let url;
    if (typeof urlOrOptions === "string") {
      url = urlOrOptions;
    } else {
      url = urlOrOptions.url;
      options = urlOrOptions;
    }
    return this.addLayer("IMAGE", { ...options, url });
  }
  /**
   * Show added layer on the map by it definition.
   */
  showLayer(layerDef, options = {}) {
    return this.toggleLayer(layerDef, true, options);
  }
  /**
   * Hide added layer on the map by it definition.
   */
  hideLayer(layerDef, options = {}) {
    return this.toggleLayer(layerDef, false, options);
  }
  /**
   * Change added layer visibility on the map by given status or inverse current status.
   *
   * @example
   * ```javascript
   * webMap.addLayer('TILE', {id: 'my_layer', url: ''}).then((layer) => {
   *   webMap.toggleLayer(layer, true);
   *   webMap.toggleLayer('my_layer', false);
   *   webMap.toggleLayer('my_layer');
   *   webMap.isLayerVisible(layer); // true
   * });
   * ```
   */
  toggleLayer(layerDef, status, options = {}) {
    const layer = this.getLayer(layerDef);
    const onMap = layer && layer.options.visibility;
    const toStatus = status !== void 0 ? status : !onMap;
    const silent = options.silent !== void 0 ? options.silent : false;
    const action = async (l) => {
      const id = String(l.id);
      const preEventName = toStatus ? "layer:preshow" : "layer:prehide";
      const eventName = toStatus ? "layer:show" : "layer:hide";
      if (!silent) {
        this._emitLayerEvent(preEventName, id, l);
        this._emitLayerEvent("layer:pretoggle", id, l);
      }
      if (toStatus && this.mapAdapter) {
        const order = l.options.baselayer ? 0 : l.options.order;
        if (l.options.baselayer && this._baselayers.length) {
          const anotherVisibleBaselayers = this._baselayers.filter((x) => {
            return x !== l.id && this.isLayerVisible(x);
          });
          for (const bl of anotherVisibleBaselayers) {
            await this.hideLayer(bl);
          }
        }
        if (l.showLayer) {
          await l.showLayer.call(l, l.layer);
        } else if (l.layer !== void 0) {
          await this.mapAdapter.showLayer(l.layer);
        }
        if (order !== void 0) {
          this.mapAdapter.setLayerOrder(l.layer, order, this._layers);
        }
      } else {
        if (l.hideLayer) {
          await l.hideLayer.call(l, l.layer);
        } else if (l.layer !== void 0) {
          await this.mapAdapter.hideLayer(l.layer);
        }
      }
      l.options.visibility = toStatus;
      if (!silent) {
        this._emitLayerEvent(eventName, id, l);
        this._emitLayerEvent("layer:toggle", id, l);
      }
    };
    if (layer) {
      return this.onMapLoad().then(() => action(layer));
    }
    return Promise.resolve();
  }
  updateLayer(layerDef, options) {
    const layer = this.getLayer(layerDef);
    if (layer) {
      if (layer.updateLayer) {
        return Promise.resolve(layer.updateLayer(options));
      } else if (this.isLayerVisible(layer)) {
        return this.hideLayer(layer, { silent: true }).then(() => {
          return this.showLayer(layer, { silent: true });
        });
      }
    }
    return Promise.resolve();
  }
  /**
   * Set transparency for a given layer by number from 0 to 1
   */
  setLayerOpacity(layerDef, value) {
    const layer = this.getLayer(layerDef);
    if (layer) {
      if (layer.setOpacity) {
        layer.setOpacity(value);
      } else if (this.mapAdapter.setLayerOpacity) {
        this.mapAdapter.setLayerOpacity(layer.layer, value);
      }
    }
  }
  isLayerLabelVisible(layerDef) {
    var _a;
    const layer = this.getLayer(layerDef);
    if (layer.isLabelVisible) {
      return layer.isLabelVisible();
    }
    return (_a = layer.options.labelVisibility) != null ? _a : true;
  }
  showLayerLabel(layerDef) {
    this.toggleLayerLabel(layerDef, true);
  }
  hideLayerLabel(layerDef) {
    this.toggleLayerLabel(layerDef, false);
  }
  toggleLayerLabel(layerDef, status) {
    const layer = this.getLayer(layerDef);
    status = status != null ? status : !this.isLayerLabelVisible(layerDef);
    if (layer) {
      if (status) {
        if (layer.showLabel) {
          layer.options.labelVisibility = true;
          layer.showLabel();
        }
      } else {
        if (layer.hideLabel) {
          layer.options.labelVisibility = false;
          layer.hideLabel();
        }
      }
      if (layer.id) {
        this._emitLayerEvent("layer:label:toggle", layer.id, layer);
      }
    }
    return status;
  }
  /**
     * Mark the layer as selected.
     * If the adapter is a vector layer and supports data selection,
     * you can pass a callback function to specify which data will be selected.
     *
     * @example
     * ```javascript
     * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {
     *   webMap.selectLayer(layer, ({feature}) => feature.id === '42');
     * });
     * ```
  
     */
  selectLayer(layerDef, findFeatureFun) {
    const layer = this.getLayer(layerDef);
    if (layer) {
      const adapter = layer;
      if (adapter && adapter.select) {
        adapter.select(findFeatureFun);
      }
      const layerId = this.getLayerId(layer);
      if (layerId) {
        this._selectedLayers.push(layerId);
      }
    }
  }
  /**
   * Unselect the given layer.
   * If the adapter is a vector layer and supports data selection,
   * you can pass a callback function to specify which data will be unselected.
   *
   * @example
   * ```javascript
   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {
   *   webMap.unSelectLayer(layer, ({feature}) => feature.id === '42');
   * });
   * ```
   *
   */
  unSelectLayer(layerDef, findFeatureFun) {
    const layer = this.getLayer(layerDef);
    if (layer) {
      const adapter = layer && layer;
      if (adapter.unselect) {
        adapter.unselect(findFeatureFun);
      }
      const layerId = this.getLayerId(layer);
      if (layerId) {
        const index = this._selectedLayers.indexOf(layerId);
        if (index !== -1) {
          this._selectedLayers.splice(index, 1);
        }
      }
    }
  }
  /** Remove selection from any selected selectable layer */
  unSelectLayers() {
    const layers = Object.values(this.allLayers());
    let l;
    for (l of layers) {
      if (l.unselect) {
        l.unselect();
      }
    }
  }
  /**
   * Hide features from a vector layer using a callback function.
   *
   * @example
   * ```javascript
   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {
   *   webMap.filterLayer(layer, ({feature}) => feature.id === '42');
   * });
   * ```
   *
   */
  filterLayer(layerDef, filter) {
    const layer = this.getLayer(layerDef);
    const adapter = layer;
    if (adapter.filter) {
      return adapter.filter(filter);
    }
    return [];
  }
  propertiesFilter(layerDef, filters, options) {
    const layer = this.getLayer(layerDef);
    if (layer) {
      const adapter = layer;
      if (adapter.propertiesFilter) {
        return adapter.propertiesFilter(filters, options);
      } else if (adapter.filter) {
        this.filterLayer(adapter, (e) => {
          if (e.feature && e.feature.properties) {
            return propertiesFilter.propertiesFilter(e.feature.properties, filters);
          }
          return true;
        });
      }
    }
    return Promise.resolve();
  }
  removeLayerFilter(layerDef) {
    const layer = this.getLayer(layerDef);
    const adapter = layer;
    if (adapter.removeFilter) {
      adapter.removeFilter();
    } else if (adapter.filter) {
      adapter.filter(() => {
        return true;
      });
    }
  }
  /**
   * Sets the GeoJSON data for given vector layer.
   *
   * @example
   * ```javascript
   * const layer = webMap.addLayer('GEOJSON').then((layer) => {
   *   webMap.setLayerData(layer, geojson);
   * });
   * ```
   */
  setLayerData(layerDef, data) {
    const vectorAdapter = this.getLayer(layerDef);
    const adapter = vectorAdapter;
    if (adapter) {
      if (adapter.setData) {
        return adapter.setData(data);
      } else if (adapter.clearLayer && adapter.addData) {
        adapter.clearLayer();
        return adapter.addData(data);
      }
    }
    return Promise.resolve();
  }
  /**
   * Push new the GeoJSON features into given vector layer.
   *
   * @example
   * ```javascript
   * const layer = webMap.addLayer('GEOJSON', {data: geojson_features_5}).then((layer) => {
   *   console.log(layer.getLayers().length) // > 5;
   *   webMap.addLayerData(layer, geojson_features_3);
   *   console.log(layer.getLayers().length) // > 8;
   * });
   * ```
   */
  addLayerData(layerDef, data) {
    const layerMem = this.getLayer(layerDef);
    const adapter = layerMem;
    if (adapter.addData) {
      adapter.addData(data);
    }
  }
  /**
   * Remove from vector layer all features.
   * it is possible to remove only some objects if you specify a callback function.
   *
   * @example
   * ```javascript
   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {
   *   webMap.clearLayerData(layer, (feture) => feture.id === 42);
   *   webMap.clearLayerData(layer);
   * });
   * ```
   */
  clearLayerData(layerDef, cb) {
    const layerMem = this.getLayer(layerDef);
    const adapter = layerMem;
    if (adapter && adapter.clearLayer) {
      adapter.clearLayer(cb);
    }
  }
  setLayerPaint(layerDef, paint) {
    const layer = this.getLayer(layerDef);
    if (paint && layer && layer.setPaint) {
      layer.setPaint(paint);
    }
  }
  setLayerSelectedPaint(layerDef, paint) {
    const layer = this.getLayer(layerDef);
    if (paint && layer && layer.setSelectedPaint) {
      layer.setSelectedPaint(paint);
    }
  }
  updateLayerPaint(layerDef, paint) {
    const layer = this.getLayer(layerDef);
    if (paint && layer && layer.updatePaint) {
      layer.updatePaint(paint);
    }
  }
  updateLayerSelectedPaint(layerDef, paint) {
    const layer = this.getLayer(layerDef);
    if (paint && layer && layer.updateSelectedPaint) {
      layer.updateSelectedPaint(paint);
    }
  }
  getAttributions(options) {
    const attributions = [];
    for (const l in this._layers) {
      const layerCache = this._layers[l];
      const onlyVisible = options.onlyVisible !== void 0 ? options.onlyVisible : true;
      let useLayerAttr = onlyVisible ? layerCache.options.visibility : true;
      if (useLayerAttr && options.onlyBaselayer) {
        useLayerAttr = this._baselayers.includes(l);
      }
      if (useLayerAttr) {
        const attr = layerCache.options && layerCache.options.attribution;
        if (attr) {
          attributions.push(attr);
        }
      }
    }
    return attributions;
  }
  getActiveBaseLayer() {
    const visibleLayerBaseLayer = this.getBaseLayers().find((x) => {
      return this.isLayerVisible(x);
    });
    if (visibleLayerBaseLayer) {
      return this.getLayer(visibleLayerBaseLayer);
    }
  }
  addTileJsonLayer(tileJson) {
    const url = tileJson.tiles[0];
    return this.addLayer("TILE", {
      url,
      maxZoom: tileJson.maxzoom,
      minZoom: tileJson.minzoom,
      subdomains: tileJson.scheme,
      attribution: tileJson.attribution
    });
  }
  /** @internal */
  _emitLayerEvent(name, id, options) {
    const name_ = String(name);
    if (utils.defined(id) && name_.startsWith("layer:")) {
      const specificLayerName = name_.replace("layer:", "layer-" + id + ":");
      this.emitter.emit(specificLayerName, options);
    }
    this.emitter.emit(name, options);
  }
  async _onLayerClick(options) {
    const id = options.layer.id;
    this._emitLayerEvent("layer:click", id || "", options);
    return Promise.resolve(options);
  }
  async _onLayerDoubleClick(options) {
    const id = options.layer.id;
    this._emitLayerEvent("layer:dblclick", id || "", options);
    return Promise.resolve(options);
  }
  async _onLayerSelect(options) {
    this._emitLayerEvent("layer:select", options.layer.id || "", options);
    return Promise.resolve(options);
  }
  _updateGeoJsonOptions(options) {
    const {
      onSelect,
      onLayerSelect,
      onClick,
      onDoubleClick,
      onLayerClick,
      onMouseOut,
      onMouseOver
    } = options;
    const onLayerClickFromOpt = onClick || onLayerClick;
    const onLayerDblClickFromOpt = onDoubleClick || onLayerClick;
    options.onClick = (e) => {
      if (onLayerClickFromOpt) {
        onLayerClickFromOpt(e);
      }
      return this._onLayerClick(e);
    };
    options.onDoubleClick = (e) => {
      if (onLayerDblClickFromOpt) {
        onLayerDblClickFromOpt(e);
      }
      return this._onLayerDoubleClick(e);
    };
    options.onMouseOut = (e) => {
      const id = e.layer.id;
      if (onMouseOut) onMouseOut(e);
      if (utils.defined(id)) {
        this._emitLayerEvent(`layer:mouseout`, id, e);
      }
    };
    options.onMouseOver = (e) => {
      const id = e.layer.id;
      if (onMouseOver) onMouseOver(e);
      if (utils.defined(id)) {
        this._emitLayerEvent(`layer:mouseover`, id, e);
      }
    };
    const onLayerSelectFromOpt = onSelect || onLayerSelect;
    options.onSelect = (e) => {
      if (onLayerSelectFromOpt) {
        onLayerSelectFromOpt(e);
      }
      return this._onLayerSelect(e);
    };
    if (!options.nativePaint) {
      if (this.options.paint) {
        options.paint = paint.preparePaint({
          paint: options.paint || {},
          defaultPaint: this.options.paint,
          getPaintFunctions: this.getPaintFunctions
        });
      }
      if (options.selectedPaint && this.options.selectedPaint) {
        options.selectedPaint = paint.preparePaint({
          paint: options.selectedPaint,
          defaultPaint: this.options.selectedPaint,
          getPaintFunctions: this.getPaintFunctions
        });
      }
    }
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const _WebMapControls = class _WebMapControls extends WebMapLayers {
  constructor() {
    super(...arguments);
    __publicField(this, "_loadControlQueue", {
      "top-right": [],
      "bottom-right": [],
      "top-left": [],
      "bottom-left": []
    });
    __publicField(this, "_isControlLoading", {
      "top-right": false,
      "bottom-right": false,
      "top-left": false,
      "bottom-left": false
    });
  }
  async addControl(controlDef, position, options) {
    let control;
    position = position != null ? position : "top-left";
    if (typeof controlDef === "string") {
      control = this.getControl(controlDef, options);
    } else {
      control = controlDef;
    }
    if (control) {
      return new Promise((resolve) => {
        const promise = async () => {
          const _control = await control;
          const c = this.mapAdapter.addControl(_control, position);
          resolve(c);
        };
        this._setControlQueue(position, promise);
      });
    }
  }
  /**
   * Creating a universal map layout control element. Can be used with any map adapter.
   *
   * @example
   * ```javascript
   * const control = webMap.createControl({
   *   onAdd() {
   *     return document.createElement('div');
   *   }
   * });
   * ```
   */
  async createControl(control, options) {
    await this.onLoad("build-map");
    if (this.mapAdapter.createControl) {
      return this.mapAdapter.createControl(control, options);
    }
  }
  async createButtonControl(options) {
    await this.onLoad("build-map");
    if (this.mapAdapter.createButtonControl) {
      return this.mapAdapter.createButtonControl(options);
    }
  }
  /**
   * Create any toggler control button
   * @param options - Options for control layout customization and assigning a callback function
   *
   * @example
   * ```javascript
   * const toggleControl = ngwMap.createToggleControl({
   *   getStatus: () => webMap.isLayerVisible('any-layer-id'),
   *   onClick: (status) => ngwMap.toggleLayer('webmap', status),
   *   html: {
   *     on: 'ON',
   *     off: 'OFF'
   *   },
   *   title: 'Toggle layer visibility'
   * });
   * webMap.addControl(toggleControl, 'top-right');
   * ```
   * {@link http://code.nextgis.com/demo-examples-toggle-control | Toggle button control example}
   */
  async createToggleControl(options) {
    await this.onLoad("build-map");
    if (this.mapAdapter.createToggleControl) {
      return this.mapAdapter.createToggleControl(options);
    } else {
      if (this.mapAdapter.createButtonControl) {
        return createToggleControl(
          this.mapAdapter.createButtonControl,
          options
        );
      }
    }
  }
  /**
   *
   * @param control - Instance of WEB-GIS framework control.
   *                  What is returned by the {@link createControl | create} method
   */
  removeControl(control) {
    if ("remove" in control) {
      control.remove();
    } else if (this.mapAdapter.removeControl) {
      Promise.resolve(control).then((c) => {
        this.mapAdapter.removeControl(c);
      });
    }
  }
  /**
   * Get instance of registered control
   * @param control - Any registered control string name
   * @param options - Custom control options
   */
  getControl(control, options) {
    const engine = this.mapAdapter.controlAdapters[control];
    if (engine) {
      return new engine(options);
    } else {
      const createFun = _WebMapControls.controls[control];
      if (createFun) {
        return createFun(this, options);
      }
    }
  }
  getControlContainer() {
    if (this.mapAdapter.getControlContainer) {
      return this.mapAdapter.getControlContainer();
    }
  }
  _setControlQueue(position, cb) {
    this._loadControlQueue[position].push(cb);
    if (!this._isControlLoading[position]) {
      this._applyControls(position);
    }
  }
  async _applyControls(position) {
    if (this._loadControlQueue[position].length) {
      this._isControlLoading[position] = true;
      const controlCb = this._loadControlQueue[position][0];
      await controlCb();
      this._loadControlQueue[position].splice(0, 1);
      this._applyControls(position);
    } else {
      this._isControlLoading[position] = false;
    }
  }
};
__publicField(_WebMapControls, "controls", {
  CONTROL: (webMap, options) => {
    return webMap.createControl(options.control, options.options);
  },
  BUTTON: (webMap, options) => {
    return webMap.createButtonControl(options);
  },
  TOGGLE: (webMap, options) => {
    return webMap.createToggleControl(options);
  }
});
let WebMapControls = _WebMapControls;

class WebMap extends WebMapControls {
  constructor(mapOptions) {
    super(mapOptions);
    this._addControls();
    setWebMap(this.id, this);
  }
  static get(id) {
    return getWebMap(id);
  }
  /**
   * @internal
   */
  async _addLayerProviders() {
    for await (const kit of this._starterKits) {
      if (kit.getLayerAdapters) {
        const adapters = await kit.getLayerAdapters.call(kit);
        if (adapters) {
          for await (const adapter of adapters) {
            const newAdapter = await adapter.createAdapter(this);
            if (newAdapter) {
              this.mapAdapter.layerAdapters[adapter.name] = newAdapter;
            }
          }
        }
      }
    }
  }
  /**
   * @internal
   */
  async _onLoadSync() {
    for await (const kit of this._starterKits) {
      if (kit.onLoadSync) {
        try {
          await kit.onLoadSync.call(kit, this);
        } catch (er) {
          console.error(er);
        }
      }
    }
  }
  _addControls() {
    if (this.options.controls) {
      this.options.controls.forEach((x) => {
        let controlAdapterName = x;
        let controlOptions = {};
        if (typeof x === "string" && this.options.controlsOptions) {
          if (this.options.controlsOptions[x]) {
            controlOptions = this.options.controlsOptions[x];
            if (controlOptions.control !== void 0) {
              controlAdapterName = controlOptions.control;
            }
          }
        }
        const { position, ...options } = controlOptions;
        this.addControl(controlAdapterName, position || "top-left", options);
      });
    }
    this._emitStatusEvent("controls:create");
  }
}

function getDefaultControls() {
  return ["ZOOM", "ATTRIBUTION"];
}

async function createWebMap(options) {
  const webMap = new WebMap(options);
  return webMap.onLoad();
}

exports.WebMap = WebMap;
exports.WebMapControls = WebMapControls;
exports.WebMapLayers = WebMapLayers;
exports.WebMapMain = WebMapMain;
exports.createToggleControl = createToggleControl;
exports.createWebMap = createWebMap;
exports.detectGeometryType = detectGeometryType;
exports.findMostFrequentGeomType = findMostFrequentGeomType;
exports.getDefaultControls = getDefaultControls;
exports.getWebMap = getWebMap;
exports.paintTypeAlias = paintTypeAlias;
exports.setWebMap = setWebMap;
exports.typeAlias = typeAlias;
exports.updateGeoJsonAdapterOptions = updateGeoJsonAdapterOptions;
//# sourceMappingURL=webmap.cjs.js.map
