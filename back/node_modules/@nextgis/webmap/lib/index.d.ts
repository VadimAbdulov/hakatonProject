import { EventEmitter } from 'events';
import { GeometryPaint, Paint, GetPaintFunction } from '@nextgis/paint';
import { Type, TileJson, LngLatArray, LngLatBoundsArray, LatLng, ZoomLevel, FeatureProperties, ExtractFeatureProperties } from '@nextgis/utils';
import { Feature, GeoJsonObject, Geometry, Polygon } from 'geojson';
import StrictEventEmitter from 'strict-event-emitter-types';
import { PropertiesFilter } from '@nextgis/properties-filter';
import { LegendSymbol } from '@nextgisweb/render/type/api';
import { LegendSymbolsEnum } from '@nextgisweb/webmap/type/api';
import { ViewOptions as ViewOptions$1 } from '@nextgis/webmap';

declare class KeyCodes {
    'backspace': number;
    'tab': number;
    'enter': number;
    'shift': number;
    'ctrl': number;
    'alt': number;
    'pause/break': number;
    'caps_lock': number;
    'escape': number;
    'page_up': number;
    'page_down': number;
    'end': number;
    'home': number;
    'left_arrow': number;
    'up_arrow': number;
    'right_arrow': number;
    'down_arrow': number;
    'insert': number;
    'delete': number;
    'left_window_key': number;
    'right_window_key': number;
    'select_key': number;
    'numpad_0': number;
    'numpad_1': number;
    'numpad_2': number;
    'numpad_3': number;
    'numpad_4': number;
    'numpad_5': number;
    'numpad_6': number;
    'numpad_7': number;
    'numpad_8': number;
    'numpad_9': number;
    'multiply': number;
    'add': number;
    'subtract': number;
    'decimal_point': number;
    'divide': number;
    'f1': number;
    'f2': number;
    'f3': number;
    'f4': number;
    'f5': number;
    'f6': number;
    'f7': number;
    'f8': number;
    'f9': number;
    'f10': number;
    'f11': number;
    'f12': number;
    'num_lock': number;
    'scroll_lock': number;
    'semi-colon': number;
    'equal_sign': number;
    ',': number;
    '-': number;
    '.': number;
    '/': number;
    '`': number;
    '[': number;
    '\\': number;
    ']': number;
    "'": number;
}

declare class Keys {
    keyCodeAlias: KeyCodes;
    keys: {
        [keyCode: number]: boolean;
    };
    private _windowOnFocus;
    private _keysPressed;
    private _keysReleased;
    constructor();
    pressed(keyName: keyof KeyCodes): boolean;
    addKeyboardEventsListener(): void;
    removeKeyboardEventsListener(): void;
    private keysPressed;
    private keysReleased;
    private windowOnFocus;
}

/**
 * Represents a legend for a specific layer.
 */
interface LayerLegend {
    layerId: string;
    legend: LegendSymbol[];
    setSymbolRender?: (symbolIndex: number, status: boolean) => void;
    legendSymbols?: LegendSymbolsEnum;
}

/**
 * Screen coordinates in pixels.
 */
interface Pixel {
    top: number;
    left: number;
    right?: number;
    bottom?: number;
}
/**
 * Available argument types for methods with map layers identification.
 *
 * @example
 * ```javascript
 * webMap.addLayer('GEOJSON', { id: 'my_layer' }).then((layer) =>{
 *   webMap.addLayerData(layer, geojson);
 *   webMap.addLayerData('my_layer', geojson);
 * });
 * ```
 */
type LayerDef = string | LayerAdapter;
/**
 * Available cursor names from
 * {@link https://developer.mozilla.org/ru/docs/Web/CSS/cursor}
 */
type Cursor = '' | 'auto' | 'crosshair' | 'default' | 'e-resize' | 'grab' | 'help' | 'move' | 'n-resize' | 'ne-resize' | 'nw-resize' | 'pointer' | 'progress' | 's-resize' | 'se-resize' | 'sw-resize' | 'text' | 'w-resize' | 'wait' | 'inherit';

type OnClickSync = () => void;
type onClickAsync = () => Promise<void>;
type OnToggleClickSync = (status: boolean) => void;
type onToggleClickAsync = (status: boolean) => Promise<void>;
type OnClick = OnClickSync | onClickAsync;
type OnToggleClick = OnToggleClickSync | onToggleClickAsync;
interface ZoomControlOptions {
    /** The text set on the 'zoom in' button. */
    zoomInText?: string;
    /** The title set on the 'zoom in' button. */
    zoomInTitle?: string;
    /** The text set on the 'zoom out' button. */
    zoomOutText?: string;
    /** The title set on the 'zoom out' button. */
    zoomOutTitle?: string;
}
interface AttributionControlOptions {
    /**
     * If true force a compact attribution that shows the full attribution on mouse hover,
     * or if  false force the full attribution control.
     */
    compact?: boolean;
    /**
     * String or strings to show in addition to any other attributions.
     */
    customAttribution?: string | string[];
}
interface MapControls extends ContribControlsOptions {
    [name: string]: Record<string, any>;
}
interface ContribControlsOptions {
    ZOOM: ZoomControlOptions;
    ATTRIBUTION: AttributionControlOptions;
}
interface ControlOptions {
    position?: ControlPosition;
    control?: string;
}
type ControlsOptions<O extends MapControls = MapControls, K extends keyof O = keyof O> = {
    [control in K]: O[K];
};
interface MapControl<M = any> {
    onAdd(map?: M): HTMLElement | undefined;
    onRemove(map?: M): unknown;
    getContainer?(): HTMLElement;
    remove?(): void;
}
/**
 * Options for creating a {@link WebMapControls.createButtonControl | button control}.
 */
interface ButtonControlOptions {
    /** Button content. */
    html?: string | HTMLElement;
    /** Additional css class string */
    addClass?: string;
    /** Set an action to execute when button clicked. */
    onClick: OnClick;
    /** Button HTMLElement title */
    title?: string;
}
type HtmlDef = string | HTMLElement;
/**
 * Values to be in the button content in accordance with the status of the toggle control
 */
interface HtmlToggle {
    on: HtmlDef;
    off: HtmlDef;
}
/**
 * Values to be in the title in accordance with the status of the toggle control
 */
interface TitleToggle {
    on: string;
    off: string;
}
/**
 * Options for creating a {@link WebMapControls.createToggleControl | toggle control}
 * to layout customization and assigning a callback function
 */
interface ToggleControlOptions {
    /** Boolean state of control. */
    status?: boolean;
    /** Button content, can be set for each state (`on` or `off`). */
    html?: HtmlDef | HtmlToggle;
    /** Additional css class string */
    addClass?: string;
    /** Additional css class string for `on` state only. */
    addClassOn?: string;
    /** Additional css class string for `off` state only. */
    addClassOff?: string;
    /** Button HTMLElement title, can be set for each state (`on` or `off`). */
    title?: string | TitleToggle;
    /** Set an action to execute when button clicked. */
    onClick?: OnToggleClick;
    /** Get current control status. */
    getStatus?: () => boolean;
}
interface CreateControlOptions {
    bar?: boolean;
    margin?: boolean;
    addClass?: string;
}
interface ToggleControl {
    onClick: OnClick;
    changeStatus: OnClickSync;
}

type Params = Record<string, any>;
interface RuntimeParams<P extends Params = Params, K = keyof P> {
    params(): P;
    get(name: K): any;
    set(name: K, value: any): void;
    remove(name: K): void;
}

interface LayerAdapterCreators {
    name: string;
    createAdapter: (webMap: WebMap) => Promise<Type<LayerAdapter>>;
}
interface StarterKit {
    onLoadSync?(webMap: WebMap): Promise<any>;
    getSettings?(webMap?: WebMap): Promise<MapOptions>;
    getLayerAdapters?(): Promise<LayerAdapterCreators[]>;
    onMapClick?(evt: MapClickEvent, webMap?: WebMap): void;
}

interface MapOptions<M = any, C = any> extends ViewOptions {
    /**
     * The main initialization property of WebMap.
     * Determines the way of interaction with the selected GIS framework.
     * Available: [Leaflet](leaflet-map-adapter); [Openlayers](ol-map-adapter); [MaplibreGL](maplibre-gl-map-adapter)
     */
    mapAdapter?: MapAdapter<M>;
    /**
     * A pre-initialized instance of the map
     */
    map?: M;
    /**
     * One way to extend WebMap functionality with the help of kits.
     */
    starterKits?: StarterKit[];
    /**
     * A way to save the state of a map to external services
     *
     * @example
     * ```javascript
     * import RuntimeParams from '@nextgis/url-runtime-params';
     * // this will allow to write in the url params of map center and zoomlevel when moving
     * new WebMap({
     *   mapAdapter: new MapAdapter(),
     *   runtimeParams: [new RuntimeParams]
     * })
     * ```
     */
    runtimeParams?: RuntimeParams[];
    /**
     * Аutomatic creation of a map from the constructor
     * @defaultValue false
     *
     * @example
     * ```javascript
     * const webMap = new WebMap(options);
     * // create: false
     * webMap.create().then(() => doSomething());
     * // create: true
     * webMap.emitter.on('created', () => doSomething());
     * ```
     */
    create?: boolean;
    /**
     * The HTML element in which NgwMap will render the map,
     * or the element's string  id.
     * The specified element must have no children.
     */
    target?: string | HTMLElement;
    /**
     * options to specify the initial position of the map
     */
    fitOptions?: FitOptions;
    view?: '2D' | '3D' | '2.5D';
    /**
     * special settings for the selected map adapter
     */
    mapAdapterOptions?: Record<string, any>;
    paint?: GeometryPaint;
    selectedPaint?: GeometryPaint;
    /**
     * The callback function is calling before adding each layer
     */
    onBeforeAddLayer?: OnBeforeLayerAdd;
    /**
     * List of controls that will be initialized when creating a map instance.
     * It can be defined as a string, then points to the corresponding entry in the
     * [controlAdapters](webmap-api#MapAdapter).
     *
     * @defaultValue ['ZOOM', 'ATTRIBUTION']
     *
     * @example
     * ```javascript
     * {
     *   controls: [
     *     'ZOOM',
     *     new CustomControl()
     *   ]
     * }
     * ```
     */
    controls?: Array<keyof MapControls | C>;
    /**
     * Set options for those controls that are specified by name.
     *
     * @example
     * ```javascript
     * {
     *   controls: ['ZOOM', 'button1', 'button2'],
     *   controlsOptions: {
     *     'ZOOM': { position: 'top-right' },
     *     'button1': { control: 'BUTTON', position: 'top-left' },
     *     'button2': { control: 'BUTTON' },
     *   }
     * }
     * ```
     */
    controlsOptions?: ControlsOptions;
    tileJson?: TileJson;
}
type OnBeforeLayerAdd = (e: {
    adapter?: Type<LayerAdapter>;
    options: AdapterOptions & Record<string, any>;
}) => {
    adapter?: Type<LayerAdapter>;
    options?: AdapterOptions;
} | undefined;
interface ToggleLayerOptions {
    silent?: boolean;
}
interface GetAttributionsOptions {
    onlyVisible?: boolean;
    onlyBaselayer?: boolean;
}
interface ViewOptions {
    /**
     * The minimum zoom level of the map (0-24).
     */
    minZoom?: number;
    /**
     * The maximum zoom level of the map (0-24).
     */
    maxZoom?: number;
    /**
     * The initial zoom level of the map (0-24).
     */
    zoom?: number;
    /**
     * Initial position of the map, array of two degrees [longitude, latitude].
     * [LngLatArray](webmap-api#LngLatArray)
     */
    center?: LngLatArray;
    /**
     * Initial extent of the map, array of degrees in [_west_, _south_, _east_, _north_] order.
     *
     * @remarks
     * Overrides the `center` and  `zoom` parameters.
     * [LngLatBoundsArray](webmap#LngLatBoundsArray)
     *
     * @example
     * ```javascript
     * // whole world
     * bounds: [0, -90, 180, 90]
     * ```
     */
    bounds?: LngLatBoundsArray;
    maxBounds?: LngLatBoundsArray | null;
}

/**
 * Parameters passed to the arguments of the callback function when clicking on the map
 */
interface MapClickEvent {
    /**
     * The geographical point where the mouse event occurred.
     */
    lngLat: LngLatArray;
    /**
     * Pixel coordinates of the point where the mouse event occurred relative to the map container.
     */
    pixel: Pixel;
    /**
     * Map adapter original click event
     */
    source?: unknown;
    /**
     * The geographical point where the mouse event occurred.
     * @deprecated use `lngLat: number[]` instead
     */
    latLng?: LatLng;
}
/**
 * Parameters that control how the fit to object will be work.
 */
interface FitOptions {
    /**
     * The maximum possible zoom to use.
     */
    maxZoom?: number;
    offset?: [number, number];
    padding?: number;
    duration?: number;
}
/**
 * @deprecated use ControlPosition instead
 */
type ControlPositions = ControlPosition;
type ControlPosition = 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
interface Locate {
    stop: () => void;
}
interface LocationEvent {
    lngLat: LngLatArray;
    bounds?: LngLatBoundsArray;
}
interface LocateOptions {
    setView?: boolean;
    maxZoom?: ZoomLevel;
}
interface DataLoadError {
    target: string;
}
interface LocationEvents {
    locationfound: (e: LocationEvent) => void;
    locationerror?: () => void;
}
/**
 * Parameters and methods that control the behavior of the map and the layers on it.
 * @typeParam M - WEB-GIS framework map interface
 * @typeParam L - WEB-GIS framework layer interface
 * @typeParam C - WEB-GIS framework control interface
 */
interface MapAdapter<M = any, L = any, C = any> {
    /**
     * State of readiness of the card for use.
     * @defaultValue true
     */
    isLoaded?: boolean;
    /**
     * Original map object of GIS framework (Leaflet.Map, Openlayers.Map, MaplibreGL.Map or other)
     */
    map?: M;
    /**
     * An instance of the EventEmitter class for listen and emit events
     */
    readonly emitter: StrictEventEmitter<EventEmitter, MapAdapterEvents>;
    /**
     * Named adapters for map layers through a generic interface.
     */
    layerAdapters: {
        [name: string]: Type<LayerAdapter<M, L, any>>;
    };
    /**
     * Named map controls specific for each framework.
     */
    controlAdapters: {
        [name: string]: Type<C>;
    };
    create(options?: MapOptions): void;
    destroy(): void;
    /**
     * Remove layer from Map
     */
    removeLayer(layer: L): any;
    beforeRemove?(): void;
    /**
     * Set the transparency of given layer.
     */
    setLayerOpacity(layer: L, opacity: number): void;
    showLayer(layer: L): void;
    hideLayer(layer: L): void;
    setLayerOrder(layer: L, order: number, layers?: {
        [name: string]: LayerAdapter;
    }): void;
    /** @deprecated use fitBounds instead */
    fit?(extent: LngLatBoundsArray, options?: FitOptions): void;
    fitBounds(extent: LngLatBoundsArray, options?: FitOptions): void;
    setView?(lngLat: LngLatArray, zoom?: number): void;
    setView?(viewOptions: ViewOptions$1): void;
    getBounds?(): LngLatBoundsArray | undefined;
    getZoom(): number | undefined;
    /**
     * Temporal async method.
     * @remarks
     * TODO: need to replace all 'get' methods with asynchronous
     */
    fetchZoom?(): Promise<number | undefined>;
    setZoom(zoom: number): void;
    /** zoom the map by one quantile of the current adapter */
    zoomIn?(): void;
    /** zoom out the map by one quantile of the current adapter */
    zoomOut?(): void;
    getCenter(): LngLatArray | undefined;
    setCenter(latLng: LngLatArray): void;
    getContainer(): HTMLElement | undefined;
    getControlContainer?(): HTMLElement;
    setCursor?(cursor: string): void;
    getCursor?(): string | undefined;
    createControl?(control: MapControl, options?: CreateControlOptions): C;
    createButtonControl?(options: ButtonControlOptions): C;
    createToggleControl?(options: ToggleControlOptions): C;
    addControl<K extends keyof MapControls>(controlName: K | any, position: ControlPosition, options?: MapControls[K]): any;
    removeControl(control: any): void;
    onMapClick(evt: any): void;
    /**
     * Tries to locate the user using the Geolocation API,
     * firing a locationfound event with location data on success
     * or a locationerror event on failure,
     * and optionally sets the map view to the user's location with
     * respect to detection accuracy (or to the world view if geolocation failed).
     * Note that, if your page doesn't use HTTPS, this method will fail in modern browsers (Chrome 50 and newer)
     * See Locate options for more details.
     */
    locate?(opt: LocateOptions, events?: LocationEvents): Locate;
}

type AdapterConstructor = () => Promise<Type<LayerAdapter> | any>;
type LayerAdapterDefinition<K extends keyof LayerAdapters = string> = K | Type<LayerAdapters[K]> | Promise<Type<LayerAdapters[K]> | undefined>;
type OnLayerSelectType = 'api' | 'click' | 'hover';
interface OnLayerSelectOptions<F extends Feature = Feature, L = LayerAdapter> extends FeaturePosition {
    layer: L;
    features?: F[] | undefined;
    type: OnLayerSelectType;
}
/** @deprecated use {@link OnLayerMouseOptions} instead */
type OnLayerClickOptions<F extends Feature = Feature, L = LayerAdapter> = OnLayerMouseOptions<F, L>;
interface OnLayerMouseOptions<F extends Feature = Feature, L = LayerAdapter> extends FeaturePosition {
    layer: L;
    event: MapClickEvent;
    source: any;
    feature?: F;
    selected?: boolean;
}
/**
 * Parameters that can be used to create any map layer adapter.
 */
interface AdapterOptions<ANYPROPS extends Record<string, any> = Record<string, any>, NATIVE extends Record<string, any> = Record<string, any>> {
    /**
     * Unique Layer ID.
     * If not specified, will be added automatically.
     *
     * @remarks
     * If the layer adapter is asynchronous, its id will be assigned only after the promise is resolved.
     * While adapter is loading, methods for obtaining layers will ignore the added layer.
     */
    id?: string;
    /**
     * Show layer on the map immediately after adding.
     * Such layers are always under others.
     * Only one base layer can be displayed on the map at a time.
     * @remarks
     * TODO: replace by show
     *
     * @defaultValue true
     */
    visibility?: boolean;
    /**
     * Indicate on a cartographic base layer.
     */
    baselayer?: boolean;
    /**
     * Indicates the map layers display sequence.
     * A layer with a larger order value overlaps smaller ones.
     * Zero value used to indicate baselayer.
     * If the value is not specified explicitly, it will be assigned automatically with an increase of one for each new layer.
     */
    order?: number;
    /**
     * String to be shown in the attribution control.
     * It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
     */
    attribution?: string;
    /**
     * Maximum zoom level of the map.
     */
    maxZoom?: number;
    /**
     * Minimum zoom level of the map.
     */
    minZoom?: number;
    /**
     * TODO: replace by minZoom
     * @deprecated use minZoom instead
     */
    minScale?: number;
    /**
     * TODO: replace by maxZoom
     * @deprecated use maxZoom instead
     */
    maxScale?: number;
    /**
     * Layer transparency.
     * From 0-transparent to 1-visible
     * @defaultValue 1
     */
    opacity?: number | null;
    /**
     * Fit map to layer extent
     * @defaultValue false
     */
    fit?: boolean;
    /**
     * Non-unique name of the layer. Can be used for user interfaces.
     */
    name?: string;
    adapter?: string;
    /**
     * Wait until the layer data is fully loaded before allowing added to the map.
     *
     * @remarks
     * If true, addLayer promise resolve only after data loading.
     * This is useful for GeoJson vector layer adapters when you need to process downloaded data before displaying.
     */
    waitFullLoad?: boolean;
    /**
     * Parameter added when forming a request for layer data.
     * This is needed if you want to access tile pixel data.
     * Refer to {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin | CORS Settings} for valid String values.
     */
    crossOrigin?: 'anonymous';
    headers?: Record<string, any>;
    withCredentials?: boolean;
    /**
     * Experimental option to set the map loading delay when changing position
     */
    setViewDelay?: number;
    /** Any properties to save in layer.
     * May be useful to get additional info from layer event.
     */
    props?: ANYPROPS;
    /**
     * Map and layer adapter base options
     * Use with care.
     * There may be a conflict in the addLayer method by the adapter of the NextGIS Frontend library
     */
    nativeOptions?: NATIVE;
    ratio?: number;
    /** Experimental only for Ol yet */
    srs?: number;
    onAdded?: (layer: LayerAdapter) => void;
    /** Type for geometries painting, for each layer may be only one of: `point`, `polygon` or `line`. */
    type?: VectorAdapterLayerType;
    layers?: string;
}
interface MvtAdapterOptions<F extends Feature = Feature> extends VectorAdapterOptions<F> {
    url: string;
    sourceLayer?: string;
}
type VectorAdapterLayerType = 'polygon' | 'point' | 'line';
type PopupOnCloseFunction = (args: LayerDefinition) => void;
interface CreatePopupContentProps<F extends Feature = Feature, L = any> extends LayerDefinition<F, L> {
    /**
     * The source of the event call. User `click`, `hover`, or programmatic `api` call
     */
    type: OnLayerSelectType;
    /**
     * Close the pop-up programmatically
     */
    close: () => void;
    /**
     * The callback function that is called when the popup is closed
     *
     * @example
     * ```javascript
     * createPopupContent: (e) => {
     *   const onZoomEnd = () => e.close();
     *   ngwMap.emitter.on('zoomend', onZoomEnd)
     *   e.onClose(() => {
     *     ngwMap.emitter.off('zoomend', onZoomEnd)
     *   })
     *   return createContentFunc(e);
     * },
     * ```
     */
    onClose: (cb: PopupOnCloseFunction) => void;
}
type CreatePopupContent<F extends Feature = Feature, L = any> = (props: CreatePopupContentProps<F, L>) => HTMLElement | string | undefined | Promise<HTMLElement | string | undefined>;
interface PopupOptions<F extends Feature = Feature, L = any> {
    minWidth?: number;
    maxWidth?: number;
    autoPan?: boolean;
    popupContent?: string | HTMLElement;
    fromProperties?: boolean;
    closeButton?: boolean;
    /** Unselect feature on popup close
     * @defaultValue true
     */
    unselectOnClose?: boolean;
    createPopupContent?: CreatePopupContent<F, L>;
}
type _VectorAdapterOptionsToExtend<P extends Record<string, any> = Record<string, any>, A extends Record<string, any> = Record<string, any>, N extends Record<string, any> = Record<string, any>> = AdapterOptions<A, N> & FilterOptions<P>;
interface VectorAdapterOptions<F extends Feature = Feature, L = any, A extends FeatureProperties = Record<string, any>, N extends FeatureProperties = Record<string, any>, P extends FeatureProperties = ExtractFeatureProperties<F>> extends _VectorAdapterOptionsToExtend<P, A, N> {
    /**
     * Determine the appearance of the vector data geometries.
     *
     * @example
     * ```javascript
     * const circlePaint = { paint: { color: 'green', radius: 6 } };
     * const paintCb = (feature) => {
     *  return { color: 'red', opacity: feature.properties.opacity }
     * }
     * ```
     * @example
     * ```javascript
     * // Use global paint function
     * // set paint function inside WebMap static property
     * WebMap.getPaintFunctions.customPaintFunction = customIconPaintFunction
     *
     * webMap.addLayer('GEOJSON', {
     *   paint: {
     *     type: 'get-paint',
     *     from: 'customPaintFunction',
     *     options: {}
     *   }
     * }
     * ```
     */
    paint?: Paint<F>;
    /**
     * The paint that applies to the features after it becomes selected.
     *
     * @example
     * ```javascript
     * webMap.addLayer('GEOJSON', {
     *   paint: { color: 'red' },
     *   selectedPaint: { color: 'green' }
     * });
     * ```
     */
    selectedPaint?: Paint<F>;
    /**
     * Determines whether objects are selected by mouse click.
     *
     * @example
     * ```javascript
     * const layer = webMap.addLayer('GEOJSON', {
     *   paint: { color: 'red' },
     *   selectedPaint: { color: 'green' },
     *   selectable: false
     * });
     * // programmatically selection - ok, but not on mouse click
     * layer.select(({ feature }) => feature.properties.id === ID_FOR_SELECT);
     * ```
     */
    selectable?: boolean;
    interactive?: boolean;
    /**
     * Indicates whether several objects can be selected in one layer.
     *
     * @example
     * ```javascript
     * // multiselect: false
     * layer.select(({ feature }) => feature.properties.color === 'green'); // one feature will be selected
     * // multiselect: true
     * layer.select(({ feature }) => feature.properties.color === 'green'); // all 'green' features will be selected
     * ```
     */
    multiselect?: boolean;
    /**
     * Deselects layer feature by second click.
     */
    unselectOnSecondClick?: boolean;
    /**
     * If false, the selection will be reset when the user clicks the map.
     * @defaultValue true
     */
    unselectOnClick?: boolean;
    /**
     * Make the feature selected while mouseover.
     */
    selectOnHover?: boolean;
    popup?: boolean;
    popupOnSelect?: boolean;
    popupOnHover?: boolean;
    popupOptions?: PopupOptions<F, L>;
    filter?: DataLayerFilter<F, L>;
    propertiesFilter?: PropertiesFilter<P>;
    featureIdName?: string;
    cluster?: boolean;
    /**
     * Max zoom to cluster points on
     */
    clusterMaxZoom?: number;
    /**
     * Radius of each cluster when clustering points
     * @defaultValue 50
     */
    clusterRadius?: number;
    label?: (e: LayerDefinition<F, L>) => string;
    labelField?: keyof P extends null ? string : keyof P;
    labelOnHover?: boolean;
    /**
     * Show set label immediately
     * @defaultValue false
     */
    labelVisibility?: boolean;
    source?: unknown;
    /**
     * @deprecated - TODO: move to nativeOptions
     */
    nativePaint?: boolean | Record<string, any>;
    /**
     * @deprecated - TODO: move to nativeOptions
     */
    nativeFilter?: unknown;
    /**
     * @deprecated - TODO: move to nativeOptions
     */
    layout?: any;
    /**
     * @deprecated - TODO: move to nativeOptions
     */
    selectedLayout?: any;
    heightOffset?: number;
    onClick?(opt: OnLayerMouseOptions<F, L>): void;
    onDoubleClick?(opt: OnLayerMouseOptions<F, L>): void;
    onSelect?(opt: OnLayerSelectOptions<F, L>): void;
    /** Fired when the mouse enters the layer. */
    onMouseOver?(opt: OnLayerMouseOptions<F, L>): void;
    /** Fired when the mouse leaves the layer. */
    onMouseOut?(opt: Omit<OnLayerMouseOptions<F, L>, keyof FeaturePosition>): void;
    /** @deprecated use {@link VectorAdapterOptions.onClick} instead */
    onLayerClick?(opt: OnLayerMouseOptions<F, L>): Promise<any>;
    /** @deprecated use {@link VectorAdapterOptions.onSelect} instead */
    onLayerSelect?(opt: OnLayerSelectOptions<F, L>): Promise<any>;
}
interface GeoJsonAdapterOptions<F extends Feature = Feature, L = any, A extends FeatureProperties = Record<string, any>, N extends FeatureProperties = Record<string, any>> extends VectorAdapterOptions<F, L, A, N> {
    /** Geojson data */
    data?: GeoJsonObject;
}
interface RasterAdapterOptions extends AdapterOptions {
    url: string;
    subdomains?: string | string[];
}
interface TileAdapterOptions extends RasterAdapterOptions {
    tileSize?: number;
}
interface Tileset3DAdapterOptions extends RasterAdapterOptions, VectorAdapterOptions {
    useTerrainHeight?: boolean;
    heightOffset?: number;
}
interface Model3DOptions extends RasterAdapterOptions {
    lon: number;
    lat: number;
    height?: number;
    rotate?: number;
    scale?: number;
}
interface WmsAdapterOptions extends RasterAdapterOptions {
    format?: 'image/png' | 'image/jpeg' | string;
    version?: string;
    tileSize?: number;
    updateWmsParams?: (obj: {
        [paramName: string]: any;
    }) => Record<string, string>;
    transparent?: boolean;
}
interface ImageAdapterOptions extends WmsAdapterOptions {
    /** @deprecated use `params` option instead */
    resourceId?: string | number;
    params: Record<string, any>;
}
interface LayerAdapters {
    [name: string]: MainLayerAdapter;
    MVT: VectorLayerAdapter;
    COG: MainLayerAdapter<any, any, RasterAdapterOptions>;
    IMAGE: MainLayerAdapter<any, any, ImageAdapterOptions>;
    WMS: MainLayerAdapter<any, any, WmsAdapterOptions>;
    OSM: MainLayerAdapter;
    TILE: MainLayerAdapter<any, any, TileAdapterOptions>;
    GEOJSON: VectorLayerAdapter<any, any, GeoJsonAdapterOptions>;
}
interface LayerAdaptersOptions {
    [name: string]: AdapterOptions;
    MVT: MvtAdapterOptions;
    IMAGE: ImageAdapterOptions;
    WMS: WmsAdapterOptions;
    OSM: RasterAdapterOptions;
    TILE: TileAdapterOptions;
    GEOJSON: GeoJsonAdapterOptions;
    COG: RasterAdapterOptions;
}
interface FeaturePosition {
    /** Get the extent for the geometry on which the action was executed. */
    getBounds: () => LngLatBoundsArray;
    /** Get the center for the geometry on which the action was executed. */
    getCenter: () => LngLatArray;
}
interface LayerDefinition<F extends Feature = Feature, L = any> extends FeaturePosition {
    /** The adapter in which the layer is created. */
    target: LayerAdapter;
    /** A vector layer object in geojson format. */
    feature: F;
    /** Native layer for a specific adapter layers of a specific map adapter. */
    layer?: L;
    /** Is layer on the map */
    visible?: boolean;
}
type CallbackFilter<F extends Feature = Feature, L = any> = (opt: LayerDefinition<F, L>) => boolean;
interface FilterOptions<P extends {
    [field: string]: any;
} = {
    [field: string]: any;
}> {
    /**
     * Offset (paginated) where from entities should be taken.
     */
    offset?: number;
    /**
     * Limit (paginated) - max number of entities should be taken.
     */
    limit?: number;
    fields?: (keyof P)[] | false | null;
    /** WKT polygon geometry */
    intersects?: string | LngLatArray[] | LngLatBoundsArray;
    strategy?: 'BBOX' | 'BBOX+';
    /**
     * set fields for order
     *
     * @remarks
     * TODO: use typescript 4.1 template string type for map -`${field}`
     *
     * @example
     * ```javascript
     * { "orderBy": ["field1", "-field2"] }
     * ```
     */
    orderBy?: (keyof P | string)[];
}
type DataLayerFilter<F extends Feature = Feature, L = any> = CallbackFilter<F, L>;
type LayerAdapter<M = any, L = any, O extends AdapterOptions = AdapterOptions> = MainLayerAdapter<M, L, O> | VectorLayerAdapter<M, L, O>;
interface GetLegendOptions {
    signal?: AbortSignal | null;
    cache?: boolean;
}
interface UpdateLayerAdapterOptions {
    params?: Record<string, string | undefined>;
    filters?: PropertiesFilter;
    options?: FilterOptions;
}
interface MainLayerAdapter<M = any, L = any, O extends AdapterOptions = AdapterOptions> {
    options: O;
    order?: number;
    id?: string;
    name?: string;
    layer?: L;
    map?: M;
    addLayer(options: O): L | Promise<L> | undefined;
    updateLayer?(options?: UpdateLayerAdapterOptions): void;
    removeLayer?(): void;
    beforeRemove?(): void;
    showLayer?(layer?: L): void;
    hideLayer?(layer?: L): void;
    /** @deprecated use {@link getBounds} instead */
    getExtent?(): LngLatBoundsArray | Promise<LngLatBoundsArray | undefined> | undefined;
    getBounds?(): LngLatBoundsArray | Promise<LngLatBoundsArray | undefined> | undefined;
    getDependLayers?(): L[];
    setPaint?(paint: Paint): void;
    updatePaint?(paint: Partial<Paint>): void;
    setSelectedPaint?(paint: Paint): void;
    updateSelectedPaint?(paint: Partial<Paint>): void;
    setOpacity?(val: number): void;
    getLegend?(options?: GetLegendOptions): Promise<LayerLegend[]>;
}
/**
 * Generic shortcut to define VectorLayerAdapter from feature
 */
type FeatureLayerAdapter<P extends FeatureProperties = FeatureProperties, G extends Geometry = Geometry, O extends VectorAdapterOptions = VectorAdapterOptions, M = any, L = any> = VectorLayerAdapter<M, L, O, Feature<G, P>>;
/**
 * Adapter for vector data display control.
 */
interface VectorLayerAdapter<M = any, L = any, O extends VectorAdapterOptions = VectorAdapterOptions, F extends Feature = Feature, PROP extends Record<string, any> | null = F extends Feature ? F['properties'] : Record<string, string>, P extends Record<string, any> = PROP extends null ? Record<string, any> : PROP> extends MainLayerAdapter<M, L, O> {
    /** True if there are selected features in the layer  */
    selected?: boolean;
    /**
     * Experimental option, only for MVT. Points to a data source instead of loading data into a layer.
     */
    source?: unknown;
    /**
     * Allows to get all vector objects of the layer. Does not work for vector tiles.
     */
    getLayers?(): LayerDefinition<F, L>[];
    /**
     * Method for selecting objects on the map. The `selectedPaint` option will be applied to the selected objects.
     * @remarks
     * It is strongly recommended to use an `PtropertiesFilter` expression to set selected objects,
     * since the selecting by the callback function is not supported by vector tiles and other asynchronous adapters.
     */
    select?(findFeatureCb?: DataLayerFilter<F, L> | PropertiesFilter): void;
    /**
     * Deselect all objects in the vector layer.
     *
     * @remarks
     * The parameter `findFeatureCb` is deprecated and will be deleted soon.
     * Instead, it’s better to deselect all and select again.
     */
    unselect?(findFeatureCb?: DataLayerFilter<F, L> | PropertiesFilter): void;
    /**
     * Get the selected objects of the vector layer.
     */
    getSelected?(): LayerDefinition<Feature, L>[];
    /**
     * Get the filtered objects of the vector layer.
     */
    getFiltered?(): LayerDefinition<Feature, L>[];
    /**
     * Ability to filter a layer with a callback function.
     * It is necessary for the adapter to provide access to the layer objects before output to the map.
     * It is not possible to apply such a filter to vector tiles and data on the remote server.
     * So, where possible, use the {@link VectorLayerAdapter.propertiesFilter}.
     * @example
     * ```javascript
     * layer.filter((e) => e.feature.properties.id === 2011);
     * // but in this case it’s better to do so:
     * layer.propertiesFilter([['id', 'eq', 2011]])
     * ```
     */
    filter?(cb: DataLayerFilter<F, L>): Array<LayerDefinition<Feature, L>>;
    /**
     * The way to filter layer objects through serializable expressions.
     * To clear the filter, pass `null` or `undefined` as the second parameter.
     * @param filters - Filter, conforming to the PropertiesFilter expression specification's.
     * @param options - Options object.
     * @example
     * ```javascript
     * layer.propertiesFilter(['all', ['color', 'eq', 'green'], ['year', 'gt', 2011]]);
     * layer.propertiesFilter([[
     *   'any',
     *   ['color', 'eq', 'green'],
     *   ['color', 'eq', 'red']
     * ],
     *   ['year', 'gt', 2011]
     * ]);
     * ```
     */
    propertiesFilter?(filters: PropertiesFilter<P>, options?: FilterOptions<P>): Promise<void>;
    /**
     * Cancel the filter, return all objects to the map.
     */
    removeFilter?(): void;
    /**
     * Add GeoJson data to layer.
     * @param geojson - GeoJson object.
     */
    addData?(geojson: GeoJsonObject): void | Promise<void>;
    /**
     * Update layer with new geojson.
     * @param geojson - GeoJson object.
     */
    setData?(geojson: GeoJsonObject): void | Promise<void>;
    /**
     * Remove layer data.
     * @param cb - Delete only those objects that match the filter.
     */
    clearLayer?(cb?: (feature: F) => boolean): void | Promise<void>;
    /**
     * Callback function that will be called when clicking on a layer.
     * @param event - Data that is transmitted when you click on a layer.
     */
    onLayerClick?(event: OnLayerMouseOptions): Promise<any>;
    openPopup?(findFeatureCb?: DataLayerFilter<F, L>, options?: PopupOptions): void;
    closePopup?(findFeatureCb?: DataLayerFilter<F, L>): void;
    updateTooltip?(layerDef?: LayerDefinition<F, L>): void;
    hideLabel?(): void;
    showLabel?(): void;
    isLabelVisible?(): boolean;
}

interface WebMapEvents extends MainMapEvents {
    /**
     * @eventProperty
     */
    create: WebMap;
    /**
     * @eventProperty
     */
    'build-map': MapAdapter;
    /**
     * @eventProperty
     */
    'layer:preadd': LayerAdapter;
    [key: `layer-${string | number}:preadd`]: LayerAdapter;
    /**
     * @eventProperty
     */
    'layer:add': LayerAdapter;
    [key: `layer-${string | number}:add`]: LayerAdapter;
    /**
     * @eventProperty
     */
    'layer:preremove': LayerAdapter;
    [key: `layer-${string | number}:preremove`]: LayerAdapter;
    /**
     * @eventProperty
     */
    'layer:remove': LayerAdapter;
    [key: `layer-${string | number}:remove`]: LayerAdapter;
    /**
     * @eventProperty
     */
    'layer:preupdate': LayerAdapter;
    [key: `layer-${string | number}:preupdate`]: LayerAdapter;
    /**
     * @eventProperty
     */
    'layer:updated': LayerAdapter;
    [key: `layer-${string | number}:updated`]: LayerAdapter;
    /**
     * @eventProperty
     */
    'layer:preshow': LayerAdapter;
    [key: `layer-${string | number}:preshow`]: LayerAdapter;
    /**
     * @eventProperty
     */
    'layer:show': LayerAdapter;
    [key: `layer-${string | number}:show`]: LayerAdapter;
    /**
     * @eventProperty
     */
    'layer:prehide': LayerAdapter;
    [key: `layer-${string | number}:prehide`]: LayerAdapter;
    /**
     * @eventProperty
     */
    'layer:hide': LayerAdapter;
    [key: `layer-${string | number}:hide`]: LayerAdapter;
    /**
     * @eventProperty
     */
    'layer:pretoggle': LayerAdapter;
    [key: `layer-${string | number}:pretoggle`]: LayerAdapter;
    /**
     * @eventProperty
     */
    'layer:toggle': LayerAdapter;
    [key: `layer-${string | number}:toggle`]: LayerAdapter;
    /**
     * @eventProperty
     */
    'layer:click': OnLayerMouseOptions;
    [key: `layer-${string | number}:click`]: OnLayerMouseOptions;
    /**
     * @eventProperty
     */
    'layer:dblclick': OnLayerMouseOptions;
    [key: `layer-${string | number}:dblclick`]: OnLayerMouseOptions;
    /**
     * @eventProperty
     */
    'layer:mouseover': OnLayerMouseOptions;
    [key: `layer-${string | number}:mouseover`]: OnLayerMouseOptions;
    /**
     * @eventProperty
     */
    'layer:mouseout': OnLayerMouseOptions;
    [key: `layer-${string | number}:mouseout`]: OnLayerMouseOptions;
    /**
     * @eventProperty
     */
    'layer:select': OnLayerSelectOptions;
    [key: `layer-${string | number}:select`]: OnLayerMouseOptions;
    /**
     * @eventProperty
     */
    'layer:label:toggle': LayerAdapter;
    /**
     * @eventProperty
     */
    'controls:create': any;
    /**
     * @eventProperty
     */
    [key: `event-${string}`]: any;
}
interface MapAdapterEvents extends MainMapEvents {
    /**
     * @eventProperty
     */
    'data-loaded': DataLoadError;
    /**
     * @eventProperty
     */
    'data-error': DataLoadError;
    /**
     * @eventProperty
     */
    create: MapAdapter;
}
interface MainMapEvents {
    /**
     * Fired before the map is clicked.
     * @eventProperty
     */
    preclick: MapClickEvent;
    /**
     * Fired every time a map is clicked.
     * @eventProperty
     */
    click: MapClickEvent;
    /**
     * Fired when the map zoom is about to change.
     * @eventProperty
     */
    zoomstart: MapAdapter;
    /**
     * Fired repeatedly during any change in zoom level
     * @eventProperty
     */
    zoom: MapAdapter;
    /**
     * Fired when the map has changed.
     * @eventProperty
     */
    zoomend: MapAdapter;
    /**
     * Fired when the view of the map starts changing (e.g. user starts dragging the map).
     * @eventProperty
     */
    movestart: MapAdapter;
    /**
     * Fired repeatedly during any movement of the map.
     * @eventProperty
     */
    move: MapAdapter;
    /**
     * Fired when the center of the map stops changing.
     * @eventProperty
     */
    moveend: MapAdapter;
    /**
     * 	Fired while the mouse moves over the map.
     * @eventProperty
     */
    mousemove: MapAdapter;
    /**
     * 	Fired when the mouse leaves the map.
     * @eventProperty
     */
    mouseout: MapAdapter;
    /**
     * Fired when the mouse enters the map.
     * @eventProperty
     */
    mouseover: MapAdapter;
}

interface MapStateItem<V = any> {
    event: (keyof WebMapEvents)[];
    name: string;
    getValue: () => V;
    toString: () => string | undefined;
    parse: (str: string) => V;
}

declare abstract class StateItem<V extends any | undefined = any | undefined> implements MapStateItem<V | undefined> {
    protected webMap: WebMap;
    name: keyof MapOptions;
    event: (keyof WebMapEvents)[];
    protected value?: V;
    constructor(webMap: WebMap, opt?: {
        name?: keyof MapOptions;
        event?: (keyof WebMapEvents)[] | keyof WebMapEvents;
        value?: V;
    });
    getValue(): V | undefined;
    setValue(val: V): void;
    abstract toString(): string | undefined;
    abstract parse(str: string): V;
}

type EmitStatusEventData = any;
declare class WebMapMain<M = any, E extends WebMapEvents = WebMapEvents, O extends MapOptions = MapOptions> {
    static keys: Keys;
    static getPaintFunctions: {
        [name: string]: GetPaintFunction;
    };
    options: O;
    readonly emitter: StrictEventEmitter<EventEmitter, WebMapEvents>;
    readonly keys: Keys;
    readonly mapAdapter: MapAdapter<M>;
    readonly runtimeParams: RuntimeParams[];
    getPaintFunctions: {
        [name: string]: GetPaintFunction;
    };
    mapStateItems: Type<StateItem>[];
    id: number;
    /**
     * From runtime params
     */
    readonly mapState: StateItem[];
    protected _initMapState: Record<string, any>;
    protected readonly _starterKits: StarterKit[];
    private _extent?;
    private readonly _eventsStatus;
    private _coordFromMapClickAbort?;
    private readonly _mapEvents;
    constructor(mapOptions: O);
    getId(): number;
    /**
     * Manual way to create a map (If {@link MapOptions.create} is `false`).
     * @example
     * ```javascript
     * const webMap = new WebMap(options);
     * webMap.create().then(() => doSomething());
     * ```
     */
    create(): Promise<this>;
    setRuntimeParams(params: RuntimeParams): void;
    /**
     * Destroys WebMap, MapAdapter, clears all layers and turn off all event listeners
     */
    destroy(): void;
    mapStateWithFunc(func: (x: any) => any): Record<string, any>;
    getStateAsString(): Record<string, any>;
    getState(): Record<string, any>;
    getRuntimeParams(): Record<string, any>;
    /**
     * Returns the HTML element that contains the map.
     * @returns The map's container
     */
    getContainer(): HTMLElement | undefined;
    /**
     * Set the cursor icon to be displayed when hover icon on the map container.
     * @param cursor - Available cursor name from https://developer.mozilla.org/ru/docs/Web/CSS/cursor
     */
    setCursor(cursor: Cursor): void;
    getCursor(): Cursor | undefined;
    /**
     * Set the center of the current view.
     * @param lngLat - Array of two numbers representing longitude and latitude of the center of the map view.
     *
     * @example
     * ```javascript
     * // Mount Everest 27° 59′ 17″ N, 86° 55′ 31″ E
     * webMap.setCenter([86.925278, 27.988056]);
     * ```
     */
    setCenter(lngLat: LngLatArray): this;
    /**
     * Returns the map's geographical centerpoint.
     * @returns lngLat Array of two numbers representing longitude and latitude of the center of the map view.
     *
     * @example
     * ```javascript
     * // Mount Everest 27° 59′ 17″ N, 86° 55′ 31″ E
     * webMap.getCenter(); // [86.925278, 27.988056]
     * ```
     */
    getCenter(): LngLatArray | undefined;
    getBounds(): LngLatBoundsArray | undefined;
    getBoundsPolygon(): Feature<Polygon> | undefined;
    /**
     * Zoom to a specific zoom level.
     * @param zoom - The zoom level to set (0-24).
     */
    setZoom(zoom: number): this;
    /**
     * Returns the map's current zoom level.
     * @returns The map's current zoom level (0-24).
     */
    getZoom(): number | undefined;
    zoomIn(): void;
    zoomOut(): void;
    /**
     * Sets the view of the map geographical center and zoom
     * @param lngLat - Array of two numbers representing longitude and latitude of the center of the map view.
     * @param zoom - The zoom level to set (0-24).
     *
     * @example
     * ```javascript
     * // Mount Everest 27° 59′ 17″ N, 86° 55′ 31″ E
     * webMap.setView([86.925278, 27.988056], 12)
     * ```
     */
    setView(lngLatOr: LngLatArray, zoom?: number): void;
    setView(options: ViewOptions): void;
    /**
     * Sets a map view that contains the given geographical bounds.
     * @param bounds - Array of coordinates, measured in degrees, in [west, south, east, north] order.
     *
     * @example
     * ```javascript
     * // Whole world
     * webMap.fitBounds([0, -90, 180, 90]);
     * ```
     */
    fitBounds(bounds: LngLatBoundsArray, options?: FitOptions): this;
    /**
     * Checking the status of any asynchronous operation
     * @param event - The name of the event whose status is checked
     *
     * @example
     * ```javascript
     * var webMap = new WebMap(options);
     * webMap.getEventStatus('create'); // false
     * webMap.emitter.on('create', function () {
     *   webMap.getEventStatus('create'); // true
     * })
     * ```
     */
    getEventStatus(event: keyof E): boolean;
    /**
     * helper method to wait for events to load. By default, card creation is tracked
     * @param event - The name of the event whose status is checked
     *
     * @example
     * ```javascript
     * var webMap = new WebMap(options);
     * webMap.onLoad().then(function () {
     *   webMap.getEventStatus('create'); // true
     * })
     *
     * // use async/await syntax
     * async function () {
     *   await webMap.onLoad();
     *   doSomething();
     * }
     *
     * ```
     */
    onLoad(event?: keyof WebMapEvents): Promise<this>;
    onMapLoad(cb?: (mapAdapter: MapAdapter) => void): Promise<MapAdapter>;
    getLayerAdapters(): {
        [name: string]: Type<LayerAdapter>;
    };
    getLayerAdapter(name: string): Type<LayerAdapter>;
    locate(opt: LocateOptions, events?: LocationEvents): Locate;
    stopGetCoordFromMapClick(): void;
    getCoordFromMapClick(): Promise<LngLatArray>;
    protected _emitStatusEvent(eventName: keyof E, data?: EmitStatusEventData): void;
    protected _addLayerProviders(): Promise<void>;
    protected _onLoadSync(): Promise<void>;
    private _setupMap;
    private _setTileJsonOptions;
    private _zoomToInitialExtent;
    private _setInitMapState;
    private _addEventsListeners;
    private _removeEventListeners;
}

type AddedLayers<M = any, L = any> = {
    [id: string]: LayerAdapter<M, L>;
};
declare class WebMapLayers<M = any, L = any, E extends WebMapEvents = WebMapEvents, O extends MapOptions = MapOptions> extends WebMapMain<M, E, O> {
    private _layersIdCounter;
    private _layersOrderCounter;
    private readonly _baselayers;
    private readonly _layers;
    private readonly _selectedLayers;
    constructor(mapOptions: O);
    /**
     * Try to fit map view by given layer bounds.
     * But not all layers have borders
     */
    fitLayer(layerDef: LayerDef, options?: FitOptions): Promise<void>;
    /**
     * Check if given layer is baselayer
     */
    isBaseLayer(layerDef: LayerDef): boolean | undefined;
    getBaseLayers(): LayerAdapter[];
    getBaseLayersIds(): string[];
    /**
     * Helper method to return added layer object by any definition type.
     */
    getLayer<LA extends LayerAdapter = LayerAdapter>(layerDef: LayerDef): LA | undefined;
    /**
     * Helper method to return added layer identificator by any definition type.
     */
    getLayerId(layerDef: LayerDef): string | undefined;
    /**
     * Return array of all added layer identifications.
     */
    getLayers(): string[];
    allLayers(): AddedLayers<M, L>;
    orderedLayers<LA extends LayerAdapter<M, L> = LayerAdapter<M, L>>(): LA[];
    findLayer<T extends LayerAdapter = LayerAdapter>(filter: (adapter: T) => boolean): T | undefined;
    /**
     * Check if the given layer on the map
     */
    isLayerVisible(layerDef: LayerDef): boolean;
    /**
     * Shortcut method to create base layer
     */
    addBaseLayer<K extends keyof LayerAdapters, O extends AdapterOptions = AdapterOptions>(adapter: K | Type<LayerAdapters[K]>, options?: O | LayerAdaptersOptions[K]): Promise<LayerAdapter>;
    /**
     * Registration of map layer.
     *
     * @param adapter - The name of layer adapter from [MapAdapter.layerAdapters](webmap#MapAdapter.layerAdapters).
     *                May be custom object or class implemented by [MainLayerAdapter](webmap#MainLayerAdapter).
     * @param options - Specific options for given adapter
     *
     * @example
     * ```javascript
     * webMap.addLayer('TILE', options).then((layer) => webMap.showLayer(layer));
     *
     * webMap.addLayer(CustomLayerAdapter, options);
     * ```
     */
    addLayer<K extends keyof LayerAdapters, LO extends AdapterOptions = AdapterOptions>(adapter: LayerAdapterDefinition<K>, options?: LO | LayerAdaptersOptions[K], order?: number): Promise<LayerAdapter>;
    addLayerFromAsyncAdapter<K extends keyof LayerAdapters, O extends AdapterOptions = AdapterOptions>(adapter: AdapterConstructor, options: O | LayerAdaptersOptions[K], order?: number): Promise<LayerAdapter>;
    /**
     * Remove all layer from map and memory.
     */
    removeLayers(allowCb?: (layer: string, adapter: LayerAdapter) => boolean): void;
    getLegend(options?: GetLegendOptions): Promise<LayerLegend[]>;
    reserveOrder(): number;
    /**
     * Remove all layers but not remove basemap.
     */
    removeOverlays(): void;
    /**
     * Remove specific layer from map and memory by its definition.
     */
    removeLayer(layerDef: LayerDef): void;
    /**
     * Create layer from GeoJson data. Set style and behavior for selection.
     *
     * @example
     * ```javascript
     * // Add simple layer
     * webMap.addGeoJsonLayer({ data: geojson, paint: { color: 'red' } });
     *
     * // Add styled by feature property layer with selection behavior
     * webMap.addGeoJsonLayer({
     *   data: geojson,
     *   paint: function (feature) {
     *     return { color: feature.properties.color, opacity: 0.5 }
     *   },
     *  selectedPaint: function (feature) {
     *    return { color: feature.properties.selcolor, opacity: 1 }
     *  },
     *  selectable: true,
     *  multiselect: true
     * });
     *
     * // Add marker layer styled with use [Icons](icons)
     * webMap.addGeoJsonLayer({ data: geojson, paint: webMap.getIcon({ color: 'orange' })});
     *
     * // work with added layer
     * const layer = webMap.addGeoJsonLayer({ data: geojson, id: 'my_layer_name'});
     * // access layer by id
     * webMap.showLayer('my_layer_name');
     * // or access layer by instance
     * webMap.showLayer(layer);
     * ```
     */
    addGeoJsonLayer<K extends keyof LayerAdapters = keyof LayerAdapters, O extends GeoJsonAdapterOptions<any, any> = GeoJsonAdapterOptions>(opt?: O, adapter?: LayerAdapterDefinition<K>): Promise<VectorLayerAdapter<any, any, any>>;
    /** Shortcut for {@link WebMapLayers.addGeoJsonLayer} to create GeoJson adapter with generic types for working in typescript */
    addFeatureLayer<P extends FeatureProperties = FeatureProperties, G extends Geometry = Geometry, O extends GeoJsonAdapterOptions<Feature<G, P>> = GeoJsonAdapterOptions<Feature<G, P>>>(options?: O): Promise<FeatureLayerAdapter<P, G>>;
    /** Shortcut for {@link WebMapLayers.addLayer} to create TileLayer adapter */
    addTileLayer(url: string, options?: Omit<TileAdapterOptions, 'url'>): Promise<MainLayerAdapter<M, L, TileAdapterOptions>>;
    /** Shortcut for {@link WebMapLayers.addLayer} to create TileLayer adapter */
    addImageLayer(url: string, options: Omit<ImageAdapterOptions, 'url'>): Promise<MainLayerAdapter<M, L, ImageAdapterOptions>>;
    addImageLayer(options: ImageAdapterOptions): Promise<MainLayerAdapter<M, L, ImageAdapterOptions>>;
    /**
     * Show added layer on the map by it definition.
     */
    showLayer(layerDef: LayerDef, options?: ToggleLayerOptions): Promise<void>;
    /**
     * Hide added layer on the map by it definition.
     */
    hideLayer(layerDef: LayerDef, options?: ToggleLayerOptions): Promise<void>;
    /**
     * Change added layer visibility on the map by given status or inverse current status.
     *
     * @example
     * ```javascript
     * webMap.addLayer('TILE', {id: 'my_layer', url: ''}).then((layer) => {
     *   webMap.toggleLayer(layer, true);
     *   webMap.toggleLayer('my_layer', false);
     *   webMap.toggleLayer('my_layer');
     *   webMap.isLayerVisible(layer); // true
     * });
     * ```
     */
    toggleLayer(layerDef: LayerDef, status?: boolean, options?: ToggleLayerOptions): Promise<void>;
    updateLayer(layerDef: LayerDef, options?: {
        params?: Record<string, string>;
    }): Promise<void>;
    /**
     * Set transparency for a given layer by number from 0 to 1
     */
    setLayerOpacity(layerDef: LayerDef, value: number): void;
    isLayerLabelVisible(layerDef: LayerDef): boolean;
    showLayerLabel(layerDef: LayerDef): void;
    hideLayerLabel(layerDef: LayerDef): void;
    toggleLayerLabel(layerDef: LayerDef, status?: boolean): boolean;
    /**
     * Mark the layer as selected.
     * If the adapter is a vector layer and supports data selection,
     * you can pass a callback function to specify which data will be selected.
     *
     * @example
     * ```javascript
     * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {
     *   webMap.selectLayer(layer, ({feature}) => feature.id === '42');
     * });
     * ```
  
     */
    selectLayer(layerDef: LayerDef, findFeatureFun?: DataLayerFilter): void;
    /**
     * Unselect the given layer.
     * If the adapter is a vector layer and supports data selection,
     * you can pass a callback function to specify which data will be unselected.
     *
     * @example
     * ```javascript
     * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {
     *   webMap.unSelectLayer(layer, ({feature}) => feature.id === '42');
     * });
     * ```
     *
     */
    unSelectLayer(layerDef: LayerDef, findFeatureFun?: DataLayerFilter): void;
    /** Remove selection from any selected selectable layer */
    unSelectLayers(): void;
    /**
     * Hide features from a vector layer using a callback function.
     *
     * @example
     * ```javascript
     * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {
     *   webMap.filterLayer(layer, ({feature}) => feature.id === '42');
     * });
     * ```
     *
     */
    filterLayer(layerDef: LayerDef, filter: DataLayerFilter<Feature, L>): LayerDefinition<Feature, L>[];
    propertiesFilter(layerDef: LayerDef, filters: PropertiesFilter, options?: FilterOptions): Promise<void>;
    removeLayerFilter(layerDef: LayerDef): void;
    /**
     * Sets the GeoJSON data for given vector layer.
     *
     * @example
     * ```javascript
     * const layer = webMap.addLayer('GEOJSON').then((layer) => {
     *   webMap.setLayerData(layer, geojson);
     * });
     * ```
     */
    setLayerData(layerDef: LayerDef, data: GeoJsonObject): void | Promise<void>;
    /**
     * Push new the GeoJSON features into given vector layer.
     *
     * @example
     * ```javascript
     * const layer = webMap.addLayer('GEOJSON', {data: geojson_features_5}).then((layer) => {
     *   console.log(layer.getLayers().length) // > 5;
     *   webMap.addLayerData(layer, geojson_features_3);
     *   console.log(layer.getLayers().length) // > 8;
     * });
     * ```
     */
    addLayerData(layerDef: LayerDef, data: GeoJsonObject): void;
    /**
     * Remove from vector layer all features.
     * it is possible to remove only some objects if you specify a callback function.
     *
     * @example
     * ```javascript
     * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {
     *   webMap.clearLayerData(layer, (feture) => feture.id === 42);
     *   webMap.clearLayerData(layer);
     * });
     * ```
     */
    clearLayerData(layerDef: LayerDef, cb?: (feature: Feature) => boolean): void;
    setLayerPaint(layerDef: LayerDef, paint?: Paint | null): void;
    setLayerSelectedPaint(layerDef: LayerDef, paint?: Paint | null): void;
    updateLayerPaint(layerDef: LayerDef, paint: Partial<Paint>): void;
    updateLayerSelectedPaint(layerDef: LayerDef, paint: Partial<Paint>): void;
    getAttributions(options: GetAttributionsOptions): string[];
    getActiveBaseLayer(): MainLayerAdapter<M, any, AdapterOptions> | undefined;
    addTileJsonLayer(tileJson: TileJson): Promise<MainLayerAdapter<M, any, TileAdapterOptions>>;
    private _onLayerClick;
    private _onLayerDoubleClick;
    private _onLayerSelect;
    private _updateGeoJsonOptions;
}

/**
 * Collection of methods for managing map controls
 */
declare class WebMapControls<M = any, L = any, C extends object = any, E extends WebMapEvents = WebMapEvents, O extends MapOptions = MapOptions> extends WebMapLayers<M, L, E, O> implements WebMapLayers, WebMapMain {
    static controls: {
        [name: string]: (webMap: WebMapControls, options?: any) => any;
    };
    private _loadControlQueue;
    private _isControlLoading;
    addControl<K extends keyof MapControls>(controlDef: K | C, position: ControlPosition, options?: MapControls[K]): Promise<any>;
    /**
     * Creating a universal map layout control element. Can be used with any map adapter.
     *
     * @example
     * ```javascript
     * const control = webMap.createControl({
     *   onAdd() {
     *     return document.createElement('div');
     *   }
     * });
     * ```
     */
    createControl(control: MapControl, options?: CreateControlOptions): Promise<C | undefined>;
    createButtonControl(options: ButtonControlOptions): Promise<C | undefined>;
    /**
     * Create any toggler control button
     * @param options - Options for control layout customization and assigning a callback function
     *
     * @example
     * ```javascript
     * const toggleControl = ngwMap.createToggleControl({
     *   getStatus: () => webMap.isLayerVisible('any-layer-id'),
     *   onClick: (status) => ngwMap.toggleLayer('webmap', status),
     *   html: {
     *     on: 'ON',
     *     off: 'OFF'
     *   },
     *   title: 'Toggle layer visibility'
     * });
     * webMap.addControl(toggleControl, 'top-right');
     * ```
     * {@link http://code.nextgis.com/demo-examples-toggle-control | Toggle button control example}
     */
    createToggleControl(options: ToggleControlOptions): Promise<(C & ToggleControl) | undefined>;
    /**
     *
     * @param control - Instance of WEB-GIS framework control.
     *                  What is returned by the {@link createControl | create} method
     */
    removeControl(control: C): void;
    /**
     * Get instance of registered control
     * @param control - Any registered control string name
     * @param options - Custom control options
     */
    getControl<K extends keyof MapControls>(control: K, options?: MapControls[K]): C | undefined;
    getControlContainer(): HTMLElement | undefined;
    private _setControlQueue;
    private _applyControls;
}

/**
 * @privateRemarks
 * Since it was not possible to split the code through mixins, inheritance was used.
 * The `ts-mixin` plugin worked fine, but led to errors in IE.
 *
 * Now inheritance is as follow:
 * BaseWebMap \> WebMapLayers \> WebMap
 *
 * Will need to be done this way:
 * ```javascript
 * class WebMap extend mixin(WebMapLayers, WebMapControls) {}
 * ```
 *
 * This approach can also be considered
 * ```javascript
 * class WebMap {
 *   layers: WebMapLayers;
 *   controls  WebMapControls
 * }
 * ```
 * and then
 *
 * const webMap = new WebMap(...);
 * webMap.layers.addLayer(...)
 *
 * looks good, but will add difficulty in inheriting from WebMap
 *
 * old:
 * ```javascript
 * class NgwMap extends WebMap {
 *   addLayer(...) {
 *      super.addLayer(...)
 *   }
 * }
 * ```
 * new:
 * ```javascript
 * class NgwLayers extends WebMapLayers {
 *   addLayer(...) {
 *     super.addLayer(...)
 *   }
 * }
 *
 * class NgwMap extends WebMap {
 *   layersClass = NgwLayers
 * }
 * ```
 * ...and there will be compatibility issues
 */

/**
 * The core component for managing map adapters.
 * It contains methods for adding and manipulation with
 * {@link WebMapMain | map}, {@link WebMapLayers | layers} and {@link WebMapControls | controls}.
 *
 * @example
 * ```javascript
 * import { WebMap } from '@nextgis/webmap';
 * import MapAdapter from '@nextgis/ol-map-adapter';
 *
 * const webMap = new WebMap({
 *   mapAdapter: new MapAdapter(),
 *   target: 'map',
 * });
 * ```
 *
 * @typeParam M - Interactive Map used in the adapter
 * @typeParam L - Layer
 * @typeParam C - Control
 * @typeParam E - Events
 *
 */
declare class WebMap<M = any, L = any, C extends object = any, E extends WebMapEvents = WebMapEvents, O extends MapOptions = MapOptions> extends WebMapControls<M, L, C, E, O> implements WebMapControls, WebMapLayers, WebMapMain {
    constructor(mapOptions: O);
    static get<T extends WebMap = WebMap>(id: number): T;
    private _addControls;
}

declare function getWebMap<T extends WebMap = WebMap>(id: number): T;
declare function setWebMap(id: number, webMap: WebMap): void;

declare function getDefaultControls(): string[];

declare const typeAlias: {
    [x: string]: VectorAdapterLayerType;
};

declare function createWebMap(options: MapOptions): Promise<WebMap>;

export { type AdapterConstructor, type AdapterOptions, type AttributionControlOptions, type ButtonControlOptions, type CallbackFilter, type ContribControlsOptions, type ControlOptions, type ControlPosition, type ControlPositions, type ControlsOptions, type CreateControlOptions, type CreatePopupContent, type CreatePopupContentProps, type Cursor, type DataLayerFilter, type DataLoadError, type FeatureLayerAdapter, type FeaturePosition, type FilterOptions, type FitOptions, type GeoJsonAdapterOptions, type GetAttributionsOptions, type GetLegendOptions, type HtmlDef, type HtmlToggle, type ImageAdapterOptions, type LayerAdapter, type LayerAdapterCreators, type LayerAdapterDefinition, type LayerAdapters, type LayerAdaptersOptions, type LayerDef, type LayerDefinition, type Locate, type LocateOptions, type LocationEvent, type LocationEvents, type MainLayerAdapter, type MainMapEvents, type MapAdapter, type MapAdapterEvents, type MapClickEvent, type MapControl, type MapControls, type MapOptions, type Model3DOptions, type MvtAdapterOptions, type OnBeforeLayerAdd, type OnClick, type OnClickSync, type OnLayerClickOptions, type OnLayerMouseOptions, type OnLayerSelectOptions, type OnLayerSelectType, type OnToggleClick, type OnToggleClickSync, type Pixel, type PopupOnCloseFunction, type PopupOptions, type RasterAdapterOptions, type RuntimeParams, type StarterKit, type TileAdapterOptions, type Tileset3DAdapterOptions, type TitleToggle, type ToggleControl, type ToggleControlOptions, type ToggleLayerOptions, type UpdateLayerAdapterOptions, type VectorAdapterLayerType, type VectorAdapterOptions, type VectorLayerAdapter, type ViewOptions, WebMap, WebMapControls, type WebMapEvents, WebMapLayers, WebMapMain, type WmsAdapterOptions, type ZoomControlOptions, createWebMap, getDefaultControls, getWebMap, type onClickAsync, type onToggleClickAsync, setWebMap, typeAlias };
