/** Bundle of @nextgis/webmap; version: 3.0.0-alpha.17; author: NextGIS */
const WEB_MAP_CONTAINER = {};
function getWebMap(id) {
  return WEB_MAP_CONTAINER[id];
}
function setWebMap(id, webMap) {
  WEB_MAP_CONTAINER[id] = webMap;
}

function createToggleControl(createButtonControl, options) {
  const link = document.createElement("div");
  let status = false;
  if (options.getStatus) {
    status = options.getStatus();
  } else if (options.status) {
    status = options.status;
  }
  const title = options.title || "";
  const html = options.html;
  function setTitle() {
    if (title) {
      if (typeof title === "string") {
        link.title = title;
      } else {
        link.title = status ? title.on : title.off;
      }
      link.setAttribute("aria-label", link.title);
    }
  }
  setTitle();
  function _setHtml(htmlDef) {
    if (htmlDef instanceof HTMLElement) {
      link.innerHTML = "";
      link.appendChild(htmlDef);
    } else if (typeof htmlDef === "string") {
      link.innerHTML = htmlDef;
    }
  }
  function setHtml() {
    if (html) {
      if (typeof html === "string" || html instanceof HTMLElement) {
        _setHtml(html);
      } else {
        _setHtml(status ? html.on : html.off);
      }
      link.setAttribute("aria-label", link.title);
    }
  }
  setHtml();
  function _setClass(addClass, impact) {
    addClass.split(" ").forEach((x) => {
      if (impact) {
        link.classList.add(x);
      } else {
        link.classList.remove(x);
      }
    });
  }
  function setClass() {
    if (options.addClassOn) {
      _setClass(options.addClassOn, status);
    }
    if (options.addClassOff) {
      _setClass(options.addClassOff, !status);
    }
  }
  if (options.addClass) {
    _setClass(options.addClass, true);
  }
  setClass();
  const changeStatus = (status_) => {
    if (status_ !== void 0) {
      status = status_;
    }
    setHtml();
    setTitle();
    setClass();
  };
  const onClick = (status_) => {
    status = status_ !== void 0 ? status_ : !status;
    if (options.onClick) {
      const afterClick = options.onClick(status);
      Promise.resolve(afterClick).then(() => changeStatus()).catch(() => status = !status);
    } else {
      changeStatus();
    }
  };
  const buttonControl = createButtonControl({
    html: link,
    onClick
  });
  buttonControl.onClick = onClick;
  buttonControl.changeStatus = changeStatus;
  return buttonControl;
}

function evaluateArgs(cb) {
  return (args, data) => {
    const unwrap = args.map((a) => a());
    return cb(unwrap, data);
  };
}

function not([expr]) {
  return !expr;
}
function notEqual([a, b]) {
  return a !== b;
}
function lessThan([left, right]) {
  return left < right;
}
function lessThanOrEqual([left, right]) {
  return left <= right;
}
function equal([left, right]) {
  return left === right;
}
function greaterThan([left, right]) {
  return left > right;
}
function greaterThanOrEqual([left, right]) {
  return left >= right;
}
const coalesce = (args) => {
  for (let i = 0; i < args.length; i++) {
    const arg = args[i]();
    if (arg !== null && arg !== void 0) {
      return arg;
    }
  }
  return null;
};
const all = (args) => {
  for (let i = 0; i < args.length; i++) {
    const arg = args[i]();
    if (!arg) {
      return false;
    }
  }
  return true;
};
const any = (args) => {
  for (let i = 0; i < args.length; i++) {
    const arg = args[i]();
    if (arg) {
      return true;
    }
  }
  return false;
};
const match = (args) => {
  const [lookupFn, ...cases] = args;
  const lookup = lookupFn();
  const defValue = cases.splice(-1, cases.length % 2)[0];
  for (let fry = 0; fry < cases.length - 1; fry += 2) {
    const key = cases[fry]();
    if (key === lookup) {
      return cases[fry + 1]();
    }
  }
  return defValue();
};
const caseFunc = (args) => {
  if (args.length < 2) {
    throw new Error(
      'The "case" function requires at least a condition and a corresponding output.'
    );
  }
  if (args.length % 2 === 0) {
    throw new Error(
      "Missing a fallback value or unmatched condition-output pair."
    );
  }
  for (let i = 0; i < args.length - 1; i += 2) {
    const condition = args[i]();
    const value = args[i + 1]();
    if (condition) {
      return value;
    }
  }
  const fallback = args[args.length - 1];
  return fallback();
};
const decisionExpressions = {
  "!": evaluateArgs(not),
  "!=": evaluateArgs(notEqual),
  "<": evaluateArgs(lessThan),
  "<=": evaluateArgs(lessThanOrEqual),
  "==": evaluateArgs(equal),
  ">": evaluateArgs(greaterThan),
  ">=": evaluateArgs(greaterThanOrEqual),
  coalesce,
  all,
  any,
  case: caseFunc,
  match
};

const COLORS = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  "indianred ": "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgrey: "#d3d3d3",
  lightgreen: "#90ee90",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370d8",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#d87093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};

function isHex(hex) {
  return typeof hex === "string" && /^#([A-Fa-f0-9]{3}){1,2}$/.test(hex);
}
function isRgb(hex) {
  const r = (
    // eslint-disable-next-line max-len
    /^rgb(a?)\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)(?:\s*,\s*([01](?:\.\d+)?))?\s*\)$/
  );
  return typeof hex === "string" && r.test(hex);
}
function isColorObj(obj) {
  if (typeof obj === "object" && obj !== null) {
    const hasRgb = "r" in obj && "g" in obj && "b" in obj;
    const hasValidAlpha = !("a" in obj) || typeof obj.a === "number" && obj.a >= 0 && obj.a <= 1;
    return hasRgb && hasValidAlpha;
  }
  return false;
}
function isColorName(name) {
  if (typeof name === "string" && name in COLORS) {
    return true;
  }
  return false;
}
function toColor(value) {
  if (isHex(value)) {
    return hexToColor(value);
  } else if (isColorName(value)) {
    return colorNameToColor(value);
  } else if (isRgb(value)) {
    return rgbToColor(value);
  } else if (isColorObj(value)) {
    return colorObjectToColor(value);
  }
  throw new Error(`The '${value}' cannot be converted to color`);
}
function colorNameToColor(name) {
  return hexToColor(COLORS[name]);
}
function hexToColor(hex) {
  const shortRGB = /^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/;
  const shortRGBA = /^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/;
  const longRGB = /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/;
  const longRGBA = /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/;
  let result;
  if (result = shortRGB.exec(hex)) {
    return [
      parseInt(result[1] + result[1], 16),
      parseInt(result[2] + result[2], 16),
      parseInt(result[3] + result[3], 16)
    ];
  } else if (result = shortRGBA.exec(hex)) {
    return [
      parseInt(result[1] + result[1], 16),
      parseInt(result[2] + result[2], 16),
      parseInt(result[3] + result[3], 16),
      parseInt(result[4] + result[4], 16) / 255
    ];
  } else if (result = longRGB.exec(hex)) {
    return [
      parseInt(result[1], 16),
      parseInt(result[2], 16),
      parseInt(result[3], 16)
    ];
  } else if (result = longRGBA.exec(hex)) {
    return [
      parseInt(result[1], 16),
      parseInt(result[2], 16),
      parseInt(result[3], 16),
      parseInt(result[4], 16) / 255
    ];
  }
  throw new Error(`The '${hex}' Is not valid hex`);
}
function rgbToColor(rgb) {
  const rgbPattern = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/;
  const rgbaPattern = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)$/;
  let matches;
  if (matches = rgb.match(rgbPattern)) {
    return [
      parseInt(matches[1], 10),
      parseInt(matches[2], 10),
      parseInt(matches[3], 10)
    ];
  } else if (matches = rgb.match(rgbaPattern)) {
    return [
      parseInt(matches[1], 10),
      parseInt(matches[2], 10),
      parseInt(matches[3], 10),
      parseFloat(matches[4])
    ];
  }
  throw new Error(`The '${rgb}' Is not valid rgb`);
}
function colorObjectToColor({ r, g, b, a }) {
  return [r, g, b, ...a !== void 0 ? [a] : []];
}
function colorToRGB(array) {
  return `rgb(${array.join(",")})`;
}

function linearInterpolation(input, input1, output1, input2, output2) {
  if (typeof output1 === "number" && typeof output2 === "number") {
    return output1 + (input - input1) / (input2 - input1) * (output2 - output1);
  }
  try {
    const outputColor1 = toColor(output1);
    const outputColor2 = toColor(output2);
    return colorToRGB(
      outputColor1.map((val, index) => {
        return Math.ceil(
          linearInterpolation(input, input1, val, input2, outputColor2[index])
        );
      })
    );
  } catch (er) {
    console.log(er);
  }
  throw new Error("Unsupported output type for linear interpolation.");
}
const interpolate = ([
  interpolationFn,
  inputFn,
  ...stops
]) => {
  if (stops.length < 2) {
    throw new Error("At least two stops are required");
  }
  if (stops.length < 2 || stops.length % 2 !== 0) {
    throw new Error("Invalid stops provided.");
  }
  const input = inputFn();
  if (typeof input !== "number") {
    throw new Error("Input must be a number.");
  }
  const interpolation = interpolationFn();
  for (let i = 0; i < stops.length - 2; i += 2) {
    const stopInput1 = stops[i]();
    const stopOutput1 = stops[i + 1]();
    const stopInput2 = stops[i + 2]();
    const stopOutput2 = stops[i + 3]();
    if (input >= stopInput1 && input <= stopInput2) {
      if (interpolation[0] === "linear") {
        return linearInterpolation(
          input,
          stopInput1,
          stopOutput1,
          stopInput2,
          stopOutput2
        );
      }
    }
  }
  throw new Error("Invalid interpolation type.");
};

const step = (args) => {
  const [inputFn, defaultValue, ...stops] = args;
  const input = inputFn();
  if (typeof input !== "number") {
    return defaultValue();
  }
  for (let i = 0; i < stops.length - 2; i += 2) {
    const stopInput = stops[i]();
    const stopOutput = stops[i + 1]();
    const nextStopInput = stops[i + 2]();
    if (input >= stopInput && input < nextStopInput) {
      return stopOutput;
    }
  }
  if (input >= stops[stops.length - 2]()) {
    return stops[stops.length - 1]();
  }
  return defaultValue();
};

const interpolationExpressions = {
  step,
  interpolate
};

function get([key, objExp], data) {
  const target = objExp || data;
  if (target && typeof target === "object" && key in target) {
    return target[key];
  }
  return null;
}
function has([key, objExp], data) {
  const target = objExp || data;
  return !!(target && typeof target === "object" && key in target);
}
function at([index, array]) {
  return array[index];
}
function inFunc([keyword, input]) {
  if (typeof input === "string") {
    return input.includes(String(keyword));
  } else if (Array.isArray(input)) {
    return input.includes(keyword);
  }
  throw new Error(
    `Invalid input type for 'in'. Expected string or array, got ${typeof input}.`
  );
}
const length = ([item]) => {
  if (typeof item === "string" || Array.isArray(item)) {
    return item.length;
  }
  return void 0;
};
function indexOf([keyword, input, startIndex]) {
  if (typeof input === "string") {
    return input.indexOf(String(keyword), startIndex);
  } else if (Array.isArray(input)) {
    return input.indexOf(keyword, startIndex);
  }
  throw new Error(
    `Invalid input type for 'index-of'. Expected string or array, got ${typeof input}.`
  );
}
function slice(args) {
  const [input, startIndex, endIndex] = args;
  if (typeof input === "string") {
    return input.slice(startIndex, endIndex);
  } else if (Array.isArray(input)) {
    return input.slice(startIndex, endIndex);
  }
  throw new Error(
    `Invalid input type for 'slice'. Expected string or array, got ${typeof input}.`
  );
}
const lookupExpressions = {
  get: evaluateArgs(get),
  length: evaluateArgs(length),
  at: evaluateArgs(at),
  has: evaluateArgs(has),
  in: evaluateArgs(inFunc),
  "index-of": evaluateArgs(indexOf),
  slice: evaluateArgs(slice)
};

const mathExpressions = {
  "+": evaluateArgs((args) => args.reduce((a, b) => a + b, 0)),
  "-": evaluateArgs((args) => args.reduce((a, b) => a - b)),
  "*": evaluateArgs((args) => args.reduce((a, b) => a * b, 1)),
  "/": evaluateArgs((args) => args.reduce((a, b) => a / b)),
  "%": evaluateArgs((args) => args[0] % args[1]),
  "^": evaluateArgs((args) => Math.pow(args[0], args[1])),
  abs: evaluateArgs((args) => Math.abs(args[0])),
  acos: evaluateArgs((args) => Math.acos(args[0])),
  asin: evaluateArgs((args) => Math.asin(args[0])),
  atan: evaluateArgs((args) => Math.atan(args[0])),
  ceil: evaluateArgs((args) => Math.ceil(args[0])),
  cos: evaluateArgs((args) => Math.cos(args[0])),
  e: () => Math.E,
  floor: evaluateArgs((args) => Math.floor(args[0])),
  ln: evaluateArgs((args) => Math.log(args[0])),
  ln2: () => Math.LN2,
  log10: evaluateArgs((args) => Math.log10(args[0])),
  log2: evaluateArgs((args) => Math.log2(args[0])),
  max: evaluateArgs((args) => Math.max(...args)),
  min: evaluateArgs((args) => Math.min(...args)),
  pi: () => Math.PI,
  round: evaluateArgs((args) => Math.round(args[0])),
  sin: evaluateArgs((args) => Math.sin(args[0])),
  sqrt: evaluateArgs((args) => Math.sqrt(args[0])),
  tan: evaluateArgs((args) => Math.tan(args[0]))
};

const stringExpressions = {
  concat: evaluateArgs((args) => args.reduce((a, b) => String(a) + String(b), "")),
  downcase: evaluateArgs((args) => String(args[0]).toLowerCase()),
  upcase: evaluateArgs((args) => String(args[0]).toUpperCase())
};

const tryConvert = (converter, arg, data) => {
  try {
    const result = converter(arg, data);
    if (result !== void 0) {
      return result;
    }
  } catch (e) {
  }
  return void 0;
};

function fallback(cb) {
  return (args, data) => {
    for (const arg of args) {
      const result = tryConvert(cb, arg, data);
      if (result !== void 0) {
        return result;
      }
    }
    throw new Error(`Received a mismatched type`);
  };
}

const array = (args) => {
  const [firstArg, secondArg, thirdArg] = args;
  let requiredType = void 0;
  let requiredLength = void 0;
  let value;
  if (typeof firstArg === "string" && ["string", "number", "boolean"].includes(firstArg)) {
    requiredType = firstArg;
    if (typeof secondArg === "number") {
      requiredLength = secondArg;
      value = thirdArg;
    } else {
      value = secondArg;
    }
  } else if (Array.isArray(firstArg)) {
    value = firstArg;
  }
  if (!Array.isArray(value)) {
    throw new Error("Expected an array");
  }
  if (requiredType && !value.every((item) => typeof item === requiredType)) {
    throw new Error(
      `Expected all items in array to be of type ${requiredType}`
    );
  }
  if (requiredLength && value.length !== requiredLength) {
    throw new Error(`Expected array of length ${requiredLength}`);
  }
  return value;
};
function typeOfValue(value) {
  if (value === null) return "null";
  switch (typeof value) {
    case "string":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "object":
      if (Array.isArray(value)) {
        let arrayType = "value";
        if (value.every((item) => typeof item === "number")) {
          arrayType = "number";
        } else if (value.every((item) => typeof item === "string")) {
          arrayType = "string";
        } else if (value.every((item) => typeof item === "boolean")) {
          arrayType = "boolean";
        }
        return `array<${arrayType}, ${value.length}>`;
      } else {
        return "object";
      }
    default:
      return "undefined";
  }
}
const typeExpressions = {
  array: evaluateArgs(array),
  boolean: evaluateArgs(
    fallback((arg) => typeof arg === "boolean" ? arg : void 0)
  ),
  literal: evaluateArgs(([arg]) => arg),
  number: evaluateArgs(fallback((arg) => typeof arg === "number" ? arg : void 0)),
  object: evaluateArgs(
    fallback(
      (arg) => arg !== null && typeof arg === "object" && !Array.isArray(arg) ? arg : void 0
    )
  ),
  string: evaluateArgs(fallback((arg) => typeof arg === "string" ? arg : void 0)),
  "to-boolean": evaluateArgs(fallback(Boolean)),
  "to-number": evaluateArgs(fallback(Number)),
  "to-string": evaluateArgs(fallback(String)),
  typeof: evaluateArgs(([arg]) => typeOfValue(arg))
};

var __defProp$c = Object.defineProperty;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$c(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$c(a, prop, b[prop]);
    }
  return a;
};
function isExpression(value) {
  if (Array.isArray(value)) {
    const [lookup, ...cases] = value;
    const l = lookup;
    return typeof l === "string" && l !== "literal" && l in expressions && cases.length > 0;
  }
  return false;
}
const expressions = __spreadValues$4(__spreadValues$4(__spreadValues$4(__spreadValues$4(__spreadValues$4(__spreadValues$4({}, mathExpressions), typeExpressions), stringExpressions), lookupExpressions), decisionExpressions), interpolationExpressions);
function evaluate(expression, data = {}) {
  const [name, ...args] = expression;
  const expressionFun = expressions[name];
  if (expressionFun) {
    return expressionFun(
      args.map((arg) => () => isExpression(arg) ? evaluate(arg, data) : arg),
      data
    );
  }
  throw new Error(`Expression "${name}" is not supported.`);
}

var __defProp$b = Object.defineProperty;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$b(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$b(a, prop, b[prop]);
    }
  return a;
};
function createPropertyExpressionCb(expression) {
  return (feature) => {
    const properties = feature.properties;
    if (properties) {
      return evaluate(expression, properties);
    }
    return false;
  };
}
const excludeExpressionList = ["iconSize", "iconAnchor"];
function createExpressionCallback(paint) {
  let withExpression = false;
  const expressions = {};
  for (const p in paint) {
    if (excludeExpressionList.indexOf(p) === -1) {
      const p_ = p;
      const val = paint[p_];
      if (isExpression(val)) {
        withExpression = true;
        expressions[p_] = createPropertyExpressionCb(val);
      }
    }
  }
  if (withExpression) {
    return (feature) => {
      const fromCb = {};
      for (const p in expressions) {
        fromCb[p] = expressions[p](feature);
      }
      return __spreadValues$3(__spreadValues$3({}, paint), fromCb);
    };
  }
  return;
}

var __defProp$a = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$a(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$a(a, prop, b[prop]);
    }
  return a;
};
function reEscape(s) {
  return s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function like(b, a, iLike) {
  a = String(a);
  b = String(b);
  if (a === b) return true;
  if (iLike && a.toUpperCase() === b.toUpperCase()) return true;
  const re = `^${reEscape(a)}$`.replace(/%/g, ".*").replace("_", ".");
  return new RegExp(re, iLike ? "i" : "").exec(b) !== null;
}
const operationsAliases = {
  // greater(>)
  gt: (a, b) => a > b,
  // lower(<)
  lt: (a, b) => a < b,
  // greater or equal(>=)
  ge: (a, b) => a >= b,
  // lower or equal(<=)
  le: (a, b) => a <= b,
  // equal(=)
  eq: (a, b) => a === b,
  //  not equal(!=)
  ne: (a, b) => a !== b,
  in: (a, b) => b.indexOf(a) !== -1,
  notin: (a, b) => b.indexOf(a) === -1,
  // LIKE SQL statement(for strings compare)
  like: (a, b) => {
    return like(a, b);
  },
  // ILIKE SQL statement(for strings compare)
  ilike: (a, b) => {
    return like(a, b, true);
  }
};
function isPropertyFilter(filter) {
  const pf = filter;
  if (pf.length === 3 && typeof pf[0] === "string" && typeof pf[1] === "string") {
    return true;
  }
  return false;
}
function featureFilter(feature, filters) {
  const properties = __spreadValues$2({}, feature.properties);
  if (properties) {
    properties.$id = feature.id;
    return propertiesFilter(properties, filters);
  }
  return false;
}
function propertiesFilter(properties, filters) {
  const logic = typeof filters[0] === "string" ? filters[0] : "all";
  const filterFunction = (p) => {
    if (isPropertyFilter(p)) {
      const [field, operation, value] = p;
      const operationExec = operationsAliases[operation];
      if (operationExec) {
        if (operation === "like" || operation === "ilike") {
          if (typeof field === "string") {
            let prop = "";
            const value_ = field.replace(/^%?(\w+)%?$/, (match, cleanField) => {
              prop = properties[cleanField];
              return field.replace(cleanField, value);
            });
            return operationExec(prop, value_);
          }
        }
        return operationExec(properties[field], value);
      }
      return false;
    } else {
      return propertiesFilter(properties, p);
    }
  };
  const filters_ = filters.filter((x) => Array.isArray(x));
  return logic === "any" ? filters_.some(filterFunction) : filters_.every(filterFunction);
}

function isPropertiesPaint(paint) {
  if (Array.isArray(paint)) {
    return true;
  }
  return false;
}
function isPaint(paint) {
  if (Object.prototype.toString.call(paint) === "[object Object]") {
    return true;
  }
  return false;
}
function isPaintCallback(paint) {
  if (typeof paint === "function") {
    return true;
  }
  return false;
}

var __defProp$9 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
function updatePaintOptionFromCallback(paint, getPaintFunctions) {
  if (typeof paint.from === "function") {
    return paint.from(paint.options);
  } else if (typeof paint.from === "string" && getPaintFunctions) {
    const from = getPaintFunctions[paint.from];
    if (from) {
      return from(paint.options);
    }
  }
}
function createPropertiesPaint(propertiesPaint) {
  let mask = {};
  const paintsFilters = [];
  for (const p of propertiesPaint) {
    if (p) {
      if (Array.isArray(p)) {
        paintsFilters.push(p);
      } else {
        mask = p;
      }
    }
  }
  return (feature) => {
    const paint = paintsFilters.find((x) => featureFilter(feature, x[0]));
    if (paint) {
      return __spreadValues$1(__spreadValues$1({}, mask), paint[1]);
    }
    return mask;
  };
}
function expressionCallback({
  paint,
  defaultPaint
}) {
  const expressionCallback2 = createExpressionCallback(paint);
  if (expressionCallback2) {
    const expressionPaintCb = (feature) => {
      return preparePaint({
        paint: expressionCallback2(feature),
        defaultPaint
      });
    };
    expressionPaintCb.paint = finalizePaint({ paint, defaultPaint });
    return expressionPaintCb;
  }
  return finalizePaint({ paint, defaultPaint });
}
function finalizePaint({ paint, defaultPaint }) {
  var _a;
  let newPaint = __spreadValues$1({}, defaultPaint);
  newPaint = __spreadValues$1(__spreadValues$1({}, newPaint), paint);
  newPaint.fill = (_a = newPaint.fill) != null ? _a : true;
  newPaint.stroke = newPaint.stroke !== void 0 ? newPaint.stroke : !newPaint.fill || !!(newPaint.strokeColor || newPaint.strokeOpacity);
  return newPaint;
}
function preparePaint({
  paint,
  defaultPaint,
  getPaintFunctions
}) {
  if (!paint) {
    throw new Error("paint is empty");
  }
  let newPaint = __spreadValues$1({}, defaultPaint);
  if (isPaintCallback(paint)) {
    const getPaintFunction = (feature) => {
      const getPaint = preparePaint({
        paint: paint(feature),
        defaultPaint,
        getPaintFunctions
      });
      getPaint.type = paint.type;
      return getPaint;
    };
    getPaintFunction.type = paint.type;
    return getPaintFunction;
  } else if (isPropertiesPaint(paint)) {
    return (feature) => {
      return preparePaint({
        paint: createPropertiesPaint(paint)(feature),
        defaultPaint,
        getPaintFunctions
      });
    };
  } else if (paint.type === "get-paint") {
    const getPaint = updatePaintOptionFromCallback(paint, getPaintFunctions);
    if (getPaint) {
      newPaint = preparePaint({
        paint: getPaint,
        defaultPaint,
        getPaintFunctions
      });
    }
  } else if (paint.type === "icon") {
    return paint;
  } else {
    newPaint = expressionCallback({ paint, defaultPaint });
  }
  if (isPaintCallback(newPaint)) {
    return newPaint;
  }
  if ("color" in newPaint) {
    if (!newPaint.strokeColor) {
      newPaint.strokeColor = newPaint.color;
    }
    if (!newPaint.fillColor) {
      newPaint.fillColor = newPaint.color;
    }
  }
  if ("opacity" in newPaint) {
    if (newPaint.strokeOpacity === void 0) {
      newPaint.strokeOpacity = newPaint.opacity;
    }
    if (newPaint.fillOpacity === void 0) {
      newPaint.fillOpacity = newPaint.opacity;
    }
  }
  return newPaint;
}

function debugLog(message) {
  {
    console.trace("DEBUG: " + message);
    return true;
  }
}

function deepmerge(target, src, mergeArray = false) {
  let target_ = target;
  const src_ = src;
  const array = Array.isArray(src_);
  let dst = array && [] || {};
  if (array && Array.isArray(src_)) {
    if (mergeArray) {
      target_ = target_ || [];
      dst = dst.concat(target_);
      src_.forEach((e, i) => {
        if (typeof dst[i] === "undefined") {
          dst[i] = e;
        } else if (typeof e === "object") {
          dst[i] = deepmerge(target_[i], e, mergeArray);
        } else {
          if (target_.indexOf(e) === -1) {
            dst.push(e);
          }
        }
      });
    } else {
      dst = src_;
    }
  } else {
    if (target_ && typeof target_ === "object") {
      Object.keys(target_).forEach(function(key) {
        dst[key] = target_[key];
      });
    }
    Object.keys(src_).forEach(function(key) {
      if (typeof src_[key] !== "object" || !src_[key]) {
        dst[key] = src_[key];
      } else {
        if (typeof target_[key] === "object" && typeof src_[key] === "object") {
          dst[key] = deepmerge(target_[key], src_[key], mergeArray);
        } else {
          dst[key] = src_[key];
        }
      }
    });
  }
  return dst;
}

function defined(val) {
  return val !== void 0 && val !== null;
}

function deprecatedMapClick(ev) {
  if (!ev.lngLat && ev.latLng) {
    debugLog("deprecated use of latLng in MapClickEvent, use lngLat instead");
    const lat = ev.latLng.lat;
    const lng = ev.latLng.lng;
    ev.lngLat = [lng, lat];
  }
  return ev;
}

function checkExtent(extent) {
  const [minLon, minLat, maxLon, maxLat] = extent;
  const isOrderValid = minLon < maxLon && minLat < maxLat;
  if (!isOrderValid) {
    console.log("Error: The extent coordinates are not in the correct order.");
    console.log(
      `Received extent: [${minLon}, ${minLat}, ${maxLon}, ${maxLat}]`
    );
    const correctedExtent = [
      Math.min(minLon, maxLon),
      Math.min(minLat, maxLat),
      Math.max(minLon, maxLon),
      Math.max(maxLat, minLat)
    ];
    console.log(`Expected order: [${correctedExtent.join(", ")}]`);
  }
  const isValidLon = minLon >= -180 && maxLon <= 180;
  const isValidLat = minLat >= -90 && maxLat <= 90;
  if (!isValidLon || !isValidLat) {
    console.log(
      "Warning: The coordinates may not be within valid geographic ranges."
    );
  }
  return isOrderValid && isValidLon && isValidLat;
}

function getBoundsPolygon(b) {
  const polygon = {
    type: "Polygon",
    coordinates: [getBoundsCoordinates(b)]
  };
  return polygon;
}
function getBoundsCoordinates(b) {
  const westNorth = [b[0], b[1]];
  const eastNorth = [b[2], b[1]];
  const eastSouth = [b[2], b[3]];
  const westSouth = [b[0], b[3]];
  return [westNorth, eastNorth, eastSouth, westSouth, westNorth];
}
function getBoundsFeature(b) {
  const feature = {
    type: "Feature",
    properties: {},
    geometry: getBoundsPolygon(b)
  };
  return feature;
}

function findMostFrequentGeomType(arr) {
  const counts = {};
  for (let fry = 0; fry < arr.length; fry++) {
    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);
  }
  let maxName;
  for (const c in counts) {
    const count = maxName !== void 0 ? counts[maxName] : 0;
    if (counts[c] > (count || 0)) {
      maxName = c;
    }
  }
  return maxName;
}
function detectGeometryType(geojson) {
  let geometry;
  if (geojson.type === "FeatureCollection") {
    const featuresTypes = geojson.features.map(
      (f) => f.geometry.type
    );
    geometry = findMostFrequentGeomType(featuresTypes);
  } else if (geojson.type === "GeometryCollection") {
    const geometryTypes = geojson.geometries.map(
      (g) => g.type
    );
    geometry = findMostFrequentGeomType(geometryTypes);
  } else if (geojson.type === "Feature") {
    geometry = geojson.geometry.type;
  } else {
    geometry = geojson.type;
  }
  return geometry;
}

const paintTypeAlias = {
  polygon: "path",
  line: "path",
  point: "circle"
};
const typeAlias = {
  Point: "point",
  LineString: "line",
  MultiPoint: "point",
  Polygon: "polygon",
  MultiLineString: "line",
  MultiPolygon: "polygon"
};
function updateGeoJsonAdapterOptions(opt) {
  if (opt.data) {
    const geomType = typeAlias[detectGeometryType(opt.data)];
    const p = opt.paint;
    if (p && isPaint(p)) {
      p.type = p.type ? p.type : geomType === "polygon" || geomType === "line" ? "path" : "html" in p || "className" in p ? "icon" : paintTypeAlias[geomType];
    }
    opt.type = opt.type || geomType;
  }
  return opt;
}

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active) ;
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

var __defProp$8 = Object.defineProperty;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$8 = (obj, key, value) => __defNormalProp$8(obj, typeof key !== "symbol" ? key + "" : key, value);
class KeyCodes {
  constructor() {
    __publicField$8(this, "backspace", 8);
    __publicField$8(this, "tab", 9);
    __publicField$8(this, "enter", 13);
    __publicField$8(this, "shift", 16);
    __publicField$8(this, "ctrl", 17);
    __publicField$8(this, "alt", 18);
    __publicField$8(this, "pause/break", 19);
    __publicField$8(this, "caps_lock", 20);
    __publicField$8(this, "escape", 27);
    __publicField$8(this, "page_up", 33);
    __publicField$8(this, "page_down", 34);
    __publicField$8(this, "end", 35);
    __publicField$8(this, "home", 36);
    __publicField$8(this, "left_arrow", 37);
    __publicField$8(this, "up_arrow", 38);
    __publicField$8(this, "right_arrow", 39);
    __publicField$8(this, "down_arrow", 40);
    __publicField$8(this, "insert", 45);
    __publicField$8(this, "delete", 46);
    __publicField$8(this, "left_window_key", 91);
    __publicField$8(this, "right_window_key", 92);
    __publicField$8(this, "select_key", 93);
    __publicField$8(this, "numpad_0", 96);
    __publicField$8(this, "numpad_1", 97);
    __publicField$8(this, "numpad_2", 98);
    __publicField$8(this, "numpad_3", 99);
    __publicField$8(this, "numpad_4", 100);
    __publicField$8(this, "numpad_5", 101);
    __publicField$8(this, "numpad_6", 102);
    __publicField$8(this, "numpad_7", 103);
    __publicField$8(this, "numpad_8", 104);
    __publicField$8(this, "numpad_9", 105);
    __publicField$8(this, "multiply", 106);
    __publicField$8(this, "add", 107);
    __publicField$8(this, "subtract", 109);
    __publicField$8(this, "decimal_point", 110);
    __publicField$8(this, "divide", 111);
    __publicField$8(this, "f1", 112);
    __publicField$8(this, "f2", 113);
    __publicField$8(this, "f3", 114);
    __publicField$8(this, "f4", 115);
    __publicField$8(this, "f5", 116);
    __publicField$8(this, "f6", 117);
    __publicField$8(this, "f7", 118);
    __publicField$8(this, "f8", 119);
    __publicField$8(this, "f9", 120);
    __publicField$8(this, "f10", 121);
    __publicField$8(this, "f11", 122);
    __publicField$8(this, "f12", 123);
    __publicField$8(this, "num_lock", 144);
    __publicField$8(this, "scroll_lock", 145);
    __publicField$8(this, "semi-colon", 186);
    __publicField$8(this, "equal_sign", 187);
    __publicField$8(this, ",", 188);
    // "comma";
    __publicField$8(this, "-", 189);
    // "dash";
    __publicField$8(this, ".", 190);
    // "period";
    __publicField$8(this, "/", 191);
    // "forward slash";
    __publicField$8(this, "`", 192);
    // "grave accent";
    __publicField$8(this, "[", 219);
    // "open bracket";
    __publicField$8(this, "\\", 220);
    // "back slash";
    __publicField$8(this, "]", 221);
    // "close braket";
    __publicField$8(this, "'", 222);
  }
  // "single quote"
}

var __defProp$7 = Object.defineProperty;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$7 = (obj, key, value) => __defNormalProp$7(obj, typeof key !== "symbol" ? key + "" : key, value);
class Keys {
  constructor() {
    __publicField$7(this, "keyCodeAlias", new KeyCodes());
    __publicField$7(this, "keys", {});
    __publicField$7(this, "_windowOnFocus");
    __publicField$7(this, "_keysPressed");
    __publicField$7(this, "_keysReleased");
    this._windowOnFocus = this.windowOnFocus.bind(this);
    this._keysPressed = this.keysPressed.bind(this);
    this._keysReleased = this.keysReleased.bind(this);
    this.addKeyboardEventsListener();
  }
  pressed(keyName) {
    const code = this.keyCodeAlias[keyName];
    return !!code && this.keys[code];
  }
  addKeyboardEventsListener() {
    if (typeof window !== "undefined") {
      window.addEventListener("focus", this._windowOnFocus, false);
      window.addEventListener("keydown", this._keysPressed, false);
      window.addEventListener("keyup", this._keysReleased, false);
    }
  }
  removeKeyboardEventsListener() {
    if (typeof window !== "undefined") {
      window.removeEventListener("focus", this._windowOnFocus, false);
      window.removeEventListener("keydown", this._keysPressed, false);
      window.removeEventListener("keyup", this._keysReleased, false);
    }
  }
  keysPressed(e) {
    e.stopPropagation();
    if (!this.keys[e.keyCode]) {
      this.keys[e.keyCode] = true;
    }
  }
  keysReleased(e) {
    e.stopPropagation();
    this.keys[e.keyCode] = false;
  }
  windowOnFocus() {
    this.keys = {};
  }
}

var __defProp$6 = Object.defineProperty;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$6 = (obj, key, value) => __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
class StateItem {
  constructor(webMap, opt) {
    this.webMap = webMap;
    __publicField$6(this, "name");
    __publicField$6(this, "event");
    __publicField$6(this, "value");
    if (opt) {
      if (opt.value) {
        this.setValue(opt.value);
      }
      if (opt.name) {
        this.name = opt.name;
      }
      if (opt.event) {
        if (typeof opt.event === "string") {
          this.event = [opt.event];
        } else {
          this.event = opt.event;
        }
      }
    }
  }
  getValue() {
    return this.value;
  }
  setValue(val) {
    this.value = val;
  }
}

var __defProp$5 = Object.defineProperty;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$5 = (obj, key, value) => __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
class BoundState extends StateItem {
  constructor() {
    super(...arguments);
    __publicField$5(this, "name", "bounds");
    __publicField$5(this, "event", ["moveend"]);
  }
  getValue() {
    return this.webMap.getBounds();
  }
  setValue(bounds) {
    this.webMap.setView({ bounds });
  }
  toString() {
    const data = this.getValue();
    if (data) {
      return data.slice(0, 4).map((x) => x.toFixed(5)).join("_");
    }
    return void 0;
  }
  parse(str) {
    const lngLat = str.split("_").map(Number);
    return lngLat;
  }
}

var __defProp$4 = Object.defineProperty;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$4 = (obj, key, value) => __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
class CenterState extends StateItem {
  constructor() {
    super(...arguments);
    __publicField$4(this, "name", "center");
    __publicField$4(this, "event", ["moveend"]);
  }
  getValue() {
    return this.webMap.getCenter();
  }
  setValue(val) {
    this.webMap.setCenter(val);
  }
  toString() {
    const data = this.getValue();
    if (data) {
      const d = data.map((x) => x.toFixed(5));
      return d[0] + "_" + d[1];
    }
    return "";
  }
  parse(str) {
    const lngLat = str.split("_").map(Number);
    return lngLat;
  }
}

var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
class ZoomState extends StateItem {
  constructor() {
    super(...arguments);
    __publicField$3(this, "name", "zoom");
    __publicField$3(this, "event", ["zoomend"]);
  }
  getValue() {
    const zoom = this.webMap.getZoom();
    return zoom !== void 0 ? Math.round(zoom) : void 0;
  }
  setValue(val) {
    this.webMap.setZoom(val);
  }
  toString() {
    return String(this.getValue());
  }
  parse(str) {
    return Number(str);
  }
}

function clearObject(obj) {
  for (const member in obj) {
    delete obj[member];
  }
}

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async$4 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
let ID = 0;
const OPTIONS = {
  minZoom: 0,
  maxZoom: 22,
  paint: {
    color: "#0000ff",
    // blue
    opacity: 0.4,
    strokeOpacity: 1,
    stroke: true,
    radius: 8,
    weight: 1
  },
  selectedPaint: {
    color: "#00008b",
    // darkblue
    opacity: 0.4,
    strokeOpacity: 1,
    stroke: true,
    radius: 12,
    weight: 1
  },
  create: true
};
const _WebMapMain = class _WebMapMain {
  constructor(mapOptions) {
    __publicField$2(this, "options", OPTIONS);
    // `WebMapEvents` must be `E` but its not work correct
    __publicField$2(this, "emitter", new EventEmitter());
    __publicField$2(this, "keys", _WebMapMain.keys);
    __publicField$2(this, "mapAdapter");
    __publicField$2(this, "runtimeParams", []);
    __publicField$2(this, "getPaintFunctions", _WebMapMain.getPaintFunctions);
    __publicField$2(this, "mapStateItems", [CenterState, ZoomState, BoundState]);
    __publicField$2(this, "id", ID++);
    /**
     * From runtime params
     */
    __publicField$2(this, "mapState", []);
    __publicField$2(this, "_initMapState", {});
    __publicField$2(this, "_starterKits");
    __publicField$2(this, "_extent");
    __publicField$2(this, "_eventsStatus", {});
    __publicField$2(this, "_coordFromMapClickAbort");
    __publicField$2(this, "_mapEvents", {});
    this.mapAdapter = mapOptions.mapAdapter;
    this._starterKits = mapOptions.starterKits || [];
    if (mapOptions) {
      this.options = deepmerge(OPTIONS || {}, mapOptions);
    }
    if (this.options.runtimeParams) {
      this.runtimeParams = this.options.runtimeParams;
    }
    this._addEventsListeners();
    if (this.options.tileJson) {
      this._setTileJsonOptions(this.options.tileJson);
    }
    if (this.options.create) {
      this.create();
    }
  }
  getId() {
    return this.id;
  }
  /**
   * Manual way to create a map (If {@link MapOptions.create} is `false`).
   * @example
   * ```javascript
   * const webMap = new WebMap(options);
   * webMap.create().then(() => doSomething());
   * ```
   */
  create() {
    return __async$4(this, null, function* () {
      if (!this.getEventStatus("create")) {
        yield this._setInitMapState(this.mapStateItems);
        yield this._setupMap();
        this._emitStatusEvent("create", this);
      }
      return this;
    });
  }
  setRuntimeParams(params) {
    this.runtimeParams.push(params);
  }
  /**
   * Destroys WebMap, MapAdapter, clears all layers and turn off all event listeners
   */
  destroy() {
    this._removeEventListeners();
    clearObject(this._emitStatusEvent);
    if (this.mapAdapter.destroy) {
      this.mapAdapter.destroy();
    }
  }
  mapStateWithFunc(func) {
    const state = {};
    this.mapState.forEach((x) => {
      state[x.name] = func(x);
    });
    return state;
  }
  getStateAsString() {
    return this.mapStateWithFunc((x) => x.toString());
  }
  getState() {
    return this.mapStateWithFunc((x) => x.getValue());
  }
  getRuntimeParams() {
    const state = {};
    this.mapState.forEach((x) => {
      for (const r of this.runtimeParams) {
        const val = r.get(x.name);
        if (val !== void 0) {
          state[x.name] = x.parse(val);
          break;
        }
      }
    });
    return state;
  }
  /**
   * Returns the HTML element that contains the map.
   * @returns The map's container
   */
  getContainer() {
    if (this.mapAdapter.getContainer) {
      return this.mapAdapter.getContainer();
    } else if (this.options.target) {
      if (this.options.target instanceof HTMLElement) {
        return this.options.target;
      } else if (typeof this.options.target === "string") {
        const element = document.getElementById(this.options.target);
        if (element) {
          return element;
        }
      }
    }
  }
  /**
   * Set the cursor icon to be displayed when hover icon on the map container.
   * @param cursor - Available cursor name from https://developer.mozilla.org/ru/docs/Web/CSS/cursor
   */
  setCursor(cursor) {
    this.onLoad().then(() => {
      if (this.mapAdapter.setCursor) {
        this.mapAdapter.setCursor(cursor);
      }
    });
  }
  getCursor() {
    if (this.mapAdapter.getCursor) {
      return this.mapAdapter.getCursor();
    }
    const container = this.getContainer();
    if (container) {
      return container.style.cursor;
    }
  }
  /**
   * Set the center of the current view.
   * @param lngLat - Array of two numbers representing longitude and latitude of the center of the map view.
   *
   * @example
   * ```javascript
   * // Mount Everest 27 59 17 N, 86 55 31 E
   * webMap.setCenter([86.925278, 27.988056]);
   * ```
   */
  setCenter(lngLat) {
    this.mapAdapter.setCenter(lngLat);
    return this;
  }
  /**
   * Returns the map's geographical centerpoint.
   * @returns lngLat Array of two numbers representing longitude and latitude of the center of the map view.
   *
   * @example
   * ```javascript
   * // Mount Everest 27 59 17 N, 86 55 31 E
   * webMap.getCenter(); // [86.925278, 27.988056]
   * ```
   */
  getCenter() {
    return this.mapAdapter.getCenter();
  }
  getBounds() {
    if (this.mapAdapter.getBounds) {
      return this.mapAdapter.getBounds();
    }
  }
  getBoundsPolygon() {
    const bounds = this.getBounds();
    if (bounds) {
      const feature = getBoundsFeature(bounds);
      return feature;
    }
  }
  /**
   * Zoom to a specific zoom level.
   * @param zoom - The zoom level to set (0-24).
   */
  setZoom(zoom) {
    this.mapAdapter.setZoom(zoom);
    return this;
  }
  /**
   * Returns the map's current zoom level.
   * @returns The map's current zoom level (0-24).
   */
  getZoom() {
    const zoom = this.mapAdapter.getZoom();
    if (typeof zoom === "number") {
      return zoom;
    }
  }
  zoomIn() {
    if (this.mapAdapter.zoomIn) {
      this.mapAdapter.zoomIn();
    } else {
      const zoom = this.getZoom();
      if (zoom !== void 0) {
        const toZoom = zoom + 1;
        this.setZoom(toZoom);
      }
    }
  }
  zoomOut() {
    if (this.mapAdapter.zoomOut) {
      this.mapAdapter.zoomOut();
    } else {
      const zoom = this.getZoom();
      if (zoom !== void 0) {
        const toZoom = zoom - 1;
        this.setZoom(toZoom);
      }
    }
  }
  setView(lngLatOrOpt, zoom) {
    if (Array.isArray(lngLatOrOpt)) {
      const lngLat = lngLatOrOpt;
      if (this.mapAdapter.setView && lngLat && defined(zoom)) {
        this.mapAdapter.setView(lngLat, zoom);
      } else {
        if (lngLat) {
          this.mapAdapter.setCenter(lngLat);
        }
        if (defined(zoom)) {
          this.mapAdapter.setZoom(zoom);
        }
      }
    } else {
      const viewOpt = lngLatOrOpt;
      if (this.mapAdapter.setView) {
        this.mapAdapter.setView(viewOpt);
      }
    }
  }
  /**
   * Sets a map view that contains the given geographical bounds.
   * @param bounds - Array of coordinates, measured in degrees, in [west, south, east, north] order.
   *
   * @example
   * ```javascript
   * // Whole world
   * webMap.fitBounds([0, -90, 180, 90]);
   * ```
   */
  fitBounds(bounds, options) {
    checkExtent(bounds);
    if (bounds.every((x) => defined(x))) {
      if (bounds[1] < -85.06) {
        bounds[1] = -85.06;
      }
      if (bounds[3] > 85.06) {
        bounds[3] = 85.06;
      }
      this.mapAdapter.fitBounds(bounds, options);
    }
    return this;
  }
  /**
   * Checking the status of any asynchronous operation
   * @param event - The name of the event whose status is checked
   *
   * @example
   * ```javascript
   * var webMap = new WebMap(options);
   * webMap.getEventStatus('create'); // false
   * webMap.emitter.on('create', function () {
   *   webMap.getEventStatus('create'); // true
   * })
   * ```
   */
  getEventStatus(event) {
    const _eventName = event;
    const status = this._eventsStatus[_eventName];
    return status != null ? status : false;
  }
  /**
   * helper method to wait for events to load. By default, card creation is tracked
   * @param event - The name of the event whose status is checked
   *
   * @example
   * ```javascript
   * var webMap = new WebMap(options);
   * webMap.onLoad().then(function () {
   *   webMap.getEventStatus('create'); // true
   * })
   *
   * // use async/await syntax
   * async function () {
   *   await webMap.onLoad();
   *   doSomething();
   * }
   *
   * ```
   */
  onLoad(event = "create") {
    return new Promise((res) => {
      if (this.getEventStatus(event)) {
        res(this);
      } else {
        this.emitter.once(event, () => {
          res(this);
        });
      }
    });
  }
  onMapLoad(cb) {
    return new Promise((res) => {
      var _a;
      const _resolve = () => {
        const mapAdapter = this.mapAdapter;
        if (cb) {
          cb(mapAdapter);
        }
        if (mapAdapter) {
          res(mapAdapter);
        }
      };
      const isLoaded = (_a = this.mapAdapter.isLoaded) != null ? _a : true;
      if (this.mapAdapter.map && isLoaded) {
        _resolve();
      } else {
        this.mapAdapter.emitter.once("create", () => {
          _resolve();
        });
      }
    });
  }
  getLayerAdapters() {
    return this.mapAdapter.layerAdapters;
  }
  getLayerAdapter(name) {
    const adapter = this.mapAdapter.layerAdapters[name];
    return adapter;
  }
  locate(opt, events) {
    if (this.mapAdapter && this.mapAdapter.locate) {
      return this.mapAdapter.locate(opt, events);
    }
    const stop = () => ({});
    return { stop };
  }
  stopGetCoordFromMapClick() {
    if (this._coordFromMapClickAbort) {
      this._coordFromMapClickAbort();
      this._coordFromMapClickAbort = void 0;
    }
  }
  getCoordFromMapClick() {
    if (!this._coordFromMapClickAbort) {
      return new Promise((resolve, reject) => {
        const cursor = this.getCursor() || "grab";
        this._removeEventListeners({ include: ["click"] });
        this.setCursor("crosshair");
        const onCancel_ = () => {
          this.setCursor(cursor);
          this._addEventsListeners({ include: ["click"] });
          this.mapAdapter.emitter.off("click", onMapClick);
          this._coordFromMapClickAbort = void 0;
        };
        const onMapClick = (e) => {
          onCancel_();
          deprecatedMapClick(e);
          resolve(e.lngLat);
        };
        this.mapAdapter.emitter.once("click", onMapClick);
        this._coordFromMapClickAbort = onCancel_;
      });
    } else {
      return this.getCoordFromMapClick();
    }
  }
  _emitStatusEvent(eventName, data) {
    const _eventName = eventName;
    this._eventsStatus[_eventName] = true;
    this.emitter.emit(_eventName, data);
  }
  _addLayerProviders() {
    return __async$4(this, null, function* () {
    });
  }
  _onLoadSync() {
    return __async$4(this, null, function* () {
    });
  }
  _setupMap() {
    return __async$4(this, null, function* () {
      if (!this.mapAdapter) {
        throw new Error("WebMap `mapAdapter` option is not set");
      }
      yield this.mapAdapter.create(this.options);
      this._zoomToInitialExtent();
      yield this._addLayerProviders();
      yield this._onLoadSync();
      this._emitStatusEvent("build-map", this.mapAdapter);
      return this;
    });
  }
  _setTileJsonOptions(tileJson) {
    if (tileJson.center) {
      this.options.center = tileJson.center;
    }
    if (tileJson.bounds) {
      this.options.bounds = tileJson.bounds;
    }
    if (defined(tileJson.maxzoom)) {
      this.options.zoom = tileJson.maxzoom;
    }
    if (defined(tileJson.minzoom)) {
      this.options.zoom = tileJson.minzoom;
    }
    if (defined(tileJson.maxzoom) && defined(tileJson.minzoom)) {
      this.options.zoom = (tileJson.maxzoom + tileJson.minzoom) / 2;
    }
  }
  _zoomToInitialExtent() {
    const { center, zoom, bounds } = this.options;
    if (this._extent) {
      this.fitBounds(this._extent);
    } else if (center && zoom) {
      this.setView(center, zoom);
    } else if (bounds) {
      this.fitBounds(bounds);
      if (zoom !== void 0) {
        this.setZoom(zoom);
      }
    }
  }
  _setInitMapState(states) {
    for (const X of states) {
      const state = new X(this);
      this.mapState.push(state);
      for (const r of this.runtimeParams) {
        const str = r.get(state.name);
        if (str !== void 0) {
          const val = state.parse(str);
          this._initMapState[state.name] = val;
          Object.defineProperty(this.options, state.name, {
            value: val,
            configurable: true,
            enumerable: true
          });
          break;
        }
      }
    }
  }
  _addEventsListeners(opt) {
    let events = [
      "preclick",
      "click",
      "zoomstart",
      "zoom",
      "zoomend",
      "movestart",
      "move",
      "moveend",
      "mousemove",
      "mouseout",
      "mouseover"
    ];
    if (opt && opt.include) {
      events = events.filter((x) => opt.include.includes(x));
    }
    events.forEach((x) => {
      this._mapEvents[x] = (data) => {
        if (this.runtimeParams.length) {
          const mapStatusEvents = this.mapState.filter(
            (y) => y.event.includes(x)
          );
          mapStatusEvents.forEach((mapStatusEvent) => {
            const value = mapStatusEvent.toString();
            this.runtimeParams.forEach((r) => {
              r.set(mapStatusEvent.name, value);
            });
          });
        }
        if (this._eventsStatus) {
          this.emitter.emit(x, data);
        }
      };
      const mapEvent = this._mapEvents[x];
      if (mapEvent) {
        this.mapAdapter.emitter.on(x, mapEvent);
      }
    });
  }
  _removeEventListeners(opt) {
    let events = Object.entries(this._mapEvents);
    if (opt && opt.include) {
      events = events.filter((x) => opt.include.includes(x[0]));
    }
    events.forEach(([x, event]) => {
      if (event) {
        this.mapAdapter.emitter.removeListener(x, event);
      }
    });
  }
};
__publicField$2(_WebMapMain, "keys", new Keys());
__publicField$2(_WebMapMain, "getPaintFunctions");
let WebMapMain = _WebMapMain;

var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async$3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class WebMapLayers extends WebMapMain {
  constructor(mapOptions) {
    super(mapOptions);
    __publicField$1(this, "_layersIdCounter", 1);
    __publicField$1(this, "_layersOrderCounter", 1);
    __publicField$1(this, "_baselayers", []);
    __publicField$1(this, "_layers", {});
    __publicField$1(this, "_selectedLayers", []);
    const tileJson = this.options.tileJson;
    if (tileJson) {
      this.emitter.once("build-map", () => this.addTileJsonLayer(tileJson));
    }
  }
  /**
   * Try to fit map view by given layer bounds.
   * But not all layers have borders
   */
  fitLayer(layerDef, options) {
    return __async$3(this, null, function* () {
      const layer = this.getLayer(layerDef);
      const getBounds = layer && (layer.getBounds || layer.getExtent);
      if (getBounds) {
        const extent = yield getBounds.call(layer);
        if (extent) {
          this.fitBounds(extent, options);
        }
      }
    });
  }
  /**
   * Check if given layer is baselayer
   */
  isBaseLayer(layerDef) {
    const layer = this.getLayer(layerDef);
    if (layer && layer.id) {
      return this._baselayers.indexOf(layer.id) !== -1;
    }
    return void 0;
  }
  getBaseLayers() {
    const baselayers = [];
    this._baselayers.forEach((x) => {
      const baselayer = this._layers[x];
      if (baselayer) {
        baselayers.push(baselayer);
      }
    });
    return baselayers;
  }
  getBaseLayersIds() {
    return this._baselayers;
  }
  /**
   * Helper method to return added layer object by any definition type.
   */
  getLayer(layerDef) {
    if (typeof layerDef === "string") {
      return this._layers[layerDef];
    }
    return layerDef;
  }
  /**
   * Helper method to return added layer identificator by any definition type.
   */
  getLayerId(layerDef) {
    const layer = this.getLayer(layerDef);
    if (layer) {
      if (layer.id) {
        return layer == null ? void 0 : layer.id;
      }
      if (layer && layer.options) {
        return layer.options.id;
      }
    }
    throw new Error("No id for layer");
  }
  /**
   * Return array of all added layer identifications.
   */
  getLayers() {
    return Object.keys(this._layers);
  }
  // TODO: rename to getLayers, getLayers rename to getLayersIds
  allLayers() {
    return this._layers;
  }
  orderedLayers() {
    return Object.values(this._layers).sort(
      (a, b) => a.order && b.order ? a.order - b.order : 0
    );
  }
  findLayer(filter) {
    for (const l in this._layers) {
      const layerAdapter = this._layers[l];
      const isFit = filter(layerAdapter);
      if (isFit) {
        return layerAdapter;
      }
    }
  }
  /**
   * Check if the given layer on the map
   */
  isLayerVisible(layerDef) {
    const layer = this.getLayer(layerDef);
    return layer && layer.options.visibility !== void 0 ? layer.options.visibility : false;
  }
  /**
   * Shortcut method to create base layer
   */
  addBaseLayer(adapter, options) {
    return __async$3(this, null, function* () {
      const layer = yield this.addLayer(
        adapter,
        __spreadProps(__spreadValues({}, options), {
          baselayer: true
        }),
        void 0
      );
      return layer;
    });
  }
  /**
   * Registration of map layer.
   *
   * @param adapter - The name of layer adapter from [MapAdapter.layerAdapters](webmap#MapAdapter.layerAdapters).
   *                May be custom object or class implemented by [MainLayerAdapter](webmap#MainLayerAdapter).
   * @param options - Specific options for given adapter
   *
   * @example
   * ```javascript
   * webMap.addLayer('TILE', options).then((layer) => webMap.showLayer(layer));
   *
   * webMap.addLayer(CustomLayerAdapter, options);
   * ```
   */
  addLayer(_0) {
    return __async$3(this, arguments, function* (adapter, options = {}, order) {
      var _a, _b;
      const id = this._layersIdCounter++;
      const _order = defined(order) ? order : options.order !== void 0 ? options.order : this.reserveOrder();
      let adapterEngine;
      if (typeof adapter === "string") {
        adapterEngine = this.getLayerAdapter(adapter);
      } else if (typeof adapter === "function") {
        adapterEngine = adapter;
      } else if ("then" in adapter) {
        adapterEngine = yield adapter;
      }
      const geoJsonOptions = options;
      this._updateGeoJsonOptions(geoJsonOptions);
      options = __spreadValues({
        id: String(id),
        order: _order
      }, options);
      const visibility = (_a = options.visibility) != null ? _a : true;
      options.visibility = false;
      if (options.baselayer) {
        options.order = 0;
      }
      if (this.options.onBeforeAddLayer) {
        const modified = this.options.onBeforeAddLayer({
          options,
          adapter: adapterEngine
        });
        if (modified) {
          if (modified.options) {
            options = modified.options;
          }
          if (modified.adapter) {
            adapterEngine = modified.adapter;
          }
        }
      }
      if (adapterEngine !== void 0) {
        const _adapter = new adapterEngine(this.mapAdapter.map, options);
        _adapter.options = __spreadValues(__spreadValues({}, options), _adapter.options);
        if (_adapter.options.baselayer) {
          options.baselayer = true;
          options.order = 0;
          _adapter.options.order = 0;
        }
        let layerId;
        if (_adapter.options.id) {
          layerId = String(_adapter.options.id);
          this._layers[layerId] = _adapter;
        }
        this._emitLayerEvent("layer:preadd", layerId || "", _adapter);
        yield this.onMapLoad();
        _adapter.map = this.mapAdapter.map;
        const layer = yield _adapter.addLayer(_adapter.options);
        _adapter.layer = layer;
        _adapter.id = _adapter.options.id || String(id);
        _adapter.options.id = _adapter.id;
        if (options.baselayer) {
          _adapter.options.order = 0;
        }
        _adapter.order = (_b = _adapter.options.order) != null ? _b : _order;
        if (layerId) {
          delete this._layers[layerId];
        }
        layerId = String(_adapter.id);
        if (this._layers[layerId]) {
          throw Error(`layer with id '${layerId}' already exist`);
        }
        if (layerId) {
          this._layers[layerId] = _adapter;
          if (geoJsonOptions.filter) {
            this.filterLayer(_adapter, geoJsonOptions.filter);
          }
          if (options.baselayer) {
            this._baselayers.push(layerId);
          }
          if (visibility) {
            yield this.showLayer(layerId);
          }
        }
        const opacity = options.opacity;
        if (opacity !== void 0 && opacity !== null && opacity <= 1) {
          this.setLayerOpacity(_adapter, opacity);
        }
        const getBounds = layer && (_adapter.getBounds || _adapter.getExtent);
        if (options.fit && getBounds) {
          const extent = yield getBounds.call(_adapter);
          if (extent) {
            yield this.fitBounds(extent);
          }
        }
        if (options.onAdded) {
          options.onAdded(_adapter);
        }
        this._emitLayerEvent("layer:add", layerId, _adapter);
        return _adapter;
      }
      return Promise.reject("No adapter");
    });
  }
  addLayerFromAsyncAdapter(adapter, options, order) {
    return __async$3(this, null, function* () {
      const _order = order || options.order !== void 0 ? options.order : this.reserveOrder();
      const adapterConstructor = adapter;
      const adapterConstructorPromise = adapterConstructor();
      const adapterEngine = yield adapterConstructorPromise;
      if (adapterEngine) {
        return this.addLayer(adapterEngine, options, _order);
      }
      return Promise.reject("No adapter");
    });
  }
  /**
   * Remove all layer from map and memory.
   */
  removeLayers(allowCb) {
    for (const l in this._layers) {
      let allow = true;
      if (allowCb) {
        allow = allowCb(l, this._layers[l]);
      }
      if (allow) {
        this.removeLayer(l);
        delete this._layers[l];
      }
    }
  }
  getLegend(options) {
    return __async$3(this, null, function* () {
      const promises = [];
      for (const l of this.orderedLayers()) {
        if (l.getLegend) {
          promises.push(l.getLegend(options));
        }
      }
      return (yield Promise.all(promises)).flat();
    });
  }
  reserveOrder() {
    return this._layersOrderCounter++;
  }
  /**
   * Remove all layers but not remove basemap.
   */
  removeOverlays() {
    this.removeLayers((layerId, layer) => {
      if (layer && layer.options && layer.options.baselayer) {
        return false;
      }
      return true;
    });
  }
  /**
   * Remove specific layer from map and memory by its definition.
   */
  removeLayer(layerDef) {
    const layer = this.getLayer(layerDef);
    const layerId = layer && this.getLayerId(layer);
    if (layer && layerId) {
      this.emitter.emit("layer:preremove", layer);
      if (layer.beforeRemove) {
        layer.beforeRemove();
      }
      if (layer.removeLayer) {
        layer.removeLayer();
      } else {
        this.mapAdapter.removeLayer(layer.layer);
      }
      if (layer.options && layer.options.baselayer) {
        const index = this._baselayers.indexOf(layerId);
        if (index) {
          this._baselayers.splice(index, 1);
        }
      }
      delete this._layers[layerId];
      this.emitter.emit("layer:remove", layer);
    }
  }
  /**
   * Create layer from GeoJson data. Set style and behavior for selection.
   *
   * @example
   * ```javascript
   * // Add simple layer
   * webMap.addGeoJsonLayer({ data: geojson, paint: { color: 'red' } });
   *
   * // Add styled by feature property layer with selection behavior
   * webMap.addGeoJsonLayer({
   *   data: geojson,
   *   paint: function (feature) {
   *     return { color: feature.properties.color, opacity: 0.5 }
   *   },
   *  selectedPaint: function (feature) {
   *    return { color: feature.properties.selcolor, opacity: 1 }
   *  },
   *  selectable: true,
   *  multiselect: true
   * });
   *
   * // Add marker layer styled with use [Icons](icons)
   * webMap.addGeoJsonLayer({ data: geojson, paint: webMap.getIcon({ color: 'orange' })});
   *
   * // work with added layer
   * const layer = webMap.addGeoJsonLayer({ data: geojson, id: 'my_layer_name'});
   * // access layer by id
   * webMap.showLayer('my_layer_name');
   * // or access layer by instance
   * webMap.showLayer(layer);
   * ```
   */
  addGeoJsonLayer(opt = {}, adapter) {
    opt = opt || {};
    opt.multiselect = opt.multiselect !== void 0 ? opt.multiselect : false;
    opt.unselectOnSecondClick = opt.unselectOnSecondClick !== void 0 ? opt.unselectOnSecondClick : true;
    if (!adapter) {
      opt = updateGeoJsonAdapterOptions(opt);
    }
    opt.paint = opt.paint || {};
    return this.addLayer(adapter || "GEOJSON", opt);
  }
  /** Shortcut for {@link WebMapLayers.addGeoJsonLayer} to create GeoJson adapter with generic types for working in typescript */
  addFeatureLayer(options = {}) {
    return this.addGeoJsonLayer(options);
  }
  /** Shortcut for {@link WebMapLayers.addLayer} to create TileLayer adapter */
  addTileLayer(url, options = {}) {
    return this.addLayer("TILE", __spreadProps(__spreadValues({}, options), { url }));
  }
  addImageLayer(urlOrOptions, options) {
    let url;
    if (typeof urlOrOptions === "string") {
      url = urlOrOptions;
    } else {
      url = urlOrOptions.url;
      options = urlOrOptions;
    }
    return this.addLayer("IMAGE", __spreadProps(__spreadValues({}, options), { url }));
  }
  /**
   * Show added layer on the map by it definition.
   */
  showLayer(layerDef, options = {}) {
    return this.toggleLayer(layerDef, true, options);
  }
  /**
   * Hide added layer on the map by it definition.
   */
  hideLayer(layerDef, options = {}) {
    return this.toggleLayer(layerDef, false, options);
  }
  /**
   * Change added layer visibility on the map by given status or inverse current status.
   *
   * @example
   * ```javascript
   * webMap.addLayer('TILE', {id: 'my_layer', url: ''}).then((layer) => {
   *   webMap.toggleLayer(layer, true);
   *   webMap.toggleLayer('my_layer', false);
   *   webMap.toggleLayer('my_layer');
   *   webMap.isLayerVisible(layer); // true
   * });
   * ```
   */
  toggleLayer(layerDef, status, options = {}) {
    const layer = this.getLayer(layerDef);
    const onMap = layer && layer.options.visibility;
    const toStatus = status !== void 0 ? status : !onMap;
    const silent = options.silent !== void 0 ? options.silent : false;
    const action = (l) => __async$3(this, null, function* () {
      const id = String(l.id);
      const preEventName = toStatus ? "layer:preshow" : "layer:prehide";
      const eventName = toStatus ? "layer:show" : "layer:hide";
      if (!silent) {
        this._emitLayerEvent(preEventName, id, l);
        this._emitLayerEvent("layer:pretoggle", id, l);
      }
      if (toStatus && this.mapAdapter) {
        const order = l.options.baselayer ? 0 : l.options.order;
        if (l.options.baselayer && this._baselayers.length) {
          const anotherVisibleBaselayers = this._baselayers.filter((x) => {
            return x !== l.id && this.isLayerVisible(x);
          });
          for (const bl of anotherVisibleBaselayers) {
            yield this.hideLayer(bl);
          }
        }
        if (l.showLayer) {
          yield l.showLayer.call(l, l.layer);
        } else if (l.layer !== void 0) {
          yield this.mapAdapter.showLayer(l.layer);
        }
        if (order !== void 0) {
          this.mapAdapter.setLayerOrder(l.layer, order, this._layers);
        }
      } else {
        if (l.hideLayer) {
          yield l.hideLayer.call(l, l.layer);
        } else if (l.layer !== void 0) {
          yield this.mapAdapter.hideLayer(l.layer);
        }
      }
      l.options.visibility = toStatus;
      if (!silent) {
        this._emitLayerEvent(eventName, id, l);
        this._emitLayerEvent("layer:toggle", id, l);
      }
    });
    if (layer) {
      return this.onMapLoad().then(() => action(layer));
    }
    return Promise.resolve();
  }
  updateLayer(layerDef, options) {
    const layer = this.getLayer(layerDef);
    if (layer) {
      if (layer.updateLayer) {
        return Promise.resolve(layer.updateLayer(options));
      } else if (this.isLayerVisible(layer)) {
        return this.hideLayer(layer, { silent: true }).then(() => {
          return this.showLayer(layer, { silent: true });
        });
      }
    }
    return Promise.resolve();
  }
  /**
   * Set transparency for a given layer by number from 0 to 1
   */
  setLayerOpacity(layerDef, value) {
    const layer = this.getLayer(layerDef);
    if (layer) {
      if (layer.setOpacity) {
        layer.setOpacity(value);
      } else if (this.mapAdapter.setLayerOpacity) {
        this.mapAdapter.setLayerOpacity(layer.layer, value);
      }
    }
  }
  isLayerLabelVisible(layerDef) {
    var _a;
    const layer = this.getLayer(layerDef);
    if (layer.isLabelVisible) {
      return layer.isLabelVisible();
    }
    return (_a = layer.options.labelVisibility) != null ? _a : true;
  }
  showLayerLabel(layerDef) {
    this.toggleLayerLabel(layerDef, true);
  }
  hideLayerLabel(layerDef) {
    this.toggleLayerLabel(layerDef, false);
  }
  toggleLayerLabel(layerDef, status) {
    const layer = this.getLayer(layerDef);
    status = status != null ? status : !this.isLayerLabelVisible(layerDef);
    if (layer) {
      if (status) {
        if (layer.showLabel) {
          layer.options.labelVisibility = true;
          layer.showLabel();
        }
      } else {
        if (layer.hideLabel) {
          layer.options.labelVisibility = false;
          layer.hideLabel();
        }
      }
      if (layer.id) {
        this._emitLayerEvent("layer:label:toggle", layer.id, layer);
      }
    }
    return status;
  }
  /**
     * Mark the layer as selected.
     * If the adapter is a vector layer and supports data selection,
     * you can pass a callback function to specify which data will be selected.
     *
     * @example
     * ```javascript
     * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {
     *   webMap.selectLayer(layer, ({feature}) => feature.id === '42');
     * });
     * ```
  
     */
  selectLayer(layerDef, findFeatureFun) {
    const layer = this.getLayer(layerDef);
    if (layer) {
      const adapter = layer;
      if (adapter && adapter.select) {
        adapter.select(findFeatureFun);
      }
      const layerId = this.getLayerId(layer);
      if (layerId) {
        this._selectedLayers.push(layerId);
      }
    }
  }
  /**
   * Unselect the given layer.
   * If the adapter is a vector layer and supports data selection,
   * you can pass a callback function to specify which data will be unselected.
   *
   * @example
   * ```javascript
   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {
   *   webMap.unSelectLayer(layer, ({feature}) => feature.id === '42');
   * });
   * ```
   *
   */
  unSelectLayer(layerDef, findFeatureFun) {
    const layer = this.getLayer(layerDef);
    if (layer) {
      const adapter = layer && layer;
      if (adapter.unselect) {
        adapter.unselect(findFeatureFun);
      }
      const layerId = this.getLayerId(layer);
      if (layerId) {
        const index = this._selectedLayers.indexOf(layerId);
        if (index !== -1) {
          this._selectedLayers.splice(index, 1);
        }
      }
    }
  }
  /** Remove selection from any selected selectable layer */
  unSelectLayers() {
    const layers = Object.values(this.allLayers());
    let l;
    for (l of layers) {
      if (l.unselect) {
        l.unselect();
      }
    }
  }
  /**
   * Hide features from a vector layer using a callback function.
   *
   * @example
   * ```javascript
   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {
   *   webMap.filterLayer(layer, ({feature}) => feature.id === '42');
   * });
   * ```
   *
   */
  filterLayer(layerDef, filter) {
    const layer = this.getLayer(layerDef);
    const adapter = layer;
    if (adapter.filter) {
      return adapter.filter(filter);
    }
    return [];
  }
  propertiesFilter(layerDef, filters, options) {
    const layer = this.getLayer(layerDef);
    if (layer) {
      const adapter = layer;
      if (adapter.propertiesFilter) {
        return adapter.propertiesFilter(filters, options);
      } else if (adapter.filter) {
        this.filterLayer(adapter, (e) => {
          if (e.feature && e.feature.properties) {
            return propertiesFilter(e.feature.properties, filters);
          }
          return true;
        });
      }
    }
    return Promise.resolve();
  }
  removeLayerFilter(layerDef) {
    const layer = this.getLayer(layerDef);
    const adapter = layer;
    if (adapter.removeFilter) {
      adapter.removeFilter();
    } else if (adapter.filter) {
      adapter.filter(() => {
        return true;
      });
    }
  }
  /**
   * Sets the GeoJSON data for given vector layer.
   *
   * @example
   * ```javascript
   * const layer = webMap.addLayer('GEOJSON').then((layer) => {
   *   webMap.setLayerData(layer, geojson);
   * });
   * ```
   */
  setLayerData(layerDef, data) {
    const vectorAdapter = this.getLayer(layerDef);
    const adapter = vectorAdapter;
    if (adapter) {
      if (adapter.setData) {
        return adapter.setData(data);
      } else if (adapter.clearLayer && adapter.addData) {
        adapter.clearLayer();
        return adapter.addData(data);
      }
    }
    return Promise.resolve();
  }
  /**
   * Push new the GeoJSON features into given vector layer.
   *
   * @example
   * ```javascript
   * const layer = webMap.addLayer('GEOJSON', {data: geojson_features_5}).then((layer) => {
   *   console.log(layer.getLayers().length) // > 5;
   *   webMap.addLayerData(layer, geojson_features_3);
   *   console.log(layer.getLayers().length) // > 8;
   * });
   * ```
   */
  addLayerData(layerDef, data) {
    const layerMem = this.getLayer(layerDef);
    const adapter = layerMem;
    if (adapter.addData) {
      adapter.addData(data);
    }
  }
  /**
   * Remove from vector layer all features.
   * it is possible to remove only some objects if you specify a callback function.
   *
   * @example
   * ```javascript
   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {
   *   webMap.clearLayerData(layer, (feture) => feture.id === 42);
   *   webMap.clearLayerData(layer);
   * });
   * ```
   */
  clearLayerData(layerDef, cb) {
    const layerMem = this.getLayer(layerDef);
    const adapter = layerMem;
    if (adapter && adapter.clearLayer) {
      adapter.clearLayer(cb);
    }
  }
  setLayerPaint(layerDef, paint) {
    const layer = this.getLayer(layerDef);
    if (paint && layer && layer.setPaint) {
      layer.setPaint(paint);
    }
  }
  setLayerSelectedPaint(layerDef, paint) {
    const layer = this.getLayer(layerDef);
    if (paint && layer && layer.setSelectedPaint) {
      layer.setSelectedPaint(paint);
    }
  }
  updateLayerPaint(layerDef, paint) {
    const layer = this.getLayer(layerDef);
    if (paint && layer && layer.updatePaint) {
      layer.updatePaint(paint);
    }
  }
  updateLayerSelectedPaint(layerDef, paint) {
    const layer = this.getLayer(layerDef);
    if (paint && layer && layer.updateSelectedPaint) {
      layer.updateSelectedPaint(paint);
    }
  }
  getAttributions(options) {
    const attributions = [];
    for (const l in this._layers) {
      const layerCache = this._layers[l];
      const onlyVisible = options.onlyVisible !== void 0 ? options.onlyVisible : true;
      let useLayerAttr = onlyVisible ? layerCache.options.visibility : true;
      if (useLayerAttr && options.onlyBaselayer) {
        useLayerAttr = this._baselayers.includes(l);
      }
      if (useLayerAttr) {
        const attr = layerCache.options && layerCache.options.attribution;
        if (attr) {
          attributions.push(attr);
        }
      }
    }
    return attributions;
  }
  getActiveBaseLayer() {
    const visibleLayerBaseLayer = this.getBaseLayers().find((x) => {
      return this.isLayerVisible(x);
    });
    if (visibleLayerBaseLayer) {
      return this.getLayer(visibleLayerBaseLayer);
    }
  }
  addTileJsonLayer(tileJson) {
    const url = tileJson.tiles[0];
    return this.addLayer("TILE", {
      url,
      maxZoom: tileJson.maxzoom,
      minZoom: tileJson.minzoom,
      subdomains: tileJson.scheme,
      attribution: tileJson.attribution
    });
  }
  /** @internal */
  _emitLayerEvent(name, id, options) {
    const name_ = String(name);
    if (defined(id) && name_.startsWith("layer:")) {
      const specificLayerName = name_.replace("layer:", "layer-" + id + ":");
      this.emitter.emit(specificLayerName, options);
    }
    this.emitter.emit(name, options);
  }
  _onLayerClick(options) {
    return __async$3(this, null, function* () {
      const id = options.layer.id;
      this._emitLayerEvent("layer:click", id || "", options);
      return Promise.resolve(options);
    });
  }
  _onLayerDoubleClick(options) {
    return __async$3(this, null, function* () {
      const id = options.layer.id;
      this._emitLayerEvent("layer:dblclick", id || "", options);
      return Promise.resolve(options);
    });
  }
  _onLayerSelect(options) {
    return __async$3(this, null, function* () {
      this._emitLayerEvent("layer:select", options.layer.id || "", options);
      return Promise.resolve(options);
    });
  }
  _updateGeoJsonOptions(options) {
    const {
      onSelect,
      onLayerSelect,
      onClick,
      onDoubleClick,
      onLayerClick,
      onMouseOut,
      onMouseOver
    } = options;
    const onLayerClickFromOpt = onClick || onLayerClick;
    const onLayerDblClickFromOpt = onDoubleClick || onLayerClick;
    options.onClick = (e) => {
      if (onLayerClickFromOpt) {
        onLayerClickFromOpt(e);
      }
      return this._onLayerClick(e);
    };
    options.onDoubleClick = (e) => {
      if (onLayerDblClickFromOpt) {
        onLayerDblClickFromOpt(e);
      }
      return this._onLayerDoubleClick(e);
    };
    options.onMouseOut = (e) => {
      const id = e.layer.id;
      if (onMouseOut) onMouseOut(e);
      if (defined(id)) {
        this._emitLayerEvent(`layer:mouseout`, id, e);
      }
    };
    options.onMouseOver = (e) => {
      const id = e.layer.id;
      if (onMouseOver) onMouseOver(e);
      if (defined(id)) {
        this._emitLayerEvent(`layer:mouseover`, id, e);
      }
    };
    const onLayerSelectFromOpt = onSelect || onLayerSelect;
    options.onSelect = (e) => {
      if (onLayerSelectFromOpt) {
        onLayerSelectFromOpt(e);
      }
      return this._onLayerSelect(e);
    };
    if (!options.nativePaint) {
      if (this.options.paint) {
        options.paint = preparePaint({
          paint: options.paint || {},
          defaultPaint: this.options.paint,
          getPaintFunctions: this.getPaintFunctions
        });
      }
      if (options.selectedPaint && this.options.selectedPaint) {
        options.selectedPaint = preparePaint({
          paint: options.selectedPaint,
          defaultPaint: this.options.selectedPaint,
          getPaintFunctions: this.getPaintFunctions
        });
      }
    }
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async$2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const _WebMapControls = class _WebMapControls extends WebMapLayers {
  constructor() {
    super(...arguments);
    __publicField(this, "_loadControlQueue", {
      "top-right": [],
      "bottom-right": [],
      "top-left": [],
      "bottom-left": []
    });
    __publicField(this, "_isControlLoading", {
      "top-right": false,
      "bottom-right": false,
      "top-left": false,
      "bottom-left": false
    });
  }
  addControl(controlDef, position, options) {
    return __async$2(this, null, function* () {
      let control;
      position = position != null ? position : "top-left";
      if (typeof controlDef === "string") {
        control = this.getControl(controlDef, options);
      } else {
        control = controlDef;
      }
      if (control) {
        return new Promise((resolve) => {
          const promise = () => __async$2(this, null, function* () {
            const _control = yield control;
            const c = this.mapAdapter.addControl(_control, position);
            resolve(c);
          });
          this._setControlQueue(position, promise);
        });
      }
    });
  }
  /**
   * Creating a universal map layout control element. Can be used with any map adapter.
   *
   * @example
   * ```javascript
   * const control = webMap.createControl({
   *   onAdd() {
   *     return document.createElement('div');
   *   }
   * });
   * ```
   */
  createControl(control, options) {
    return __async$2(this, null, function* () {
      yield this.onLoad("build-map");
      if (this.mapAdapter.createControl) {
        return this.mapAdapter.createControl(control, options);
      }
    });
  }
  createButtonControl(options) {
    return __async$2(this, null, function* () {
      yield this.onLoad("build-map");
      if (this.mapAdapter.createButtonControl) {
        return this.mapAdapter.createButtonControl(options);
      }
    });
  }
  /**
   * Create any toggler control button
   * @param options - Options for control layout customization and assigning a callback function
   *
   * @example
   * ```javascript
   * const toggleControl = ngwMap.createToggleControl({
   *   getStatus: () => webMap.isLayerVisible('any-layer-id'),
   *   onClick: (status) => ngwMap.toggleLayer('webmap', status),
   *   html: {
   *     on: 'ON',
   *     off: 'OFF'
   *   },
   *   title: 'Toggle layer visibility'
   * });
   * webMap.addControl(toggleControl, 'top-right');
   * ```
   * {@link http://code.nextgis.com/demo-examples-toggle-control | Toggle button control example}
   */
  createToggleControl(options) {
    return __async$2(this, null, function* () {
      yield this.onLoad("build-map");
      if (this.mapAdapter.createToggleControl) {
        return this.mapAdapter.createToggleControl(options);
      } else {
        if (this.mapAdapter.createButtonControl) {
          return createToggleControl(
            this.mapAdapter.createButtonControl,
            options
          );
        }
      }
    });
  }
  /**
   *
   * @param control - Instance of WEB-GIS framework control.
   *                  What is returned by the {@link createControl | create} method
   */
  removeControl(control) {
    if ("remove" in control) {
      control.remove();
    } else if (this.mapAdapter.removeControl) {
      Promise.resolve(control).then((c) => {
        this.mapAdapter.removeControl(c);
      });
    }
  }
  /**
   * Get instance of registered control
   * @param control - Any registered control string name
   * @param options - Custom control options
   */
  getControl(control, options) {
    const engine = this.mapAdapter.controlAdapters[control];
    if (engine) {
      return new engine(options);
    } else {
      const createFun = _WebMapControls.controls[control];
      if (createFun) {
        return createFun(this, options);
      }
    }
  }
  getControlContainer() {
    if (this.mapAdapter.getControlContainer) {
      return this.mapAdapter.getControlContainer();
    }
  }
  _setControlQueue(position, cb) {
    this._loadControlQueue[position].push(cb);
    if (!this._isControlLoading[position]) {
      this._applyControls(position);
    }
  }
  _applyControls(position) {
    return __async$2(this, null, function* () {
      if (this._loadControlQueue[position].length) {
        this._isControlLoading[position] = true;
        const controlCb = this._loadControlQueue[position][0];
        yield controlCb();
        this._loadControlQueue[position].splice(0, 1);
        this._applyControls(position);
      } else {
        this._isControlLoading[position] = false;
      }
    });
  }
};
__publicField(_WebMapControls, "controls", {
  CONTROL: (webMap, options) => {
    return webMap.createControl(options.control, options.options);
  },
  BUTTON: (webMap, options) => {
    return webMap.createButtonControl(options);
  },
  TOGGLE: (webMap, options) => {
    return webMap.createToggleControl(options);
  }
});
let WebMapControls = _WebMapControls;

var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
class WebMap extends WebMapControls {
  constructor(mapOptions) {
    super(mapOptions);
    this._addControls();
    setWebMap(this.id, this);
  }
  static get(id) {
    return getWebMap(id);
  }
  /**
   * @internal
   */
  _addLayerProviders() {
    return __async$1(this, null, function* () {
      try {
        for (var iter2 = __forAwait(this._starterKits), more2, temp2, error2; more2 = !(temp2 = yield iter2.next()).done; more2 = false) {
          const kit = temp2.value;
          if (kit.getLayerAdapters) {
            const adapters = yield kit.getLayerAdapters.call(kit);
            if (adapters) {
              try {
                for (var iter = __forAwait(adapters), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
                  const adapter = temp.value;
                  const newAdapter = yield adapter.createAdapter(this);
                  if (newAdapter) {
                    this.mapAdapter.layerAdapters[adapter.name] = newAdapter;
                  }
                }
              } catch (temp) {
                error = [temp];
              } finally {
                try {
                  more && (temp = iter.return) && (yield temp.call(iter));
                } finally {
                  if (error)
                    throw error[0];
                }
              }
            }
          }
        }
      } catch (temp2) {
        error2 = [temp2];
      } finally {
        try {
          more2 && (temp2 = iter2.return) && (yield temp2.call(iter2));
        } finally {
          if (error2)
            throw error2[0];
        }
      }
    });
  }
  /**
   * @internal
   */
  _onLoadSync() {
    return __async$1(this, null, function* () {
      try {
        for (var iter = __forAwait(this._starterKits), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const kit = temp.value;
          if (kit.onLoadSync) {
            try {
              yield kit.onLoadSync.call(kit, this);
            } catch (er) {
              console.error(er);
            }
          }
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  _addControls() {
    if (this.options.controls) {
      this.options.controls.forEach((x) => {
        let controlAdapterName = x;
        let controlOptions = {};
        if (typeof x === "string" && this.options.controlsOptions) {
          if (this.options.controlsOptions[x]) {
            controlOptions = this.options.controlsOptions[x];
            if (controlOptions.control !== void 0) {
              controlAdapterName = controlOptions.control;
            }
          }
        }
        const _a = controlOptions, { position } = _a, options = __objRest(_a, ["position"]);
        this.addControl(controlAdapterName, position || "top-left", options);
      });
    }
    this._emitStatusEvent("controls:create");
  }
}

function getDefaultControls() {
  return ["ZOOM", "ATTRIBUTION"];
}

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function createWebMap(options) {
  return __async(this, null, function* () {
    const webMap = new WebMap(options);
    return webMap.onLoad();
  });
}

export { WebMap, WebMapControls, WebMapLayers, WebMapMain, createToggleControl, createWebMap, detectGeometryType, findMostFrequentGeomType, getDefaultControls, getWebMap, paintTypeAlias, setWebMap, typeAlias, updateGeoJsonAdapterOptions };
//# sourceMappingURL=webmap.esm-browser.js.map
