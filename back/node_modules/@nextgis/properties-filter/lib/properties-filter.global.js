/** Bundle of @nextgis/properties-filter; version: 3.0.0-alpha.13; author: NextGIS */
var PropertiesFilter = (function (exports) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  function reEscape(s) {
    return s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  function like(b, a, iLike) {
    a = String(a);
    b = String(b);
    if (a === b) return true;
    if (iLike && a.toUpperCase() === b.toUpperCase()) return true;
    const re = `^${reEscape(a)}$`.replace(/%/g, ".*").replace("_", ".");
    return new RegExp(re, iLike ? "i" : "").exec(b) !== null;
  }
  const operationsAliases = {
    // greater(>)
    gt: (a, b) => a > b,
    // lower(<)
    lt: (a, b) => a < b,
    // greater or equal(>=)
    ge: (a, b) => a >= b,
    // lower or equal(<=)
    le: (a, b) => a <= b,
    // equal(=)
    eq: (a, b) => a === b,
    //  not equal(!=)
    ne: (a, b) => a !== b,
    in: (a, b) => b.indexOf(a) !== -1,
    notin: (a, b) => b.indexOf(a) === -1,
    // LIKE SQL statement(for strings compare)
    like: (a, b) => {
      return like(a, b);
    },
    // ILIKE SQL statement(for strings compare)
    ilike: (a, b) => {
      return like(a, b, true);
    }
  };
  function isPropertyFilter(filter) {
    const pf = filter;
    if (pf.length === 3 && typeof pf[0] === "string" && typeof pf[1] === "string") {
      return true;
    }
    return false;
  }
  function checkIfPropertyFilter(filter) {
    return isPropertyFilter(filter);
  }
  function featureFilter(feature, filters) {
    const properties = __spreadValues({}, feature.properties);
    if (properties) {
      properties.$id = feature.id;
      return propertiesFilter(properties, filters);
    }
    return false;
  }
  function propertiesFilter(properties, filters) {
    const logic = typeof filters[0] === "string" ? filters[0] : "all";
    const filterFunction = (p) => {
      if (isPropertyFilter(p)) {
        const [field, operation, value] = p;
        const operationExec = operationsAliases[operation];
        if (operationExec) {
          if (operation === "like" || operation === "ilike") {
            if (typeof field === "string") {
              let prop = "";
              const value_ = field.replace(/^%?(\w+)%?$/, (match, cleanField) => {
                prop = properties[cleanField];
                return field.replace(cleanField, value);
              });
              return operationExec(prop, value_);
            }
          }
          return operationExec(properties[field], value);
        }
        return false;
      } else {
        return propertiesFilter(properties, p);
      }
    };
    const filters_ = filters.filter((x) => Array.isArray(x));
    return logic === "any" ? filters_.some(filterFunction) : filters_.every(filterFunction);
  }

  exports.checkIfPropertyFilter = checkIfPropertyFilter;
  exports.featureFilter = featureFilter;
  exports.isPropertyFilter = isPropertyFilter;
  exports.propertiesFilter = propertiesFilter;

  return exports;

})({});
//# sourceMappingURL=properties-filter.global.js.map
